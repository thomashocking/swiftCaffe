/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: caffe.proto
 *
 */

import Foundation
import SwiftProtobuf


public enum Phase: ProtobufEnum {
  public typealias RawValue = Int
  case train // = 0
  case test // = 1

  public init() {
    self = .train
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .train
    case 1: self = .test
    default: return nil
    }
  }

  public init?(name: String) {
    switch name {
    case "train": self = .train
    case "test": self = .test
    default: return nil
    }
  }

  public init?(jsonName: String) {
    switch jsonName {
    case "TRAIN": self = .train
    case "TEST": self = .test
    default: return nil
    }
  }

  public init?(protoName: String) {
    switch protoName {
    case "TRAIN": self = .train
    case "TEST": self = .test
    default: return nil
    }
  }

  public var rawValue: Int {
    get {
      switch self {
      case .train: return 0
      case .test: return 1
      }
    }
  }

  public var json: String {
    get {
      switch self {
      case .train: return "\"TRAIN\""
      case .test: return "\"TEST\""
      }
    }
  }

  public var hashValue: Int { return rawValue }

  public var debugDescription: String {
    get {
      switch self {
      case .train: return ".train"
      case .test: return ".test"
      }
    }
  }

}

///   Specifies the shape (dimensions) of a Blob.
public struct BlobShape: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "BlobShape"}
  public var protoMessageName: String {return "BlobShape"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "dim": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dim": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var dim: [Int64] = []

  public init() {}

  public init(dim: [Int64] = [])
  {
    if !dim.isEmpty {
      self.dim = dim
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodePackedField(fieldType: ProtobufInt64.self, value: &dim)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !dim.isEmpty {
      try visitor.visitPackedField(fieldType: ProtobufInt64.self, value: dim, protoFieldNumber: 1, protoFieldName: "dim", jsonFieldName: "dim", swiftFieldName: "dim")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: BlobShape) -> Bool {
    if dim != other.dim {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct BlobProto: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "BlobProto"}
  public var protoMessageName: String {return "BlobProto"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "shape": 7,
    "data": 5,
    "diff": 6,
    "doubleData": 8,
    "doubleDiff": 9,
    "num": 1,
    "channels": 2,
    "height": 3,
    "width": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "shape": 7,
    "data": 5,
    "diff": 6,
    "double_data": 8,
    "double_diff": 9,
    "num": 1,
    "channels": 2,
    "height": 3,
    "width": 4,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = BlobProto
    var unknown = ProtobufUnknownStorage()
    var _shape: BlobShape? = nil
    var _data: [Float] = []
    var _diff: [Float] = []
    var _doubleData: [Double] = []
    var _doubleDiff: [Double] = []
    var _num: Int32? = nil
    var _channels: Int32? = nil
    var _height: Int32? = nil
    var _width: Int32? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 7: handled = try setter.decodeOptionalMessageField(fieldType: BlobShape.self, value: &_shape)
      case 5: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &_data)
      case 6: handled = try setter.decodePackedField(fieldType: ProtobufFloat.self, value: &_diff)
      case 8: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &_doubleData)
      case 9: handled = try setter.decodePackedField(fieldType: ProtobufDouble.self, value: &_doubleDiff)
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_num)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_channels)
      case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_height)
      case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_width)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _num {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "num", jsonFieldName: "num", swiftFieldName: "num")
      }
      if let v = _channels {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "channels", jsonFieldName: "channels", swiftFieldName: "channels")
      }
      if let v = _height {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "height", jsonFieldName: "height", swiftFieldName: "height")
      }
      if let v = _width {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "width", jsonFieldName: "width", swiftFieldName: "width")
      }
      if !_data.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: _data, protoFieldNumber: 5, protoFieldName: "data", jsonFieldName: "data", swiftFieldName: "data")
      }
      if !_diff.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufFloat.self, value: _diff, protoFieldNumber: 6, protoFieldName: "diff", jsonFieldName: "diff", swiftFieldName: "diff")
      }
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 7, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      if !_doubleData.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: _doubleData, protoFieldNumber: 8, protoFieldName: "double_data", jsonFieldName: "doubleData", swiftFieldName: "doubleData")
      }
      if !_doubleDiff.isEmpty {
        try visitor.visitPackedField(fieldType: ProtobufDouble.self, value: _doubleDiff, protoFieldNumber: 9, protoFieldName: "double_diff", jsonFieldName: "doubleDiff", swiftFieldName: "doubleDiff")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_shape != nil || other._shape != nil) && (_shape == nil || other._shape == nil || _shape! != other._shape!)) {return false}
      if _data != other._data {return false}
      if _diff != other._diff {return false}
      if _doubleData != other._doubleData {return false}
      if _doubleDiff != other._doubleDiff {return false}
      if (((_num != nil && _num! != 0) || (other._num != nil && other._num! != 0)) && (_num == nil || other._num == nil || _num! != other._num!)) {return false}
      if (((_channels != nil && _channels! != 0) || (other._channels != nil && other._channels! != 0)) && (_channels == nil || other._channels == nil || _channels! != other._channels!)) {return false}
      if (((_height != nil && _height! != 0) || (other._height != nil && other._height! != 0)) && (_height == nil || other._height == nil || _height! != other._height!)) {return false}
      if (((_width != nil && _width! != 0) || (other._width != nil && other._width! != 0)) && (_width == nil || other._width == nil || _width! != other._width!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._shape = _shape
      clone._data = _data
      clone._diff = _diff
      clone._doubleData = _doubleData
      clone._doubleDiff = _doubleDiff
      clone._num = _num
      clone._channels = _channels
      clone._height = _height
      clone._width = _width
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var shape: BlobShape? {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  public var data: [Float] {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  public var diff: [Float] {
    get {return _storage._diff}
    set {_uniqueStorage()._diff = newValue}
  }

  public var doubleData: [Double] {
    get {return _storage._doubleData}
    set {_uniqueStorage()._doubleData = newValue}
  }

  public var doubleDiff: [Double] {
    get {return _storage._doubleDiff}
    set {_uniqueStorage()._doubleDiff = newValue}
  }

  ///   4D dimensions -- deprecated.  Use "shape" instead.
  public var num: Int32? {
    get {return _storage._num ?? 0}
    set {_uniqueStorage()._num = newValue}
  }

  public var channels: Int32? {
    get {return _storage._channels ?? 0}
    set {_uniqueStorage()._channels = newValue}
  }

  public var height: Int32? {
    get {return _storage._height ?? 0}
    set {_uniqueStorage()._height = newValue}
  }

  public var width: Int32? {
    get {return _storage._width ?? 0}
    set {_uniqueStorage()._width = newValue}
  }

  public init() {}

  public init(shape: BlobShape? = nil,
    data: [Float] = [],
    diff: [Float] = [],
    doubleData: [Double] = [],
    doubleDiff: [Double] = [],
    num: Int32? = nil,
    channels: Int32? = nil,
    height: Int32? = nil,
    width: Int32? = nil)
  {
    let storage = _uniqueStorage()
    storage._shape = shape
    if !data.isEmpty {
      storage._data = data
    }
    if !diff.isEmpty {
      storage._diff = diff
    }
    if !doubleData.isEmpty {
      storage._doubleData = doubleData
    }
    if !doubleDiff.isEmpty {
      storage._doubleDiff = doubleDiff
    }
    storage._num = num
    storage._channels = channels
    storage._height = height
    storage._width = width
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: BlobProto) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   The BlobProtoVector is simply a way to pass multiple blobproto instances
///   around.
public struct BlobProtoVector: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "BlobProtoVector"}
  public var protoMessageName: String {return "BlobProtoVector"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "blobs": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "blobs": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var blobs: [BlobProto] = []

  public init() {}

  public init(blobs: [BlobProto] = [])
  {
    if !blobs.isEmpty {
      self.blobs = blobs
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: BlobProto.self, value: &blobs)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !blobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: blobs, protoFieldNumber: 1, protoFieldName: "blobs", jsonFieldName: "blobs", swiftFieldName: "blobs")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: BlobProtoVector) -> Bool {
    if blobs != other.blobs {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct Datum: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "Datum"}
  public var protoMessageName: String {return "Datum"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "channels": 1,
    "height": 2,
    "width": 3,
    "data": 4,
    "label": 5,
    "floatData": 6,
    "encoded": 7,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "channels": 1,
    "height": 2,
    "width": 3,
    "data": 4,
    "label": 5,
    "float_data": 6,
    "encoded": 7,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var channels: Int32? = nil

  public var height: Int32? = nil

  public var width: Int32? = nil

  ///   the actual image data, in bytes
  public var data: Data? = nil

  public var label: Int32? = nil

  ///   Optionally, the datum could also hold float data.
  public var floatData: [Float] = []

  ///   If true data contains an encoded image that need to be decoded
  private var _encoded: Bool? = nil
  public var encoded: Bool? {
    get {return _encoded ?? false}
    set {_encoded = newValue}
  }

  public init() {}

  public init(channels: Int32? = nil,
    height: Int32? = nil,
    width: Int32? = nil,
    data: Data? = nil,
    label: Int32? = nil,
    floatData: [Float] = [],
    encoded: Bool? = nil)
  {
    self.channels = channels
    self.height = height
    self.width = width
    self.data = data
    self.label = label
    if !floatData.isEmpty {
      self.floatData = floatData
    }
    self.encoded = encoded
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &channels)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &height)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &width)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufBytes.self, value: &data)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &label)
    case 6: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &floatData)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &encoded)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = channels {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "channels", jsonFieldName: "channels", swiftFieldName: "channels")
    }
    if let v = height {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "height", jsonFieldName: "height", swiftFieldName: "height")
    }
    if let v = width {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "width", jsonFieldName: "width", swiftFieldName: "width")
    }
    if let v = data {
      try visitor.visitSingularField(fieldType: ProtobufBytes.self, value: v, protoFieldNumber: 4, protoFieldName: "data", jsonFieldName: "data", swiftFieldName: "data")
    }
    if let v = label {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "label", jsonFieldName: "label", swiftFieldName: "label")
    }
    if !floatData.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: floatData, protoFieldNumber: 6, protoFieldName: "float_data", jsonFieldName: "floatData", swiftFieldName: "floatData")
    }
    if let v = encoded {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 7, protoFieldName: "encoded", jsonFieldName: "encoded", swiftFieldName: "encoded")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: Datum) -> Bool {
    if ((channels != nil || other.channels != nil) && (channels == nil || other.channels == nil || channels! != other.channels!)) {return false}
    if ((height != nil || other.height != nil) && (height == nil || other.height == nil || height! != other.height!)) {return false}
    if ((width != nil || other.width != nil) && (width == nil || other.width == nil || width! != other.width!)) {return false}
    if ((data != nil || other.data != nil) && (data == nil || other.data == nil || data! != other.data!)) {return false}
    if ((label != nil || other.label != nil) && (label == nil || other.label == nil || label! != other.label!)) {return false}
    if floatData != other.floatData {return false}
    if (((encoded != nil && encoded! != false) || (other.encoded != nil && other.encoded! != false)) && (encoded == nil || other.encoded == nil || encoded! != other.encoded!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct FillerParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "FillerParameter"}
  public var protoMessageName: String {return "FillerParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "type": 1,
    "value": 2,
    "min": 3,
    "max": 4,
    "mean": 5,
    "std": 6,
    "sparse": 7,
    "varianceNorm": 8,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "type": 1,
    "value": 2,
    "min": 3,
    "max": 4,
    "mean": 5,
    "std": 6,
    "sparse": 7,
    "variance_norm": 8,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Normalize the filler variance by fan_in, fan_out, or their average.
  ///   Applies to 'xavier' and 'msra' fillers.
  public enum VarianceNorm: ProtobufEnum {
    public typealias RawValue = Int
    case fanIn // = 0
    case fanOut // = 1
    case average // = 2

    public init() {
      self = .fanIn
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fanIn
      case 1: self = .fanOut
      case 2: self = .average
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "fanIn": self = .fanIn
      case "fanOut": self = .fanOut
      case "average": self = .average
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "FAN_IN": self = .fanIn
      case "FAN_OUT": self = .fanOut
      case "AVERAGE": self = .average
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "FAN_IN": self = .fanIn
      case "FAN_OUT": self = .fanOut
      case "AVERAGE": self = .average
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .fanIn: return 0
        case .fanOut: return 1
        case .average: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .fanIn: return "\"FAN_IN\""
        case .fanOut: return "\"FAN_OUT\""
        case .average: return "\"AVERAGE\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .fanIn: return ".fanIn"
        case .fanOut: return ".fanOut"
        case .average: return ".average"
        }
      }
    }

  }

  ///   The filler type.
  private var _type: String? = nil
  public var type: String? {
    get {return _type ?? "constant"}
    set {_type = newValue}
  }

  ///   the value in constant filler
  private var _value: Float? = nil
  public var value: Float? {
    get {return _value ?? 0}
    set {_value = newValue}
  }

  ///   the min value in uniform filler
  private var _min: Float? = nil
  public var min: Float? {
    get {return _min ?? 0}
    set {_min = newValue}
  }

  ///   the max value in uniform filler
  private var _max: Float? = nil
  public var max: Float? {
    get {return _max ?? 1}
    set {_max = newValue}
  }

  ///   the mean value in Gaussian filler
  private var _mean: Float? = nil
  public var mean: Float? {
    get {return _mean ?? 0}
    set {_mean = newValue}
  }

  ///   the std value in Gaussian filler
  private var _std: Float? = nil
  public var std: Float? {
    get {return _std ?? 1}
    set {_std = newValue}
  }

  ///   The expected number of non-zero output weights for a given input in
  ///   Gaussian filler -- the default -1 means don't perform sparsification.
  private var _sparse: Int32? = nil
  public var sparse: Int32? {
    get {return _sparse ?? -1}
    set {_sparse = newValue}
  }

  private var _varianceNorm: FillerParameter.VarianceNorm? = nil
  public var varianceNorm: FillerParameter.VarianceNorm? {
    get {return _varianceNorm ?? FillerParameter.VarianceNorm.fanIn}
    set {_varianceNorm = newValue}
  }

  public init() {}

  public init(type: String? = nil,
    value: Float? = nil,
    min: Float? = nil,
    max: Float? = nil,
    mean: Float? = nil,
    std: Float? = nil,
    sparse: Int32? = nil,
    varianceNorm: FillerParameter.VarianceNorm? = nil)
  {
    self.type = type
    self.value = value
    self.min = min
    self.max = max
    self.mean = mean
    self.std = std
    self.sparse = sparse
    self.varianceNorm = varianceNorm
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &type)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &value)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &min)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &max)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &mean)
    case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &std)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &sparse)
    case 8: handled = try setter.decodeOptionalField(fieldType: FillerParameter.VarianceNorm.self, value: &varianceNorm)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = type {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
    }
    if let v = value {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "value", jsonFieldName: "value", swiftFieldName: "value")
    }
    if let v = min {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "min", jsonFieldName: "min", swiftFieldName: "min")
    }
    if let v = max {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 4, protoFieldName: "max", jsonFieldName: "max", swiftFieldName: "max")
    }
    if let v = mean {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 5, protoFieldName: "mean", jsonFieldName: "mean", swiftFieldName: "mean")
    }
    if let v = std {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 6, protoFieldName: "std", jsonFieldName: "std", swiftFieldName: "std")
    }
    if let v = sparse {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 7, protoFieldName: "sparse", jsonFieldName: "sparse", swiftFieldName: "sparse")
    }
    if let v = varianceNorm {
      try visitor.visitSingularField(fieldType: FillerParameter.VarianceNorm.self, value: v, protoFieldNumber: 8, protoFieldName: "variance_norm", jsonFieldName: "varianceNorm", swiftFieldName: "varianceNorm")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: FillerParameter) -> Bool {
    if (((type != nil && type! != "constant") || (other.type != nil && other.type! != "constant")) && (type == nil || other.type == nil || type! != other.type!)) {return false}
    if (((value != nil && value! != 0) || (other.value != nil && other.value! != 0)) && (value == nil || other.value == nil || value! != other.value!)) {return false}
    if (((min != nil && min! != 0) || (other.min != nil && other.min! != 0)) && (min == nil || other.min == nil || min! != other.min!)) {return false}
    if (((max != nil && max! != 1) || (other.max != nil && other.max! != 1)) && (max == nil || other.max == nil || max! != other.max!)) {return false}
    if (((mean != nil && mean! != 0) || (other.mean != nil && other.mean! != 0)) && (mean == nil || other.mean == nil || mean! != other.mean!)) {return false}
    if (((std != nil && std! != 1) || (other.std != nil && other.std! != 1)) && (std == nil || other.std == nil || std! != other.std!)) {return false}
    if (((sparse != nil && sparse! != -1) || (other.sparse != nil && other.sparse! != -1)) && (sparse == nil || other.sparse == nil || sparse! != other.sparse!)) {return false}
    if (((varianceNorm != nil && varianceNorm! != FillerParameter.VarianceNorm.fanIn) || (other.varianceNorm != nil && other.varianceNorm! != FillerParameter.VarianceNorm.fanIn)) && (varianceNorm == nil || other.varianceNorm == nil || varianceNorm! != other.varianceNorm!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct NetParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "NetParameter"}
  public var protoMessageName: String {return "NetParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "input": 3,
    "inputShape": 8,
    "inputDim": 4,
    "forceBackward": 5,
    "state": 6,
    "debugInfo": 7,
    "layer": 100,
    "layers": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "input": 3,
    "input_shape": 8,
    "input_dim": 4,
    "force_backward": 5,
    "state": 6,
    "debug_info": 7,
    "layer": 100,
    "layers": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = NetParameter
    var unknown = ProtobufUnknownStorage()
    var _name: String? = nil
    var _input: [String] = []
    var _inputShape: [BlobShape] = []
    var _inputDim: [Int32] = []
    var _forceBackward: Bool? = nil
    var _state: NetState? = nil
    var _debugInfo: Bool? = nil
    var _layer: [LayerParameter] = []
    var _layers: [V1LayerParameter] = []

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_name)
      case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_input)
      case 8: handled = try setter.decodeRepeatedMessageField(fieldType: BlobShape.self, value: &_inputShape)
      case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufInt32.self, value: &_inputDim)
      case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_forceBackward)
      case 6: handled = try setter.decodeOptionalMessageField(fieldType: NetState.self, value: &_state)
      case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_debugInfo)
      case 100: handled = try setter.decodeRepeatedMessageField(fieldType: LayerParameter.self, value: &_layer)
      case 2: handled = try setter.decodeRepeatedMessageField(fieldType: V1LayerParameter.self, value: &_layers)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if !_layers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _layers, protoFieldNumber: 2, protoFieldName: "layers", jsonFieldName: "layers", swiftFieldName: "layers")
      }
      if !_input.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _input, protoFieldNumber: 3, protoFieldName: "input", jsonFieldName: "input", swiftFieldName: "input")
      }
      if !_inputDim.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufInt32.self, value: _inputDim, protoFieldNumber: 4, protoFieldName: "input_dim", jsonFieldName: "inputDim", swiftFieldName: "inputDim")
      }
      if let v = _forceBackward {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 5, protoFieldName: "force_backward", jsonFieldName: "forceBackward", swiftFieldName: "forceBackward")
      }
      if let v = _state {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 6, protoFieldName: "state", jsonFieldName: "state", swiftFieldName: "state")
      }
      if let v = _debugInfo {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 7, protoFieldName: "debug_info", jsonFieldName: "debugInfo", swiftFieldName: "debugInfo")
      }
      if !_inputShape.isEmpty {
        try visitor.visitRepeatedMessageField(value: _inputShape, protoFieldNumber: 8, protoFieldName: "input_shape", jsonFieldName: "inputShape", swiftFieldName: "inputShape")
      }
      if !_layer.isEmpty {
        try visitor.visitRepeatedMessageField(value: _layer, protoFieldNumber: 100, protoFieldName: "layer", jsonFieldName: "layer", swiftFieldName: "layer")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_name != nil || other._name != nil) && (_name == nil || other._name == nil || _name! != other._name!)) {return false}
      if _input != other._input {return false}
      if _inputShape != other._inputShape {return false}
      if _inputDim != other._inputDim {return false}
      if (((_forceBackward != nil && _forceBackward! != false) || (other._forceBackward != nil && other._forceBackward! != false)) && (_forceBackward == nil || other._forceBackward == nil || _forceBackward! != other._forceBackward!)) {return false}
      if ((_state != nil || other._state != nil) && (_state == nil || other._state == nil || _state! != other._state!)) {return false}
      if (((_debugInfo != nil && _debugInfo! != false) || (other._debugInfo != nil && other._debugInfo! != false)) && (_debugInfo == nil || other._debugInfo == nil || _debugInfo! != other._debugInfo!)) {return false}
      if _layer != other._layer {return false}
      if _layers != other._layers {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._input = _input
      clone._inputShape = _inputShape
      clone._inputDim = _inputDim
      clone._forceBackward = _forceBackward
      clone._state = _state
      clone._debugInfo = _debugInfo
      clone._layer = _layer
      clone._layers = _layers
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   consider giving the network a name
  public var name: String? {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///   DEPRECATED. See InputParameter. The input blobs to the network.
  public var input: [String] {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  ///   DEPRECATED. See InputParameter. The shape of the input blobs.
  public var inputShape: [BlobShape] {
    get {return _storage._inputShape}
    set {_uniqueStorage()._inputShape = newValue}
  }

  ///   4D input dimensions -- deprecated.  Use "input_shape" instead.
  ///   If specified, for each input blob there should be four
  ///   values specifying the num, channels, height and width of the input blob.
  ///   Thus, there should be a total of (4 * #input) numbers.
  public var inputDim: [Int32] {
    get {return _storage._inputDim}
    set {_uniqueStorage()._inputDim = newValue}
  }

  ///   Whether the network will force every layer to carry out backward operation.
  ///   If set False, then whether to carry out backward is determined
  ///   automatically according to the net structure and learning rates.
  public var forceBackward: Bool? {
    get {return _storage._forceBackward ?? false}
    set {_uniqueStorage()._forceBackward = newValue}
  }

  ///   The current "state" of the network, including the phase, level, and stage.
  ///   Some layers may be included/excluded depending on this state and the states
  ///   specified in the layers' include and exclude fields.
  public var state: NetState? {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  ///   Print debugging information about results while running Net::Forward,
  ///   Net::Backward, and Net::Update.
  public var debugInfo: Bool? {
    get {return _storage._debugInfo ?? false}
    set {_uniqueStorage()._debugInfo = newValue}
  }

  ///   The layers that make up the net.  Each of their configurations, including
  ///   connectivity and behavior, is specified as a LayerParameter.
  public var layer: [LayerParameter] {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  ///   DEPRECATED: use 'layer' instead.
  public var layers: [V1LayerParameter] {
    get {return _storage._layers}
    set {_uniqueStorage()._layers = newValue}
  }

  public init() {}

  public init(name: String? = nil,
    input: [String] = [],
    inputShape: [BlobShape] = [],
    inputDim: [Int32] = [],
    forceBackward: Bool? = nil,
    state: NetState? = nil,
    debugInfo: Bool? = nil,
    layer: [LayerParameter] = [],
    layers: [V1LayerParameter] = [])
  {
    let storage = _uniqueStorage()
    storage._name = name
    if !input.isEmpty {
      storage._input = input
    }
    if !inputShape.isEmpty {
      storage._inputShape = inputShape
    }
    if !inputDim.isEmpty {
      storage._inputDim = inputDim
    }
    storage._forceBackward = forceBackward
    storage._state = state
    storage._debugInfo = debugInfo
    if !layer.isEmpty {
      storage._layer = layer
    }
    if !layers.isEmpty {
      storage._layers = layers
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: NetParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   NOTE
///   Update the next available ID when you add a new SolverParameter field.
///  
///   SolverParameter next available ID: 42 (last added: layer_wise_reduce)
public struct SolverParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "SolverParameter"}
  public var protoMessageName: String {return "SolverParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "net": 24,
    "netParam": 25,
    "trainNet": 1,
    "testNet": 2,
    "trainNetParam": 21,
    "testNetParam": 22,
    "trainState": 26,
    "testState": 27,
    "testIter": 3,
    "testInterval": 4,
    "testComputeLoss": 19,
    "testInitialization": 32,
    "baseLr": 5,
    "display": 6,
    "averageLoss": 33,
    "maxIter": 7,
    "iterSize": 36,
    "lrPolicy": 8,
    "gamma": 9,
    "power": 10,
    "momentum": 11,
    "weightDecay": 12,
    "regularizationType": 29,
    "stepsize": 13,
    "stepvalue": 34,
    "clipGradients": 35,
    "snapshot": 14,
    "snapshotPrefix": 15,
    "snapshotDiff": 16,
    "snapshotFormat": 37,
    "solverMode": 17,
    "deviceId": 18,
    "randomSeed": 20,
    "type": 40,
    "delta": 31,
    "momentum2": 39,
    "rmsDecay": 38,
    "debugInfo": 23,
    "snapshotAfterTrain": 28,
    "solverType": 30,
    "layerWiseReduce": 41,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "net": 24,
    "net_param": 25,
    "train_net": 1,
    "test_net": 2,
    "train_net_param": 21,
    "test_net_param": 22,
    "train_state": 26,
    "test_state": 27,
    "test_iter": 3,
    "test_interval": 4,
    "test_compute_loss": 19,
    "test_initialization": 32,
    "base_lr": 5,
    "display": 6,
    "average_loss": 33,
    "max_iter": 7,
    "iter_size": 36,
    "lr_policy": 8,
    "gamma": 9,
    "power": 10,
    "momentum": 11,
    "weight_decay": 12,
    "regularization_type": 29,
    "stepsize": 13,
    "stepvalue": 34,
    "clip_gradients": 35,
    "snapshot": 14,
    "snapshot_prefix": 15,
    "snapshot_diff": 16,
    "snapshot_format": 37,
    "solver_mode": 17,
    "device_id": 18,
    "random_seed": 20,
    "type": 40,
    "delta": 31,
    "momentum2": 39,
    "rms_decay": 38,
    "debug_info": 23,
    "snapshot_after_train": 28,
    "solver_type": 30,
    "layer_wise_reduce": 41,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = SolverParameter
    var unknown = ProtobufUnknownStorage()
    var _net: String? = nil
    var _netParam: NetParameter? = nil
    var _trainNet: String? = nil
    var _testNet: [String] = []
    var _trainNetParam: NetParameter? = nil
    var _testNetParam: [NetParameter] = []
    var _trainState: NetState? = nil
    var _testState: [NetState] = []
    var _testIter: [Int32] = []
    var _testInterval: Int32? = nil
    var _testComputeLoss: Bool? = nil
    var _testInitialization: Bool? = nil
    var _baseLr: Float? = nil
    var _display: Int32? = nil
    var _averageLoss: Int32? = nil
    var _maxIter: Int32? = nil
    var _iterSize: Int32? = nil
    var _lrPolicy: String? = nil
    var _gamma: Float? = nil
    var _power: Float? = nil
    var _momentum: Float? = nil
    var _weightDecay: Float? = nil
    var _regularizationType: String? = nil
    var _stepsize: Int32? = nil
    var _stepvalue: [Int32] = []
    var _clipGradients: Float? = nil
    var _snapshot: Int32? = nil
    var _snapshotPrefix: String? = nil
    var _snapshotDiff: Bool? = nil
    var _snapshotFormat: SolverParameter.SnapshotFormat? = nil
    var _solverMode: SolverParameter.SolverMode? = nil
    var _deviceId: Int32? = nil
    var _randomSeed: Int64? = nil
    var _type: String? = nil
    var _delta: Float? = nil
    var _momentum2: Float? = nil
    var _rmsDecay: Float? = nil
    var _debugInfo: Bool? = nil
    var _snapshotAfterTrain: Bool? = nil
    var _solverType: SolverParameter.SolverType? = nil
    var _layerWiseReduce: Bool? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 24: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_net)
      case 25: handled = try setter.decodeOptionalMessageField(fieldType: NetParameter.self, value: &_netParam)
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_trainNet)
      case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_testNet)
      case 21: handled = try setter.decodeOptionalMessageField(fieldType: NetParameter.self, value: &_trainNetParam)
      case 22: handled = try setter.decodeRepeatedMessageField(fieldType: NetParameter.self, value: &_testNetParam)
      case 26: handled = try setter.decodeOptionalMessageField(fieldType: NetState.self, value: &_trainState)
      case 27: handled = try setter.decodeRepeatedMessageField(fieldType: NetState.self, value: &_testState)
      case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufInt32.self, value: &_testIter)
      case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_testInterval)
      case 19: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_testComputeLoss)
      case 32: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_testInitialization)
      case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_baseLr)
      case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_display)
      case 33: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_averageLoss)
      case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_maxIter)
      case 36: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_iterSize)
      case 8: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_lrPolicy)
      case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_gamma)
      case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_power)
      case 11: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_momentum)
      case 12: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_weightDecay)
      case 29: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_regularizationType)
      case 13: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_stepsize)
      case 34: handled = try setter.decodeRepeatedField(fieldType: ProtobufInt32.self, value: &_stepvalue)
      case 35: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_clipGradients)
      case 14: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_snapshot)
      case 15: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_snapshotPrefix)
      case 16: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_snapshotDiff)
      case 37: handled = try setter.decodeOptionalField(fieldType: SolverParameter.SnapshotFormat.self, value: &_snapshotFormat)
      case 17: handled = try setter.decodeOptionalField(fieldType: SolverParameter.SolverMode.self, value: &_solverMode)
      case 18: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_deviceId)
      case 20: handled = try setter.decodeOptionalField(fieldType: ProtobufInt64.self, value: &_randomSeed)
      case 40: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_type)
      case 31: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_delta)
      case 39: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_momentum2)
      case 38: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_rmsDecay)
      case 23: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_debugInfo)
      case 28: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_snapshotAfterTrain)
      case 30: handled = try setter.decodeOptionalField(fieldType: SolverParameter.SolverType.self, value: &_solverType)
      case 41: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_layerWiseReduce)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _trainNet {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "train_net", jsonFieldName: "trainNet", swiftFieldName: "trainNet")
      }
      if !_testNet.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _testNet, protoFieldNumber: 2, protoFieldName: "test_net", jsonFieldName: "testNet", swiftFieldName: "testNet")
      }
      if !_testIter.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufInt32.self, value: _testIter, protoFieldNumber: 3, protoFieldName: "test_iter", jsonFieldName: "testIter", swiftFieldName: "testIter")
      }
      if let v = _testInterval {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "test_interval", jsonFieldName: "testInterval", swiftFieldName: "testInterval")
      }
      if let v = _baseLr {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 5, protoFieldName: "base_lr", jsonFieldName: "baseLr", swiftFieldName: "baseLr")
      }
      if let v = _display {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 6, protoFieldName: "display", jsonFieldName: "display", swiftFieldName: "display")
      }
      if let v = _maxIter {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 7, protoFieldName: "max_iter", jsonFieldName: "maxIter", swiftFieldName: "maxIter")
      }
      if let v = _lrPolicy {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 8, protoFieldName: "lr_policy", jsonFieldName: "lrPolicy", swiftFieldName: "lrPolicy")
      }
      if let v = _gamma {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 9, protoFieldName: "gamma", jsonFieldName: "gamma", swiftFieldName: "gamma")
      }
      if let v = _power {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 10, protoFieldName: "power", jsonFieldName: "power", swiftFieldName: "power")
      }
      if let v = _momentum {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 11, protoFieldName: "momentum", jsonFieldName: "momentum", swiftFieldName: "momentum")
      }
      if let v = _weightDecay {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 12, protoFieldName: "weight_decay", jsonFieldName: "weightDecay", swiftFieldName: "weightDecay")
      }
      if let v = _stepsize {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 13, protoFieldName: "stepsize", jsonFieldName: "stepsize", swiftFieldName: "stepsize")
      }
      if let v = _snapshot {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 14, protoFieldName: "snapshot", jsonFieldName: "snapshot", swiftFieldName: "snapshot")
      }
      if let v = _snapshotPrefix {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 15, protoFieldName: "snapshot_prefix", jsonFieldName: "snapshotPrefix", swiftFieldName: "snapshotPrefix")
      }
      if let v = _snapshotDiff {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 16, protoFieldName: "snapshot_diff", jsonFieldName: "snapshotDiff", swiftFieldName: "snapshotDiff")
      }
      if let v = _solverMode {
        try visitor.visitSingularField(fieldType: SolverParameter.SolverMode.self, value: v, protoFieldNumber: 17, protoFieldName: "solver_mode", jsonFieldName: "solverMode", swiftFieldName: "solverMode")
      }
      if let v = _deviceId {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 18, protoFieldName: "device_id", jsonFieldName: "deviceId", swiftFieldName: "deviceId")
      }
      if let v = _testComputeLoss {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 19, protoFieldName: "test_compute_loss", jsonFieldName: "testComputeLoss", swiftFieldName: "testComputeLoss")
      }
      if let v = _randomSeed {
        try visitor.visitSingularField(fieldType: ProtobufInt64.self, value: v, protoFieldNumber: 20, protoFieldName: "random_seed", jsonFieldName: "randomSeed", swiftFieldName: "randomSeed")
      }
      if let v = _trainNetParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 21, protoFieldName: "train_net_param", jsonFieldName: "trainNetParam", swiftFieldName: "trainNetParam")
      }
      if !_testNetParam.isEmpty {
        try visitor.visitRepeatedMessageField(value: _testNetParam, protoFieldNumber: 22, protoFieldName: "test_net_param", jsonFieldName: "testNetParam", swiftFieldName: "testNetParam")
      }
      if let v = _debugInfo {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 23, protoFieldName: "debug_info", jsonFieldName: "debugInfo", swiftFieldName: "debugInfo")
      }
      if let v = _net {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 24, protoFieldName: "net", jsonFieldName: "net", swiftFieldName: "net")
      }
      if let v = _netParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 25, protoFieldName: "net_param", jsonFieldName: "netParam", swiftFieldName: "netParam")
      }
      if let v = _trainState {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 26, protoFieldName: "train_state", jsonFieldName: "trainState", swiftFieldName: "trainState")
      }
      if !_testState.isEmpty {
        try visitor.visitRepeatedMessageField(value: _testState, protoFieldNumber: 27, protoFieldName: "test_state", jsonFieldName: "testState", swiftFieldName: "testState")
      }
      if let v = _snapshotAfterTrain {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 28, protoFieldName: "snapshot_after_train", jsonFieldName: "snapshotAfterTrain", swiftFieldName: "snapshotAfterTrain")
      }
      if let v = _regularizationType {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 29, protoFieldName: "regularization_type", jsonFieldName: "regularizationType", swiftFieldName: "regularizationType")
      }
      if let v = _solverType {
        try visitor.visitSingularField(fieldType: SolverParameter.SolverType.self, value: v, protoFieldNumber: 30, protoFieldName: "solver_type", jsonFieldName: "solverType", swiftFieldName: "solverType")
      }
      if let v = _delta {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 31, protoFieldName: "delta", jsonFieldName: "delta", swiftFieldName: "delta")
      }
      if let v = _testInitialization {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 32, protoFieldName: "test_initialization", jsonFieldName: "testInitialization", swiftFieldName: "testInitialization")
      }
      if let v = _averageLoss {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 33, protoFieldName: "average_loss", jsonFieldName: "averageLoss", swiftFieldName: "averageLoss")
      }
      if !_stepvalue.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufInt32.self, value: _stepvalue, protoFieldNumber: 34, protoFieldName: "stepvalue", jsonFieldName: "stepvalue", swiftFieldName: "stepvalue")
      }
      if let v = _clipGradients {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 35, protoFieldName: "clip_gradients", jsonFieldName: "clipGradients", swiftFieldName: "clipGradients")
      }
      if let v = _iterSize {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 36, protoFieldName: "iter_size", jsonFieldName: "iterSize", swiftFieldName: "iterSize")
      }
      if let v = _snapshotFormat {
        try visitor.visitSingularField(fieldType: SolverParameter.SnapshotFormat.self, value: v, protoFieldNumber: 37, protoFieldName: "snapshot_format", jsonFieldName: "snapshotFormat", swiftFieldName: "snapshotFormat")
      }
      if let v = _rmsDecay {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 38, protoFieldName: "rms_decay", jsonFieldName: "rmsDecay", swiftFieldName: "rmsDecay")
      }
      if let v = _momentum2 {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 39, protoFieldName: "momentum2", jsonFieldName: "momentum2", swiftFieldName: "momentum2")
      }
      if let v = _type {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 40, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
      }
      if let v = _layerWiseReduce {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 41, protoFieldName: "layer_wise_reduce", jsonFieldName: "layerWiseReduce", swiftFieldName: "layerWiseReduce")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_net != nil || other._net != nil) && (_net == nil || other._net == nil || _net! != other._net!)) {return false}
      if ((_netParam != nil || other._netParam != nil) && (_netParam == nil || other._netParam == nil || _netParam! != other._netParam!)) {return false}
      if ((_trainNet != nil || other._trainNet != nil) && (_trainNet == nil || other._trainNet == nil || _trainNet! != other._trainNet!)) {return false}
      if _testNet != other._testNet {return false}
      if ((_trainNetParam != nil || other._trainNetParam != nil) && (_trainNetParam == nil || other._trainNetParam == nil || _trainNetParam! != other._trainNetParam!)) {return false}
      if _testNetParam != other._testNetParam {return false}
      if ((_trainState != nil || other._trainState != nil) && (_trainState == nil || other._trainState == nil || _trainState! != other._trainState!)) {return false}
      if _testState != other._testState {return false}
      if _testIter != other._testIter {return false}
      if (((_testInterval != nil && _testInterval! != 0) || (other._testInterval != nil && other._testInterval! != 0)) && (_testInterval == nil || other._testInterval == nil || _testInterval! != other._testInterval!)) {return false}
      if (((_testComputeLoss != nil && _testComputeLoss! != false) || (other._testComputeLoss != nil && other._testComputeLoss! != false)) && (_testComputeLoss == nil || other._testComputeLoss == nil || _testComputeLoss! != other._testComputeLoss!)) {return false}
      if (((_testInitialization != nil && _testInitialization! != true) || (other._testInitialization != nil && other._testInitialization! != true)) && (_testInitialization == nil || other._testInitialization == nil || _testInitialization! != other._testInitialization!)) {return false}
      if ((_baseLr != nil || other._baseLr != nil) && (_baseLr == nil || other._baseLr == nil || _baseLr! != other._baseLr!)) {return false}
      if ((_display != nil || other._display != nil) && (_display == nil || other._display == nil || _display! != other._display!)) {return false}
      if (((_averageLoss != nil && _averageLoss! != 1) || (other._averageLoss != nil && other._averageLoss! != 1)) && (_averageLoss == nil || other._averageLoss == nil || _averageLoss! != other._averageLoss!)) {return false}
      if ((_maxIter != nil || other._maxIter != nil) && (_maxIter == nil || other._maxIter == nil || _maxIter! != other._maxIter!)) {return false}
      if (((_iterSize != nil && _iterSize! != 1) || (other._iterSize != nil && other._iterSize! != 1)) && (_iterSize == nil || other._iterSize == nil || _iterSize! != other._iterSize!)) {return false}
      if ((_lrPolicy != nil || other._lrPolicy != nil) && (_lrPolicy == nil || other._lrPolicy == nil || _lrPolicy! != other._lrPolicy!)) {return false}
      if ((_gamma != nil || other._gamma != nil) && (_gamma == nil || other._gamma == nil || _gamma! != other._gamma!)) {return false}
      if ((_power != nil || other._power != nil) && (_power == nil || other._power == nil || _power! != other._power!)) {return false}
      if ((_momentum != nil || other._momentum != nil) && (_momentum == nil || other._momentum == nil || _momentum! != other._momentum!)) {return false}
      if ((_weightDecay != nil || other._weightDecay != nil) && (_weightDecay == nil || other._weightDecay == nil || _weightDecay! != other._weightDecay!)) {return false}
      if (((_regularizationType != nil && _regularizationType! != "L2") || (other._regularizationType != nil && other._regularizationType! != "L2")) && (_regularizationType == nil || other._regularizationType == nil || _regularizationType! != other._regularizationType!)) {return false}
      if ((_stepsize != nil || other._stepsize != nil) && (_stepsize == nil || other._stepsize == nil || _stepsize! != other._stepsize!)) {return false}
      if _stepvalue != other._stepvalue {return false}
      if (((_clipGradients != nil && _clipGradients! != -1) || (other._clipGradients != nil && other._clipGradients! != -1)) && (_clipGradients == nil || other._clipGradients == nil || _clipGradients! != other._clipGradients!)) {return false}
      if (((_snapshot != nil && _snapshot! != 0) || (other._snapshot != nil && other._snapshot! != 0)) && (_snapshot == nil || other._snapshot == nil || _snapshot! != other._snapshot!)) {return false}
      if ((_snapshotPrefix != nil || other._snapshotPrefix != nil) && (_snapshotPrefix == nil || other._snapshotPrefix == nil || _snapshotPrefix! != other._snapshotPrefix!)) {return false}
      if (((_snapshotDiff != nil && _snapshotDiff! != false) || (other._snapshotDiff != nil && other._snapshotDiff! != false)) && (_snapshotDiff == nil || other._snapshotDiff == nil || _snapshotDiff! != other._snapshotDiff!)) {return false}
      if (((_snapshotFormat != nil && _snapshotFormat! != SolverParameter.SnapshotFormat.binaryproto) || (other._snapshotFormat != nil && other._snapshotFormat! != SolverParameter.SnapshotFormat.binaryproto)) && (_snapshotFormat == nil || other._snapshotFormat == nil || _snapshotFormat! != other._snapshotFormat!)) {return false}
      if (((_solverMode != nil && _solverMode! != SolverParameter.SolverMode.gpu) || (other._solverMode != nil && other._solverMode! != SolverParameter.SolverMode.gpu)) && (_solverMode == nil || other._solverMode == nil || _solverMode! != other._solverMode!)) {return false}
      if (((_deviceId != nil && _deviceId! != 0) || (other._deviceId != nil && other._deviceId! != 0)) && (_deviceId == nil || other._deviceId == nil || _deviceId! != other._deviceId!)) {return false}
      if (((_randomSeed != nil && _randomSeed! != -1) || (other._randomSeed != nil && other._randomSeed! != -1)) && (_randomSeed == nil || other._randomSeed == nil || _randomSeed! != other._randomSeed!)) {return false}
      if (((_type != nil && _type! != "SGD") || (other._type != nil && other._type! != "SGD")) && (_type == nil || other._type == nil || _type! != other._type!)) {return false}
      if (((_delta != nil && _delta! != 1e-08) || (other._delta != nil && other._delta! != 1e-08)) && (_delta == nil || other._delta == nil || _delta! != other._delta!)) {return false}
      if (((_momentum2 != nil && _momentum2! != 0.999) || (other._momentum2 != nil && other._momentum2! != 0.999)) && (_momentum2 == nil || other._momentum2 == nil || _momentum2! != other._momentum2!)) {return false}
      if (((_rmsDecay != nil && _rmsDecay! != 0.99) || (other._rmsDecay != nil && other._rmsDecay! != 0.99)) && (_rmsDecay == nil || other._rmsDecay == nil || _rmsDecay! != other._rmsDecay!)) {return false}
      if (((_debugInfo != nil && _debugInfo! != false) || (other._debugInfo != nil && other._debugInfo! != false)) && (_debugInfo == nil || other._debugInfo == nil || _debugInfo! != other._debugInfo!)) {return false}
      if (((_snapshotAfterTrain != nil && _snapshotAfterTrain! != true) || (other._snapshotAfterTrain != nil && other._snapshotAfterTrain! != true)) && (_snapshotAfterTrain == nil || other._snapshotAfterTrain == nil || _snapshotAfterTrain! != other._snapshotAfterTrain!)) {return false}
      if (((_solverType != nil && _solverType! != SolverParameter.SolverType.sgd) || (other._solverType != nil && other._solverType! != SolverParameter.SolverType.sgd)) && (_solverType == nil || other._solverType == nil || _solverType! != other._solverType!)) {return false}
      if (((_layerWiseReduce != nil && _layerWiseReduce! != true) || (other._layerWiseReduce != nil && other._layerWiseReduce! != true)) && (_layerWiseReduce == nil || other._layerWiseReduce == nil || _layerWiseReduce! != other._layerWiseReduce!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._net = _net
      clone._netParam = _netParam
      clone._trainNet = _trainNet
      clone._testNet = _testNet
      clone._trainNetParam = _trainNetParam
      clone._testNetParam = _testNetParam
      clone._trainState = _trainState
      clone._testState = _testState
      clone._testIter = _testIter
      clone._testInterval = _testInterval
      clone._testComputeLoss = _testComputeLoss
      clone._testInitialization = _testInitialization
      clone._baseLr = _baseLr
      clone._display = _display
      clone._averageLoss = _averageLoss
      clone._maxIter = _maxIter
      clone._iterSize = _iterSize
      clone._lrPolicy = _lrPolicy
      clone._gamma = _gamma
      clone._power = _power
      clone._momentum = _momentum
      clone._weightDecay = _weightDecay
      clone._regularizationType = _regularizationType
      clone._stepsize = _stepsize
      clone._stepvalue = _stepvalue
      clone._clipGradients = _clipGradients
      clone._snapshot = _snapshot
      clone._snapshotPrefix = _snapshotPrefix
      clone._snapshotDiff = _snapshotDiff
      clone._snapshotFormat = _snapshotFormat
      clone._solverMode = _solverMode
      clone._deviceId = _deviceId
      clone._randomSeed = _randomSeed
      clone._type = _type
      clone._delta = _delta
      clone._momentum2 = _momentum2
      clone._rmsDecay = _rmsDecay
      clone._debugInfo = _debugInfo
      clone._snapshotAfterTrain = _snapshotAfterTrain
      clone._solverType = _solverType
      clone._layerWiseReduce = _layerWiseReduce
      return clone
    }
  }

  private var _storage = _StorageClass()

  public enum SnapshotFormat: ProtobufEnum {
    public typealias RawValue = Int
    case hdf5 // = 0
    case binaryproto // = 1

    public init() {
      self = .hdf5
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .hdf5
      case 1: self = .binaryproto
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "hdf5": self = .hdf5
      case "binaryproto": self = .binaryproto
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "HDF5": self = .hdf5
      case "BINARYPROTO": self = .binaryproto
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "HDF5": self = .hdf5
      case "BINARYPROTO": self = .binaryproto
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .hdf5: return 0
        case .binaryproto: return 1
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .hdf5: return "\"HDF5\""
        case .binaryproto: return "\"BINARYPROTO\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .hdf5: return ".hdf5"
        case .binaryproto: return ".binaryproto"
        }
      }
    }

  }

  ///   the mode solver will use: 0 for CPU and 1 for GPU. Use GPU in default.
  public enum SolverMode: ProtobufEnum {
    public typealias RawValue = Int
    case cpu // = 0
    case gpu // = 1

    public init() {
      self = .cpu
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cpu
      case 1: self = .gpu
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "cpu": self = .cpu
      case "gpu": self = .gpu
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "CPU": self = .cpu
      case "GPU": self = .gpu
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "CPU": self = .cpu
      case "GPU": self = .gpu
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .cpu: return 0
        case .gpu: return 1
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .cpu: return "\"CPU\""
        case .gpu: return "\"GPU\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .cpu: return ".cpu"
        case .gpu: return ".gpu"
        }
      }
    }

  }

  ///   DEPRECATED: old solver enum types, use string instead
  public enum SolverType: ProtobufEnum {
    public typealias RawValue = Int
    case sgd // = 0
    case nesterov // = 1
    case adagrad // = 2
    case rmsprop // = 3
    case adadelta // = 4
    case adam // = 5

    public init() {
      self = .sgd
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sgd
      case 1: self = .nesterov
      case 2: self = .adagrad
      case 3: self = .rmsprop
      case 4: self = .adadelta
      case 5: self = .adam
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "sgd": self = .sgd
      case "nesterov": self = .nesterov
      case "adagrad": self = .adagrad
      case "rmsprop": self = .rmsprop
      case "adadelta": self = .adadelta
      case "adam": self = .adam
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "SGD": self = .sgd
      case "NESTEROV": self = .nesterov
      case "ADAGRAD": self = .adagrad
      case "RMSPROP": self = .rmsprop
      case "ADADELTA": self = .adadelta
      case "ADAM": self = .adam
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "SGD": self = .sgd
      case "NESTEROV": self = .nesterov
      case "ADAGRAD": self = .adagrad
      case "RMSPROP": self = .rmsprop
      case "ADADELTA": self = .adadelta
      case "ADAM": self = .adam
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .sgd: return 0
        case .nesterov: return 1
        case .adagrad: return 2
        case .rmsprop: return 3
        case .adadelta: return 4
        case .adam: return 5
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .sgd: return "\"SGD\""
        case .nesterov: return "\"NESTEROV\""
        case .adagrad: return "\"ADAGRAD\""
        case .rmsprop: return "\"RMSPROP\""
        case .adadelta: return "\"ADADELTA\""
        case .adam: return "\"ADAM\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .sgd: return ".sgd"
        case .nesterov: return ".nesterov"
        case .adagrad: return ".adagrad"
        case .rmsprop: return ".rmsprop"
        case .adadelta: return ".adadelta"
        case .adam: return ".adam"
        }
      }
    }

  }

  ///   Proto filename for the train net, possibly combined with one or more
  ///   test nets.
  public var net: String? {
    get {return _storage._net}
    set {_uniqueStorage()._net = newValue}
  }

  ///   Inline train net param, possibly combined with one or more test nets.
  public var netParam: NetParameter? {
    get {return _storage._netParam}
    set {_uniqueStorage()._netParam = newValue}
  }

  ///   Proto filename for the train net.
  public var trainNet: String? {
    get {return _storage._trainNet}
    set {_uniqueStorage()._trainNet = newValue}
  }

  ///   Proto filenames for the test nets.
  public var testNet: [String] {
    get {return _storage._testNet}
    set {_uniqueStorage()._testNet = newValue}
  }

  ///   Inline train net params.
  public var trainNetParam: NetParameter? {
    get {return _storage._trainNetParam}
    set {_uniqueStorage()._trainNetParam = newValue}
  }

  ///   Inline test net params.
  public var testNetParam: [NetParameter] {
    get {return _storage._testNetParam}
    set {_uniqueStorage()._testNetParam = newValue}
  }

  ///   The states for the train/test nets. Must be unspecified or
  ///   specified once per net.
  ///  
  ///   By default, all states will have solver = true;
  ///   train_state will have phase = TRAIN,
  ///   and all test_state's will have phase = TEST.
  ///   Other defaults are set according to the NetState defaults.
  public var trainState: NetState? {
    get {return _storage._trainState}
    set {_uniqueStorage()._trainState = newValue}
  }

  public var testState: [NetState] {
    get {return _storage._testState}
    set {_uniqueStorage()._testState = newValue}
  }

  ///   The number of iterations for each test net.
  public var testIter: [Int32] {
    get {return _storage._testIter}
    set {_uniqueStorage()._testIter = newValue}
  }

  ///   The number of iterations between two testing phases.
  public var testInterval: Int32? {
    get {return _storage._testInterval ?? 0}
    set {_uniqueStorage()._testInterval = newValue}
  }

  public var testComputeLoss: Bool? {
    get {return _storage._testComputeLoss ?? false}
    set {_uniqueStorage()._testComputeLoss = newValue}
  }

  ///   If true, run an initial test pass before the first iteration,
  ///   ensuring memory availability and printing the starting value of the loss.
  public var testInitialization: Bool? {
    get {return _storage._testInitialization ?? true}
    set {_uniqueStorage()._testInitialization = newValue}
  }

  ///   The base learning rate
  public var baseLr: Float? {
    get {return _storage._baseLr}
    set {_uniqueStorage()._baseLr = newValue}
  }

  ///   the number of iterations between displaying info. If display = 0, no info
  ///   will be displayed.
  public var display: Int32? {
    get {return _storage._display}
    set {_uniqueStorage()._display = newValue}
  }

  ///   Display the loss averaged over the last average_loss iterations
  public var averageLoss: Int32? {
    get {return _storage._averageLoss ?? 1}
    set {_uniqueStorage()._averageLoss = newValue}
  }

  ///   the maximum number of iterations
  public var maxIter: Int32? {
    get {return _storage._maxIter}
    set {_uniqueStorage()._maxIter = newValue}
  }

  ///   accumulate gradients over `iter_size` x `batch_size` instances
  public var iterSize: Int32? {
    get {return _storage._iterSize ?? 1}
    set {_uniqueStorage()._iterSize = newValue}
  }

  ///   The learning rate decay policy. The currently implemented learning rate
  ///   policies are as follows:
  ///      - fixed: always return base_lr.
  ///      - step: return base_lr * gamma ^ (floor(iter / step))
  ///      - exp: return base_lr * gamma ^ iter
  ///      - inv: return base_lr * (1 + gamma * iter) ^ (- power)
  ///      - multistep: similar to step but it allows non uniform steps defined by
  ///        stepvalue
  ///      - poly: the effective learning rate follows a polynomial decay, to be
  ///        zero by the max_iter. return base_lr (1 - iter/max_iter) ^ (power)
  ///      - sigmoid: the effective learning rate follows a sigmod decay
  ///        return base_lr ( 1/(1 + exp(-gamma * (iter - stepsize))))
  ///  
  ///   where base_lr, max_iter, gamma, step, stepvalue and power are defined
  ///   in the solver parameter protocol buffer, and iter is the current iteration.
  public var lrPolicy: String? {
    get {return _storage._lrPolicy}
    set {_uniqueStorage()._lrPolicy = newValue}
  }

  ///   The parameter to compute the learning rate.
  public var gamma: Float? {
    get {return _storage._gamma}
    set {_uniqueStorage()._gamma = newValue}
  }

  ///   The parameter to compute the learning rate.
  public var power: Float? {
    get {return _storage._power}
    set {_uniqueStorage()._power = newValue}
  }

  ///   The momentum value.
  public var momentum: Float? {
    get {return _storage._momentum}
    set {_uniqueStorage()._momentum = newValue}
  }

  ///   The weight decay.
  public var weightDecay: Float? {
    get {return _storage._weightDecay}
    set {_uniqueStorage()._weightDecay = newValue}
  }

  ///   regularization types supported: L1 and L2
  ///   controlled by weight_decay
  public var regularizationType: String? {
    get {return _storage._regularizationType ?? "L2"}
    set {_uniqueStorage()._regularizationType = newValue}
  }

  ///   the stepsize for learning rate policy "step"
  public var stepsize: Int32? {
    get {return _storage._stepsize}
    set {_uniqueStorage()._stepsize = newValue}
  }

  ///   the stepsize for learning rate policy "multistep"
  public var stepvalue: [Int32] {
    get {return _storage._stepvalue}
    set {_uniqueStorage()._stepvalue = newValue}
  }

  ///   Set clip_gradients to >= 0 to clip parameter gradients to that L2 norm,
  ///   whenever their actual L2 norm is larger.
  public var clipGradients: Float? {
    get {return _storage._clipGradients ?? -1}
    set {_uniqueStorage()._clipGradients = newValue}
  }

  ///   The snapshot interval
  public var snapshot: Int32? {
    get {return _storage._snapshot ?? 0}
    set {_uniqueStorage()._snapshot = newValue}
  }

  ///   The prefix for the snapshot.
  public var snapshotPrefix: String? {
    get {return _storage._snapshotPrefix}
    set {_uniqueStorage()._snapshotPrefix = newValue}
  }

  ///   whether to snapshot diff in the results or not. Snapshotting diff will help
  ///   debugging but the final protocol buffer size will be much larger.
  public var snapshotDiff: Bool? {
    get {return _storage._snapshotDiff ?? false}
    set {_uniqueStorage()._snapshotDiff = newValue}
  }

  public var snapshotFormat: SolverParameter.SnapshotFormat? {
    get {return _storage._snapshotFormat ?? SolverParameter.SnapshotFormat.binaryproto}
    set {_uniqueStorage()._snapshotFormat = newValue}
  }

  public var solverMode: SolverParameter.SolverMode? {
    get {return _storage._solverMode ?? SolverParameter.SolverMode.gpu}
    set {_uniqueStorage()._solverMode = newValue}
  }

  ///   the device_id will that be used in GPU mode. Use device_id = 0 in default.
  public var deviceId: Int32? {
    get {return _storage._deviceId ?? 0}
    set {_uniqueStorage()._deviceId = newValue}
  }

  ///   If non-negative, the seed with which the Solver will initialize the Caffe
  ///   random number generator -- useful for reproducible results. Otherwise,
  ///   (and by default) initialize using a seed derived from the system clock.
  public var randomSeed: Int64? {
    get {return _storage._randomSeed ?? -1}
    set {_uniqueStorage()._randomSeed = newValue}
  }

  ///   type of the solver
  public var type: String? {
    get {return _storage._type ?? "SGD"}
    set {_uniqueStorage()._type = newValue}
  }

  ///   numerical stability for RMSProp, AdaGrad and AdaDelta and Adam
  public var delta: Float? {
    get {return _storage._delta ?? 1e-08}
    set {_uniqueStorage()._delta = newValue}
  }

  ///   parameters for the Adam solver
  public var momentum2: Float? {
    get {return _storage._momentum2 ?? 0.999}
    set {_uniqueStorage()._momentum2 = newValue}
  }

  ///   RMSProp decay value
  ///   MeanSquare(t) = rms_decay*MeanSquare(t-1) + (1-rms_decay)*SquareGradient(t)
  public var rmsDecay: Float? {
    get {return _storage._rmsDecay ?? 0.99}
    set {_uniqueStorage()._rmsDecay = newValue}
  }

  ///   If true, print information about the state of the net that may help with
  ///   debugging learning problems.
  public var debugInfo: Bool? {
    get {return _storage._debugInfo ?? false}
    set {_uniqueStorage()._debugInfo = newValue}
  }

  ///   If false, don't save a snapshot after training finishes.
  public var snapshotAfterTrain: Bool? {
    get {return _storage._snapshotAfterTrain ?? true}
    set {_uniqueStorage()._snapshotAfterTrain = newValue}
  }

  ///   DEPRECATED: use type instead of solver_type
  public var solverType: SolverParameter.SolverType? {
    get {return _storage._solverType ?? SolverParameter.SolverType.sgd}
    set {_uniqueStorage()._solverType = newValue}
  }

  ///   Overlap compute and communication for data parallel training
  public var layerWiseReduce: Bool? {
    get {return _storage._layerWiseReduce ?? true}
    set {_uniqueStorage()._layerWiseReduce = newValue}
  }

  public init() {}

  public init(net: String? = nil,
    netParam: NetParameter? = nil,
    trainNet: String? = nil,
    testNet: [String] = [],
    trainNetParam: NetParameter? = nil,
    testNetParam: [NetParameter] = [],
    trainState: NetState? = nil,
    testState: [NetState] = [],
    testIter: [Int32] = [],
    testInterval: Int32? = nil,
    testComputeLoss: Bool? = nil,
    testInitialization: Bool? = nil,
    baseLr: Float? = nil,
    display: Int32? = nil,
    averageLoss: Int32? = nil,
    maxIter: Int32? = nil,
    iterSize: Int32? = nil,
    lrPolicy: String? = nil,
    gamma: Float? = nil,
    power: Float? = nil,
    momentum: Float? = nil,
    weightDecay: Float? = nil,
    regularizationType: String? = nil,
    stepsize: Int32? = nil,
    stepvalue: [Int32] = [],
    clipGradients: Float? = nil,
    snapshot: Int32? = nil,
    snapshotPrefix: String? = nil,
    snapshotDiff: Bool? = nil,
    snapshotFormat: SolverParameter.SnapshotFormat? = nil,
    solverMode: SolverParameter.SolverMode? = nil,
    deviceId: Int32? = nil,
    randomSeed: Int64? = nil,
    type: String? = nil,
    delta: Float? = nil,
    momentum2: Float? = nil,
    rmsDecay: Float? = nil,
    debugInfo: Bool? = nil,
    snapshotAfterTrain: Bool? = nil,
    solverType: SolverParameter.SolverType? = nil,
    layerWiseReduce: Bool? = nil)
  {
    let storage = _uniqueStorage()
    storage._net = net
    storage._netParam = netParam
    storage._trainNet = trainNet
    if !testNet.isEmpty {
      storage._testNet = testNet
    }
    storage._trainNetParam = trainNetParam
    if !testNetParam.isEmpty {
      storage._testNetParam = testNetParam
    }
    storage._trainState = trainState
    if !testState.isEmpty {
      storage._testState = testState
    }
    if !testIter.isEmpty {
      storage._testIter = testIter
    }
    storage._testInterval = testInterval
    storage._testComputeLoss = testComputeLoss
    storage._testInitialization = testInitialization
    storage._baseLr = baseLr
    storage._display = display
    storage._averageLoss = averageLoss
    storage._maxIter = maxIter
    storage._iterSize = iterSize
    storage._lrPolicy = lrPolicy
    storage._gamma = gamma
    storage._power = power
    storage._momentum = momentum
    storage._weightDecay = weightDecay
    storage._regularizationType = regularizationType
    storage._stepsize = stepsize
    if !stepvalue.isEmpty {
      storage._stepvalue = stepvalue
    }
    storage._clipGradients = clipGradients
    storage._snapshot = snapshot
    storage._snapshotPrefix = snapshotPrefix
    storage._snapshotDiff = snapshotDiff
    storage._snapshotFormat = snapshotFormat
    storage._solverMode = solverMode
    storage._deviceId = deviceId
    storage._randomSeed = randomSeed
    storage._type = type
    storage._delta = delta
    storage._momentum2 = momentum2
    storage._rmsDecay = rmsDecay
    storage._debugInfo = debugInfo
    storage._snapshotAfterTrain = snapshotAfterTrain
    storage._solverType = solverType
    storage._layerWiseReduce = layerWiseReduce
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: SolverParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   A message that stores the solver snapshots
public struct SolverState: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "SolverState"}
  public var protoMessageName: String {return "SolverState"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "iter": 1,
    "learnedNet": 2,
    "history": 3,
    "currentStep": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "iter": 1,
    "learned_net": 2,
    "history": 3,
    "current_step": 4,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   The current iteration
  public var iter: Int32? = nil

  ///   The file that stores the learned net.
  public var learnedNet: String? = nil

  ///   The history for sgd solvers
  public var history: [BlobProto] = []

  ///   The current step for learning rate
  private var _currentStep: Int32? = nil
  public var currentStep: Int32? {
    get {return _currentStep ?? 0}
    set {_currentStep = newValue}
  }

  public init() {}

  public init(iter: Int32? = nil,
    learnedNet: String? = nil,
    history: [BlobProto] = [],
    currentStep: Int32? = nil)
  {
    self.iter = iter
    self.learnedNet = learnedNet
    if !history.isEmpty {
      self.history = history
    }
    self.currentStep = currentStep
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &iter)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &learnedNet)
    case 3: handled = try setter.decodeRepeatedMessageField(fieldType: BlobProto.self, value: &history)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &currentStep)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = iter {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "iter", jsonFieldName: "iter", swiftFieldName: "iter")
    }
    if let v = learnedNet {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 2, protoFieldName: "learned_net", jsonFieldName: "learnedNet", swiftFieldName: "learnedNet")
    }
    if !history.isEmpty {
      try visitor.visitRepeatedMessageField(value: history, protoFieldNumber: 3, protoFieldName: "history", jsonFieldName: "history", swiftFieldName: "history")
    }
    if let v = currentStep {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "current_step", jsonFieldName: "currentStep", swiftFieldName: "currentStep")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: SolverState) -> Bool {
    if ((iter != nil || other.iter != nil) && (iter == nil || other.iter == nil || iter! != other.iter!)) {return false}
    if ((learnedNet != nil || other.learnedNet != nil) && (learnedNet == nil || other.learnedNet == nil || learnedNet! != other.learnedNet!)) {return false}
    if history != other.history {return false}
    if (((currentStep != nil && currentStep! != 0) || (other.currentStep != nil && other.currentStep! != 0)) && (currentStep == nil || other.currentStep == nil || currentStep! != other.currentStep!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct NetState: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "NetState"}
  public var protoMessageName: String {return "NetState"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "phase": 1,
    "level": 2,
    "stage": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "phase": 1,
    "level": 2,
    "stage": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  private var _phase: Phase? = nil
  public var phase: Phase? {
    get {return _phase ?? Phase.test}
    set {_phase = newValue}
  }

  private var _level: Int32? = nil
  public var level: Int32? {
    get {return _level ?? 0}
    set {_level = newValue}
  }

  public var stage: [String] = []

  public init() {}

  public init(phase: Phase? = nil,
    level: Int32? = nil,
    stage: [String] = [])
  {
    self.phase = phase
    self.level = level
    if !stage.isEmpty {
      self.stage = stage
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: Phase.self, value: &phase)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &level)
    case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &stage)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = phase {
      try visitor.visitSingularField(fieldType: Phase.self, value: v, protoFieldNumber: 1, protoFieldName: "phase", jsonFieldName: "phase", swiftFieldName: "phase")
    }
    if let v = level {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "level", jsonFieldName: "level", swiftFieldName: "level")
    }
    if !stage.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: stage, protoFieldNumber: 3, protoFieldName: "stage", jsonFieldName: "stage", swiftFieldName: "stage")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: NetState) -> Bool {
    if (((phase != nil && phase! != Phase.test) || (other.phase != nil && other.phase! != Phase.test)) && (phase == nil || other.phase == nil || phase! != other.phase!)) {return false}
    if (((level != nil && level! != 0) || (other.level != nil && other.level! != 0)) && (level == nil || other.level == nil || level! != other.level!)) {return false}
    if stage != other.stage {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct NetStateRule: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "NetStateRule"}
  public var protoMessageName: String {return "NetStateRule"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "phase": 1,
    "minLevel": 2,
    "maxLevel": 3,
    "stage": 4,
    "notStage": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "phase": 1,
    "min_level": 2,
    "max_level": 3,
    "stage": 4,
    "not_stage": 5,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Set phase to require the NetState have a particular phase (TRAIN or TEST)
  ///   to meet this rule.
  public var phase: Phase? = nil

  ///   Set the minimum and/or maximum levels in which the layer should be used.
  ///   Leave undefined to meet the rule regardless of level.
  public var minLevel: Int32? = nil

  public var maxLevel: Int32? = nil

  ///   Customizable sets of stages to include or exclude.
  ///   The net must have ALL of the specified stages and NONE of the specified
  ///   "not_stage"s to meet the rule.
  ///   (Use multiple NetStateRules to specify conjunctions of stages.)
  public var stage: [String] = []

  public var notStage: [String] = []

  public init() {}

  public init(phase: Phase? = nil,
    minLevel: Int32? = nil,
    maxLevel: Int32? = nil,
    stage: [String] = [],
    notStage: [String] = [])
  {
    self.phase = phase
    self.minLevel = minLevel
    self.maxLevel = maxLevel
    if !stage.isEmpty {
      self.stage = stage
    }
    if !notStage.isEmpty {
      self.notStage = notStage
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: Phase.self, value: &phase)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &minLevel)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &maxLevel)
    case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &stage)
    case 5: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &notStage)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = phase {
      try visitor.visitSingularField(fieldType: Phase.self, value: v, protoFieldNumber: 1, protoFieldName: "phase", jsonFieldName: "phase", swiftFieldName: "phase")
    }
    if let v = minLevel {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "min_level", jsonFieldName: "minLevel", swiftFieldName: "minLevel")
    }
    if let v = maxLevel {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "max_level", jsonFieldName: "maxLevel", swiftFieldName: "maxLevel")
    }
    if !stage.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: stage, protoFieldNumber: 4, protoFieldName: "stage", jsonFieldName: "stage", swiftFieldName: "stage")
    }
    if !notStage.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: notStage, protoFieldNumber: 5, protoFieldName: "not_stage", jsonFieldName: "notStage", swiftFieldName: "notStage")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: NetStateRule) -> Bool {
    if ((phase != nil || other.phase != nil) && (phase == nil || other.phase == nil || phase! != other.phase!)) {return false}
    if ((minLevel != nil || other.minLevel != nil) && (minLevel == nil || other.minLevel == nil || minLevel! != other.minLevel!)) {return false}
    if ((maxLevel != nil || other.maxLevel != nil) && (maxLevel == nil || other.maxLevel == nil || maxLevel! != other.maxLevel!)) {return false}
    if stage != other.stage {return false}
    if notStage != other.notStage {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Specifies training parameters (multipliers on global learning constants,
///   and the name and other settings used for weight sharing).
public struct ParamSpec: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ParamSpec"}
  public var protoMessageName: String {return "ParamSpec"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "shareMode": 2,
    "lrMult": 3,
    "decayMult": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "share_mode": 2,
    "lr_mult": 3,
    "decay_mult": 4,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum DimCheckMode: ProtobufEnum {
    public typealias RawValue = Int

    ///   STRICT (default) requires that num, channels, height, width each match.
    case strict // = 0

    ///   PERMISSIVE requires only the count (num*channels*height*width) to match.
    case permissive // = 1

    public init() {
      self = .strict
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .strict
      case 1: self = .permissive
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "strict": self = .strict
      case "permissive": self = .permissive
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "STRICT": self = .strict
      case "PERMISSIVE": self = .permissive
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "STRICT": self = .strict
      case "PERMISSIVE": self = .permissive
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .strict: return 0
        case .permissive: return 1
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .strict: return "\"STRICT\""
        case .permissive: return "\"PERMISSIVE\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .strict: return ".strict"
        case .permissive: return ".permissive"
        }
      }
    }

  }

  ///   The names of the parameter blobs -- useful for sharing parameters among
  ///   layers, but never required otherwise.  To share a parameter between two
  ///   layers, give it a (non-empty) name.
  public var name: String? = nil

  ///   Whether to require shared weights to have the same shape, or just the same
  ///   count -- defaults to STRICT if unspecified.
  public var shareMode: ParamSpec.DimCheckMode? = nil

  ///   The multiplier on the global learning rate for this parameter.
  private var _lrMult: Float? = nil
  public var lrMult: Float? {
    get {return _lrMult ?? 1}
    set {_lrMult = newValue}
  }

  ///   The multiplier on the global weight decay for this parameter.
  private var _decayMult: Float? = nil
  public var decayMult: Float? {
    get {return _decayMult ?? 1}
    set {_decayMult = newValue}
  }

  public init() {}

  public init(name: String? = nil,
    shareMode: ParamSpec.DimCheckMode? = nil,
    lrMult: Float? = nil,
    decayMult: Float? = nil)
  {
    self.name = name
    self.shareMode = shareMode
    self.lrMult = lrMult
    self.decayMult = decayMult
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &name)
    case 2: handled = try setter.decodeOptionalField(fieldType: ParamSpec.DimCheckMode.self, value: &shareMode)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &lrMult)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &decayMult)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = name {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
    }
    if let v = shareMode {
      try visitor.visitSingularField(fieldType: ParamSpec.DimCheckMode.self, value: v, protoFieldNumber: 2, protoFieldName: "share_mode", jsonFieldName: "shareMode", swiftFieldName: "shareMode")
    }
    if let v = lrMult {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "lr_mult", jsonFieldName: "lrMult", swiftFieldName: "lrMult")
    }
    if let v = decayMult {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 4, protoFieldName: "decay_mult", jsonFieldName: "decayMult", swiftFieldName: "decayMult")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ParamSpec) -> Bool {
    if ((name != nil || other.name != nil) && (name == nil || other.name == nil || name! != other.name!)) {return false}
    if ((shareMode != nil || other.shareMode != nil) && (shareMode == nil || other.shareMode == nil || shareMode! != other.shareMode!)) {return false}
    if (((lrMult != nil && lrMult! != 1) || (other.lrMult != nil && other.lrMult! != 1)) && (lrMult == nil || other.lrMult == nil || lrMult! != other.lrMult!)) {return false}
    if (((decayMult != nil && decayMult! != 1) || (other.decayMult != nil && other.decayMult! != 1)) && (decayMult == nil || other.decayMult == nil || decayMult! != other.decayMult!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   NOTE
///   Update the next available ID when you add a new LayerParameter field.
///  
///   LayerParameter next available layer-specific ID: 147 (last added: recurrent_param)
public struct LayerParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "LayerParameter"}
  public var protoMessageName: String {return "LayerParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "type": 2,
    "bottom": 3,
    "top": 4,
    "phase": 10,
    "lossWeight": 5,
    "param": 6,
    "blobs": 7,
    "propagateDown": 11,
    "include": 8,
    "exclude": 9,
    "transformParam": 100,
    "lossParam": 101,
    "accuracyParam": 102,
    "argmaxParam": 103,
    "batchNormParam": 139,
    "biasParam": 141,
    "concatParam": 104,
    "contrastiveLossParam": 105,
    "convolutionParam": 106,
    "cropParam": 144,
    "dataParam": 107,
    "dropoutParam": 108,
    "dummyDataParam": 109,
    "eltwiseParam": 110,
    "eluParam": 140,
    "embedParam": 137,
    "expParam": 111,
    "flattenParam": 135,
    "hdf5DataParam": 112,
    "hdf5OutputParam": 113,
    "hingeLossParam": 114,
    "imageDataParam": 115,
    "infogainLossParam": 116,
    "innerProductParam": 117,
    "inputParam": 143,
    "logParam": 134,
    "lrnParam": 118,
    "memoryDataParam": 119,
    "mvnParam": 120,
    "parameterParam": 145,
    "poolingParam": 121,
    "powerParam": 122,
    "preluParam": 131,
    "pythonParam": 130,
    "recurrentParam": 146,
    "reductionParam": 136,
    "reluParam": 123,
    "reshapeParam": 133,
    "scaleParam": 142,
    "sigmoidParam": 124,
    "softmaxParam": 125,
    "sppParam": 132,
    "sliceParam": 126,
    "tanhParam": 127,
    "thresholdParam": 128,
    "tileParam": 138,
    "windowDataParam": 129,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "type": 2,
    "bottom": 3,
    "top": 4,
    "phase": 10,
    "loss_weight": 5,
    "param": 6,
    "blobs": 7,
    "propagate_down": 11,
    "include": 8,
    "exclude": 9,
    "transform_param": 100,
    "loss_param": 101,
    "accuracy_param": 102,
    "argmax_param": 103,
    "batch_norm_param": 139,
    "bias_param": 141,
    "concat_param": 104,
    "contrastive_loss_param": 105,
    "convolution_param": 106,
    "crop_param": 144,
    "data_param": 107,
    "dropout_param": 108,
    "dummy_data_param": 109,
    "eltwise_param": 110,
    "elu_param": 140,
    "embed_param": 137,
    "exp_param": 111,
    "flatten_param": 135,
    "hdf5_data_param": 112,
    "hdf5_output_param": 113,
    "hinge_loss_param": 114,
    "image_data_param": 115,
    "infogain_loss_param": 116,
    "inner_product_param": 117,
    "input_param": 143,
    "log_param": 134,
    "lrn_param": 118,
    "memory_data_param": 119,
    "mvn_param": 120,
    "parameter_param": 145,
    "pooling_param": 121,
    "power_param": 122,
    "prelu_param": 131,
    "python_param": 130,
    "recurrent_param": 146,
    "reduction_param": 136,
    "relu_param": 123,
    "reshape_param": 133,
    "scale_param": 142,
    "sigmoid_param": 124,
    "softmax_param": 125,
    "spp_param": 132,
    "slice_param": 126,
    "tanh_param": 127,
    "threshold_param": 128,
    "tile_param": 138,
    "window_data_param": 129,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = LayerParameter
    var unknown = ProtobufUnknownStorage()
    var _name: String? = nil
    var _type: String? = nil
    var _bottom: [String] = []
    var _top: [String] = []
    var _phase: Phase? = nil
    var _lossWeight: [Float] = []
    var _param: [ParamSpec] = []
    var _blobs: [BlobProto] = []
    var _propagateDown: [Bool] = []
    var _include: [NetStateRule] = []
    var _exclude: [NetStateRule] = []
    var _transformParam: TransformationParameter? = nil
    var _lossParam: LossParameter? = nil
    var _accuracyParam: AccuracyParameter? = nil
    var _argmaxParam: ArgMaxParameter? = nil
    var _batchNormParam: BatchNormParameter? = nil
    var _biasParam: BiasParameter? = nil
    var _concatParam: ConcatParameter? = nil
    var _contrastiveLossParam: ContrastiveLossParameter? = nil
    var _convolutionParam: ConvolutionParameter? = nil
    var _cropParam: CropParameter? = nil
    var _dataParam: DataParameter? = nil
    var _dropoutParam: DropoutParameter? = nil
    var _dummyDataParam: DummyDataParameter? = nil
    var _eltwiseParam: EltwiseParameter? = nil
    var _eluParam: ELUParameter? = nil
    var _embedParam: EmbedParameter? = nil
    var _expParam: ExpParameter? = nil
    var _flattenParam: FlattenParameter? = nil
    var _hdf5DataParam: HDF5DataParameter? = nil
    var _hdf5OutputParam: HDF5OutputParameter? = nil
    var _hingeLossParam: HingeLossParameter? = nil
    var _imageDataParam: ImageDataParameter? = nil
    var _infogainLossParam: InfogainLossParameter? = nil
    var _innerProductParam: InnerProductParameter? = nil
    var _inputParam: InputParameter? = nil
    var _logParam: LogParameter? = nil
    var _lrnParam: LRNParameter? = nil
    var _memoryDataParam: MemoryDataParameter? = nil
    var _mvnParam: MVNParameter? = nil
    var _parameterParam: ParameterParameter? = nil
    var _poolingParam: PoolingParameter? = nil
    var _powerParam: PowerParameter? = nil
    var _preluParam: PReLUParameter? = nil
    var _pythonParam: PythonParameter? = nil
    var _recurrentParam: RecurrentParameter? = nil
    var _reductionParam: ReductionParameter? = nil
    var _reluParam: ReLUParameter? = nil
    var _reshapeParam: ReshapeParameter? = nil
    var _scaleParam: ScaleParameter? = nil
    var _sigmoidParam: SigmoidParameter? = nil
    var _softmaxParam: SoftmaxParameter? = nil
    var _sppParam: SPPParameter? = nil
    var _sliceParam: SliceParameter? = nil
    var _tanhParam: TanHParameter? = nil
    var _thresholdParam: ThresholdParameter? = nil
    var _tileParam: TileParameter? = nil
    var _windowDataParam: WindowDataParameter? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_name)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_type)
      case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_bottom)
      case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_top)
      case 10: handled = try setter.decodeOptionalField(fieldType: Phase.self, value: &_phase)
      case 5: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &_lossWeight)
      case 6: handled = try setter.decodeRepeatedMessageField(fieldType: ParamSpec.self, value: &_param)
      case 7: handled = try setter.decodeRepeatedMessageField(fieldType: BlobProto.self, value: &_blobs)
      case 11: handled = try setter.decodeRepeatedField(fieldType: ProtobufBool.self, value: &_propagateDown)
      case 8: handled = try setter.decodeRepeatedMessageField(fieldType: NetStateRule.self, value: &_include)
      case 9: handled = try setter.decodeRepeatedMessageField(fieldType: NetStateRule.self, value: &_exclude)
      case 100: handled = try setter.decodeOptionalMessageField(fieldType: TransformationParameter.self, value: &_transformParam)
      case 101: handled = try setter.decodeOptionalMessageField(fieldType: LossParameter.self, value: &_lossParam)
      case 102: handled = try setter.decodeOptionalMessageField(fieldType: AccuracyParameter.self, value: &_accuracyParam)
      case 103: handled = try setter.decodeOptionalMessageField(fieldType: ArgMaxParameter.self, value: &_argmaxParam)
      case 139: handled = try setter.decodeOptionalMessageField(fieldType: BatchNormParameter.self, value: &_batchNormParam)
      case 141: handled = try setter.decodeOptionalMessageField(fieldType: BiasParameter.self, value: &_biasParam)
      case 104: handled = try setter.decodeOptionalMessageField(fieldType: ConcatParameter.self, value: &_concatParam)
      case 105: handled = try setter.decodeOptionalMessageField(fieldType: ContrastiveLossParameter.self, value: &_contrastiveLossParam)
      case 106: handled = try setter.decodeOptionalMessageField(fieldType: ConvolutionParameter.self, value: &_convolutionParam)
      case 144: handled = try setter.decodeOptionalMessageField(fieldType: CropParameter.self, value: &_cropParam)
      case 107: handled = try setter.decodeOptionalMessageField(fieldType: DataParameter.self, value: &_dataParam)
      case 108: handled = try setter.decodeOptionalMessageField(fieldType: DropoutParameter.self, value: &_dropoutParam)
      case 109: handled = try setter.decodeOptionalMessageField(fieldType: DummyDataParameter.self, value: &_dummyDataParam)
      case 110: handled = try setter.decodeOptionalMessageField(fieldType: EltwiseParameter.self, value: &_eltwiseParam)
      case 140: handled = try setter.decodeOptionalMessageField(fieldType: ELUParameter.self, value: &_eluParam)
      case 137: handled = try setter.decodeOptionalMessageField(fieldType: EmbedParameter.self, value: &_embedParam)
      case 111: handled = try setter.decodeOptionalMessageField(fieldType: ExpParameter.self, value: &_expParam)
      case 135: handled = try setter.decodeOptionalMessageField(fieldType: FlattenParameter.self, value: &_flattenParam)
      case 112: handled = try setter.decodeOptionalMessageField(fieldType: HDF5DataParameter.self, value: &_hdf5DataParam)
      case 113: handled = try setter.decodeOptionalMessageField(fieldType: HDF5OutputParameter.self, value: &_hdf5OutputParam)
      case 114: handled = try setter.decodeOptionalMessageField(fieldType: HingeLossParameter.self, value: &_hingeLossParam)
      case 115: handled = try setter.decodeOptionalMessageField(fieldType: ImageDataParameter.self, value: &_imageDataParam)
      case 116: handled = try setter.decodeOptionalMessageField(fieldType: InfogainLossParameter.self, value: &_infogainLossParam)
      case 117: handled = try setter.decodeOptionalMessageField(fieldType: InnerProductParameter.self, value: &_innerProductParam)
      case 143: handled = try setter.decodeOptionalMessageField(fieldType: InputParameter.self, value: &_inputParam)
      case 134: handled = try setter.decodeOptionalMessageField(fieldType: LogParameter.self, value: &_logParam)
      case 118: handled = try setter.decodeOptionalMessageField(fieldType: LRNParameter.self, value: &_lrnParam)
      case 119: handled = try setter.decodeOptionalMessageField(fieldType: MemoryDataParameter.self, value: &_memoryDataParam)
      case 120: handled = try setter.decodeOptionalMessageField(fieldType: MVNParameter.self, value: &_mvnParam)
      case 145: handled = try setter.decodeOptionalMessageField(fieldType: ParameterParameter.self, value: &_parameterParam)
      case 121: handled = try setter.decodeOptionalMessageField(fieldType: PoolingParameter.self, value: &_poolingParam)
      case 122: handled = try setter.decodeOptionalMessageField(fieldType: PowerParameter.self, value: &_powerParam)
      case 131: handled = try setter.decodeOptionalMessageField(fieldType: PReLUParameter.self, value: &_preluParam)
      case 130: handled = try setter.decodeOptionalMessageField(fieldType: PythonParameter.self, value: &_pythonParam)
      case 146: handled = try setter.decodeOptionalMessageField(fieldType: RecurrentParameter.self, value: &_recurrentParam)
      case 136: handled = try setter.decodeOptionalMessageField(fieldType: ReductionParameter.self, value: &_reductionParam)
      case 123: handled = try setter.decodeOptionalMessageField(fieldType: ReLUParameter.self, value: &_reluParam)
      case 133: handled = try setter.decodeOptionalMessageField(fieldType: ReshapeParameter.self, value: &_reshapeParam)
      case 142: handled = try setter.decodeOptionalMessageField(fieldType: ScaleParameter.self, value: &_scaleParam)
      case 124: handled = try setter.decodeOptionalMessageField(fieldType: SigmoidParameter.self, value: &_sigmoidParam)
      case 125: handled = try setter.decodeOptionalMessageField(fieldType: SoftmaxParameter.self, value: &_softmaxParam)
      case 132: handled = try setter.decodeOptionalMessageField(fieldType: SPPParameter.self, value: &_sppParam)
      case 126: handled = try setter.decodeOptionalMessageField(fieldType: SliceParameter.self, value: &_sliceParam)
      case 127: handled = try setter.decodeOptionalMessageField(fieldType: TanHParameter.self, value: &_tanhParam)
      case 128: handled = try setter.decodeOptionalMessageField(fieldType: ThresholdParameter.self, value: &_thresholdParam)
      case 138: handled = try setter.decodeOptionalMessageField(fieldType: TileParameter.self, value: &_tileParam)
      case 129: handled = try setter.decodeOptionalMessageField(fieldType: WindowDataParameter.self, value: &_windowDataParam)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if let v = _type {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 2, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
      }
      if !_bottom.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _bottom, protoFieldNumber: 3, protoFieldName: "bottom", jsonFieldName: "bottom", swiftFieldName: "bottom")
      }
      if !_top.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _top, protoFieldNumber: 4, protoFieldName: "top", jsonFieldName: "top", swiftFieldName: "top")
      }
      if !_lossWeight.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: _lossWeight, protoFieldNumber: 5, protoFieldName: "loss_weight", jsonFieldName: "lossWeight", swiftFieldName: "lossWeight")
      }
      if !_param.isEmpty {
        try visitor.visitRepeatedMessageField(value: _param, protoFieldNumber: 6, protoFieldName: "param", jsonFieldName: "param", swiftFieldName: "param")
      }
      if !_blobs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _blobs, protoFieldNumber: 7, protoFieldName: "blobs", jsonFieldName: "blobs", swiftFieldName: "blobs")
      }
      if !_include.isEmpty {
        try visitor.visitRepeatedMessageField(value: _include, protoFieldNumber: 8, protoFieldName: "include", jsonFieldName: "include", swiftFieldName: "include")
      }
      if !_exclude.isEmpty {
        try visitor.visitRepeatedMessageField(value: _exclude, protoFieldNumber: 9, protoFieldName: "exclude", jsonFieldName: "exclude", swiftFieldName: "exclude")
      }
      if let v = _phase {
        try visitor.visitSingularField(fieldType: Phase.self, value: v, protoFieldNumber: 10, protoFieldName: "phase", jsonFieldName: "phase", swiftFieldName: "phase")
      }
      if !_propagateDown.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufBool.self, value: _propagateDown, protoFieldNumber: 11, protoFieldName: "propagate_down", jsonFieldName: "propagateDown", swiftFieldName: "propagateDown")
      }
      if let v = _transformParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 100, protoFieldName: "transform_param", jsonFieldName: "transformParam", swiftFieldName: "transformParam")
      }
      if let v = _lossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 101, protoFieldName: "loss_param", jsonFieldName: "lossParam", swiftFieldName: "lossParam")
      }
      if let v = _accuracyParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 102, protoFieldName: "accuracy_param", jsonFieldName: "accuracyParam", swiftFieldName: "accuracyParam")
      }
      if let v = _argmaxParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 103, protoFieldName: "argmax_param", jsonFieldName: "argmaxParam", swiftFieldName: "argmaxParam")
      }
      if let v = _concatParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 104, protoFieldName: "concat_param", jsonFieldName: "concatParam", swiftFieldName: "concatParam")
      }
      if let v = _contrastiveLossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 105, protoFieldName: "contrastive_loss_param", jsonFieldName: "contrastiveLossParam", swiftFieldName: "contrastiveLossParam")
      }
      if let v = _convolutionParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 106, protoFieldName: "convolution_param", jsonFieldName: "convolutionParam", swiftFieldName: "convolutionParam")
      }
      if let v = _dataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 107, protoFieldName: "data_param", jsonFieldName: "dataParam", swiftFieldName: "dataParam")
      }
      if let v = _dropoutParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 108, protoFieldName: "dropout_param", jsonFieldName: "dropoutParam", swiftFieldName: "dropoutParam")
      }
      if let v = _dummyDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 109, protoFieldName: "dummy_data_param", jsonFieldName: "dummyDataParam", swiftFieldName: "dummyDataParam")
      }
      if let v = _eltwiseParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 110, protoFieldName: "eltwise_param", jsonFieldName: "eltwiseParam", swiftFieldName: "eltwiseParam")
      }
      if let v = _expParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 111, protoFieldName: "exp_param", jsonFieldName: "expParam", swiftFieldName: "expParam")
      }
      if let v = _hdf5DataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 112, protoFieldName: "hdf5_data_param", jsonFieldName: "hdf5DataParam", swiftFieldName: "hdf5DataParam")
      }
      if let v = _hdf5OutputParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 113, protoFieldName: "hdf5_output_param", jsonFieldName: "hdf5OutputParam", swiftFieldName: "hdf5OutputParam")
      }
      if let v = _hingeLossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 114, protoFieldName: "hinge_loss_param", jsonFieldName: "hingeLossParam", swiftFieldName: "hingeLossParam")
      }
      if let v = _imageDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 115, protoFieldName: "image_data_param", jsonFieldName: "imageDataParam", swiftFieldName: "imageDataParam")
      }
      if let v = _infogainLossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 116, protoFieldName: "infogain_loss_param", jsonFieldName: "infogainLossParam", swiftFieldName: "infogainLossParam")
      }
      if let v = _innerProductParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 117, protoFieldName: "inner_product_param", jsonFieldName: "innerProductParam", swiftFieldName: "innerProductParam")
      }
      if let v = _lrnParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 118, protoFieldName: "lrn_param", jsonFieldName: "lrnParam", swiftFieldName: "lrnParam")
      }
      if let v = _memoryDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 119, protoFieldName: "memory_data_param", jsonFieldName: "memoryDataParam", swiftFieldName: "memoryDataParam")
      }
      if let v = _mvnParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 120, protoFieldName: "mvn_param", jsonFieldName: "mvnParam", swiftFieldName: "mvnParam")
      }
      if let v = _poolingParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 121, protoFieldName: "pooling_param", jsonFieldName: "poolingParam", swiftFieldName: "poolingParam")
      }
      if let v = _powerParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 122, protoFieldName: "power_param", jsonFieldName: "powerParam", swiftFieldName: "powerParam")
      }
      if let v = _reluParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 123, protoFieldName: "relu_param", jsonFieldName: "reluParam", swiftFieldName: "reluParam")
      }
      if let v = _sigmoidParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 124, protoFieldName: "sigmoid_param", jsonFieldName: "sigmoidParam", swiftFieldName: "sigmoidParam")
      }
      if let v = _softmaxParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 125, protoFieldName: "softmax_param", jsonFieldName: "softmaxParam", swiftFieldName: "softmaxParam")
      }
      if let v = _sliceParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 126, protoFieldName: "slice_param", jsonFieldName: "sliceParam", swiftFieldName: "sliceParam")
      }
      if let v = _tanhParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 127, protoFieldName: "tanh_param", jsonFieldName: "tanhParam", swiftFieldName: "tanhParam")
      }
      if let v = _thresholdParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 128, protoFieldName: "threshold_param", jsonFieldName: "thresholdParam", swiftFieldName: "thresholdParam")
      }
      if let v = _windowDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 129, protoFieldName: "window_data_param", jsonFieldName: "windowDataParam", swiftFieldName: "windowDataParam")
      }
      if let v = _pythonParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 130, protoFieldName: "python_param", jsonFieldName: "pythonParam", swiftFieldName: "pythonParam")
      }
      if let v = _preluParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 131, protoFieldName: "prelu_param", jsonFieldName: "preluParam", swiftFieldName: "preluParam")
      }
      if let v = _sppParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 132, protoFieldName: "spp_param", jsonFieldName: "sppParam", swiftFieldName: "sppParam")
      }
      if let v = _reshapeParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 133, protoFieldName: "reshape_param", jsonFieldName: "reshapeParam", swiftFieldName: "reshapeParam")
      }
      if let v = _logParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 134, protoFieldName: "log_param", jsonFieldName: "logParam", swiftFieldName: "logParam")
      }
      if let v = _flattenParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 135, protoFieldName: "flatten_param", jsonFieldName: "flattenParam", swiftFieldName: "flattenParam")
      }
      if let v = _reductionParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 136, protoFieldName: "reduction_param", jsonFieldName: "reductionParam", swiftFieldName: "reductionParam")
      }
      if let v = _embedParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 137, protoFieldName: "embed_param", jsonFieldName: "embedParam", swiftFieldName: "embedParam")
      }
      if let v = _tileParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 138, protoFieldName: "tile_param", jsonFieldName: "tileParam", swiftFieldName: "tileParam")
      }
      if let v = _batchNormParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 139, protoFieldName: "batch_norm_param", jsonFieldName: "batchNormParam", swiftFieldName: "batchNormParam")
      }
      if let v = _eluParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 140, protoFieldName: "elu_param", jsonFieldName: "eluParam", swiftFieldName: "eluParam")
      }
      if let v = _biasParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 141, protoFieldName: "bias_param", jsonFieldName: "biasParam", swiftFieldName: "biasParam")
      }
      if let v = _scaleParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 142, protoFieldName: "scale_param", jsonFieldName: "scaleParam", swiftFieldName: "scaleParam")
      }
      if let v = _inputParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 143, protoFieldName: "input_param", jsonFieldName: "inputParam", swiftFieldName: "inputParam")
      }
      if let v = _cropParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 144, protoFieldName: "crop_param", jsonFieldName: "cropParam", swiftFieldName: "cropParam")
      }
      if let v = _parameterParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 145, protoFieldName: "parameter_param", jsonFieldName: "parameterParam", swiftFieldName: "parameterParam")
      }
      if let v = _recurrentParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 146, protoFieldName: "recurrent_param", jsonFieldName: "recurrentParam", swiftFieldName: "recurrentParam")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_name != nil || other._name != nil) && (_name == nil || other._name == nil || _name! != other._name!)) {return false}
      if ((_type != nil || other._type != nil) && (_type == nil || other._type == nil || _type! != other._type!)) {return false}
      if _bottom != other._bottom {return false}
      if _top != other._top {return false}
      if ((_phase != nil || other._phase != nil) && (_phase == nil || other._phase == nil || _phase! != other._phase!)) {return false}
      if _lossWeight != other._lossWeight {return false}
      if _param != other._param {return false}
      if _blobs != other._blobs {return false}
      if _propagateDown != other._propagateDown {return false}
      if _include != other._include {return false}
      if _exclude != other._exclude {return false}
      if ((_transformParam != nil || other._transformParam != nil) && (_transformParam == nil || other._transformParam == nil || _transformParam! != other._transformParam!)) {return false}
      if ((_lossParam != nil || other._lossParam != nil) && (_lossParam == nil || other._lossParam == nil || _lossParam! != other._lossParam!)) {return false}
      if ((_accuracyParam != nil || other._accuracyParam != nil) && (_accuracyParam == nil || other._accuracyParam == nil || _accuracyParam! != other._accuracyParam!)) {return false}
      if ((_argmaxParam != nil || other._argmaxParam != nil) && (_argmaxParam == nil || other._argmaxParam == nil || _argmaxParam! != other._argmaxParam!)) {return false}
      if ((_batchNormParam != nil || other._batchNormParam != nil) && (_batchNormParam == nil || other._batchNormParam == nil || _batchNormParam! != other._batchNormParam!)) {return false}
      if ((_biasParam != nil || other._biasParam != nil) && (_biasParam == nil || other._biasParam == nil || _biasParam! != other._biasParam!)) {return false}
      if ((_concatParam != nil || other._concatParam != nil) && (_concatParam == nil || other._concatParam == nil || _concatParam! != other._concatParam!)) {return false}
      if ((_contrastiveLossParam != nil || other._contrastiveLossParam != nil) && (_contrastiveLossParam == nil || other._contrastiveLossParam == nil || _contrastiveLossParam! != other._contrastiveLossParam!)) {return false}
      if ((_convolutionParam != nil || other._convolutionParam != nil) && (_convolutionParam == nil || other._convolutionParam == nil || _convolutionParam! != other._convolutionParam!)) {return false}
      if ((_cropParam != nil || other._cropParam != nil) && (_cropParam == nil || other._cropParam == nil || _cropParam! != other._cropParam!)) {return false}
      if ((_dataParam != nil || other._dataParam != nil) && (_dataParam == nil || other._dataParam == nil || _dataParam! != other._dataParam!)) {return false}
      if ((_dropoutParam != nil || other._dropoutParam != nil) && (_dropoutParam == nil || other._dropoutParam == nil || _dropoutParam! != other._dropoutParam!)) {return false}
      if ((_dummyDataParam != nil || other._dummyDataParam != nil) && (_dummyDataParam == nil || other._dummyDataParam == nil || _dummyDataParam! != other._dummyDataParam!)) {return false}
      if ((_eltwiseParam != nil || other._eltwiseParam != nil) && (_eltwiseParam == nil || other._eltwiseParam == nil || _eltwiseParam! != other._eltwiseParam!)) {return false}
      if ((_eluParam != nil || other._eluParam != nil) && (_eluParam == nil || other._eluParam == nil || _eluParam! != other._eluParam!)) {return false}
      if ((_embedParam != nil || other._embedParam != nil) && (_embedParam == nil || other._embedParam == nil || _embedParam! != other._embedParam!)) {return false}
      if ((_expParam != nil || other._expParam != nil) && (_expParam == nil || other._expParam == nil || _expParam! != other._expParam!)) {return false}
      if ((_flattenParam != nil || other._flattenParam != nil) && (_flattenParam == nil || other._flattenParam == nil || _flattenParam! != other._flattenParam!)) {return false}
      if ((_hdf5DataParam != nil || other._hdf5DataParam != nil) && (_hdf5DataParam == nil || other._hdf5DataParam == nil || _hdf5DataParam! != other._hdf5DataParam!)) {return false}
      if ((_hdf5OutputParam != nil || other._hdf5OutputParam != nil) && (_hdf5OutputParam == nil || other._hdf5OutputParam == nil || _hdf5OutputParam! != other._hdf5OutputParam!)) {return false}
      if ((_hingeLossParam != nil || other._hingeLossParam != nil) && (_hingeLossParam == nil || other._hingeLossParam == nil || _hingeLossParam! != other._hingeLossParam!)) {return false}
      if ((_imageDataParam != nil || other._imageDataParam != nil) && (_imageDataParam == nil || other._imageDataParam == nil || _imageDataParam! != other._imageDataParam!)) {return false}
      if ((_infogainLossParam != nil || other._infogainLossParam != nil) && (_infogainLossParam == nil || other._infogainLossParam == nil || _infogainLossParam! != other._infogainLossParam!)) {return false}
      if ((_innerProductParam != nil || other._innerProductParam != nil) && (_innerProductParam == nil || other._innerProductParam == nil || _innerProductParam! != other._innerProductParam!)) {return false}
      if ((_inputParam != nil || other._inputParam != nil) && (_inputParam == nil || other._inputParam == nil || _inputParam! != other._inputParam!)) {return false}
      if ((_logParam != nil || other._logParam != nil) && (_logParam == nil || other._logParam == nil || _logParam! != other._logParam!)) {return false}
      if ((_lrnParam != nil || other._lrnParam != nil) && (_lrnParam == nil || other._lrnParam == nil || _lrnParam! != other._lrnParam!)) {return false}
      if ((_memoryDataParam != nil || other._memoryDataParam != nil) && (_memoryDataParam == nil || other._memoryDataParam == nil || _memoryDataParam! != other._memoryDataParam!)) {return false}
      if ((_mvnParam != nil || other._mvnParam != nil) && (_mvnParam == nil || other._mvnParam == nil || _mvnParam! != other._mvnParam!)) {return false}
      if ((_parameterParam != nil || other._parameterParam != nil) && (_parameterParam == nil || other._parameterParam == nil || _parameterParam! != other._parameterParam!)) {return false}
      if ((_poolingParam != nil || other._poolingParam != nil) && (_poolingParam == nil || other._poolingParam == nil || _poolingParam! != other._poolingParam!)) {return false}
      if ((_powerParam != nil || other._powerParam != nil) && (_powerParam == nil || other._powerParam == nil || _powerParam! != other._powerParam!)) {return false}
      if ((_preluParam != nil || other._preluParam != nil) && (_preluParam == nil || other._preluParam == nil || _preluParam! != other._preluParam!)) {return false}
      if ((_pythonParam != nil || other._pythonParam != nil) && (_pythonParam == nil || other._pythonParam == nil || _pythonParam! != other._pythonParam!)) {return false}
      if ((_recurrentParam != nil || other._recurrentParam != nil) && (_recurrentParam == nil || other._recurrentParam == nil || _recurrentParam! != other._recurrentParam!)) {return false}
      if ((_reductionParam != nil || other._reductionParam != nil) && (_reductionParam == nil || other._reductionParam == nil || _reductionParam! != other._reductionParam!)) {return false}
      if ((_reluParam != nil || other._reluParam != nil) && (_reluParam == nil || other._reluParam == nil || _reluParam! != other._reluParam!)) {return false}
      if ((_reshapeParam != nil || other._reshapeParam != nil) && (_reshapeParam == nil || other._reshapeParam == nil || _reshapeParam! != other._reshapeParam!)) {return false}
      if ((_scaleParam != nil || other._scaleParam != nil) && (_scaleParam == nil || other._scaleParam == nil || _scaleParam! != other._scaleParam!)) {return false}
      if ((_sigmoidParam != nil || other._sigmoidParam != nil) && (_sigmoidParam == nil || other._sigmoidParam == nil || _sigmoidParam! != other._sigmoidParam!)) {return false}
      if ((_softmaxParam != nil || other._softmaxParam != nil) && (_softmaxParam == nil || other._softmaxParam == nil || _softmaxParam! != other._softmaxParam!)) {return false}
      if ((_sppParam != nil || other._sppParam != nil) && (_sppParam == nil || other._sppParam == nil || _sppParam! != other._sppParam!)) {return false}
      if ((_sliceParam != nil || other._sliceParam != nil) && (_sliceParam == nil || other._sliceParam == nil || _sliceParam! != other._sliceParam!)) {return false}
      if ((_tanhParam != nil || other._tanhParam != nil) && (_tanhParam == nil || other._tanhParam == nil || _tanhParam! != other._tanhParam!)) {return false}
      if ((_thresholdParam != nil || other._thresholdParam != nil) && (_thresholdParam == nil || other._thresholdParam == nil || _thresholdParam! != other._thresholdParam!)) {return false}
      if ((_tileParam != nil || other._tileParam != nil) && (_tileParam == nil || other._tileParam == nil || _tileParam! != other._tileParam!)) {return false}
      if ((_windowDataParam != nil || other._windowDataParam != nil) && (_windowDataParam == nil || other._windowDataParam == nil || _windowDataParam! != other._windowDataParam!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._type = _type
      clone._bottom = _bottom
      clone._top = _top
      clone._phase = _phase
      clone._lossWeight = _lossWeight
      clone._param = _param
      clone._blobs = _blobs
      clone._propagateDown = _propagateDown
      clone._include = _include
      clone._exclude = _exclude
      clone._transformParam = _transformParam
      clone._lossParam = _lossParam
      clone._accuracyParam = _accuracyParam
      clone._argmaxParam = _argmaxParam
      clone._batchNormParam = _batchNormParam
      clone._biasParam = _biasParam
      clone._concatParam = _concatParam
      clone._contrastiveLossParam = _contrastiveLossParam
      clone._convolutionParam = _convolutionParam
      clone._cropParam = _cropParam
      clone._dataParam = _dataParam
      clone._dropoutParam = _dropoutParam
      clone._dummyDataParam = _dummyDataParam
      clone._eltwiseParam = _eltwiseParam
      clone._eluParam = _eluParam
      clone._embedParam = _embedParam
      clone._expParam = _expParam
      clone._flattenParam = _flattenParam
      clone._hdf5DataParam = _hdf5DataParam
      clone._hdf5OutputParam = _hdf5OutputParam
      clone._hingeLossParam = _hingeLossParam
      clone._imageDataParam = _imageDataParam
      clone._infogainLossParam = _infogainLossParam
      clone._innerProductParam = _innerProductParam
      clone._inputParam = _inputParam
      clone._logParam = _logParam
      clone._lrnParam = _lrnParam
      clone._memoryDataParam = _memoryDataParam
      clone._mvnParam = _mvnParam
      clone._parameterParam = _parameterParam
      clone._poolingParam = _poolingParam
      clone._powerParam = _powerParam
      clone._preluParam = _preluParam
      clone._pythonParam = _pythonParam
      clone._recurrentParam = _recurrentParam
      clone._reductionParam = _reductionParam
      clone._reluParam = _reluParam
      clone._reshapeParam = _reshapeParam
      clone._scaleParam = _scaleParam
      clone._sigmoidParam = _sigmoidParam
      clone._softmaxParam = _softmaxParam
      clone._sppParam = _sppParam
      clone._sliceParam = _sliceParam
      clone._tanhParam = _tanhParam
      clone._thresholdParam = _thresholdParam
      clone._tileParam = _tileParam
      clone._windowDataParam = _windowDataParam
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   the layer name
  public var name: String? {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///   the layer type
  public var type: String? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///   the name of each bottom blob
  public var bottom: [String] {
    get {return _storage._bottom}
    set {_uniqueStorage()._bottom = newValue}
  }

  ///   the name of each top blob
  public var top: [String] {
    get {return _storage._top}
    set {_uniqueStorage()._top = newValue}
  }

  ///   The train / test phase for computation.
  public var phase: Phase? {
    get {return _storage._phase}
    set {_uniqueStorage()._phase = newValue}
  }

  ///   The amount of weight to assign each top blob in the objective.
  ///   Each layer assigns a default value, usually of either 0 or 1,
  ///   to each top blob.
  public var lossWeight: [Float] {
    get {return _storage._lossWeight}
    set {_uniqueStorage()._lossWeight = newValue}
  }

  ///   Specifies training parameters (multipliers on global learning constants,
  ///   and the name and other settings used for weight sharing).
  public var param: [ParamSpec] {
    get {return _storage._param}
    set {_uniqueStorage()._param = newValue}
  }

  ///   The blobs containing the numeric parameters of the layer.
  public var blobs: [BlobProto] {
    get {return _storage._blobs}
    set {_uniqueStorage()._blobs = newValue}
  }

  ///   Specifies whether to backpropagate to each bottom. If unspecified,
  ///   Caffe will automatically infer whether each input needs backpropagation
  ///   to compute parameter gradients. If set to true for some inputs,
  ///   backpropagation to those inputs is forced; if set false for some inputs,
  ///   backpropagation to those inputs is skipped.
  ///  
  ///   The size must be either 0 or equal to the number of bottoms.
  public var propagateDown: [Bool] {
    get {return _storage._propagateDown}
    set {_uniqueStorage()._propagateDown = newValue}
  }

  ///   Rules controlling whether and when a layer is included in the network,
  ///   based on the current NetState.  You may specify a non-zero number of rules
  ///   to include OR exclude, but not both.  If no include or exclude rules are
  ///   specified, the layer is always included.  If the current NetState meets
  ///   ANY (i.e., one or more) of the specified rules, the layer is
  ///   included/excluded.
  public var include: [NetStateRule] {
    get {return _storage._include}
    set {_uniqueStorage()._include = newValue}
  }

  public var exclude: [NetStateRule] {
    get {return _storage._exclude}
    set {_uniqueStorage()._exclude = newValue}
  }

  ///   Parameters for data pre-processing.
  public var transformParam: TransformationParameter? {
    get {return _storage._transformParam}
    set {_uniqueStorage()._transformParam = newValue}
  }

  ///   Parameters shared by loss layers.
  public var lossParam: LossParameter? {
    get {return _storage._lossParam}
    set {_uniqueStorage()._lossParam = newValue}
  }

  ///   Layer type-specific parameters.
  ///  
  ///   Note: certain layers may have more than one computational engine
  ///   for their implementation. These layers include an Engine type and
  ///   engine parameter for selecting the implementation.
  ///   The default for the engine is set by the ENGINE switch at compile-time.
  public var accuracyParam: AccuracyParameter? {
    get {return _storage._accuracyParam}
    set {_uniqueStorage()._accuracyParam = newValue}
  }

  public var argmaxParam: ArgMaxParameter? {
    get {return _storage._argmaxParam}
    set {_uniqueStorage()._argmaxParam = newValue}
  }

  public var batchNormParam: BatchNormParameter? {
    get {return _storage._batchNormParam}
    set {_uniqueStorage()._batchNormParam = newValue}
  }

  public var biasParam: BiasParameter? {
    get {return _storage._biasParam}
    set {_uniqueStorage()._biasParam = newValue}
  }

  public var concatParam: ConcatParameter? {
    get {return _storage._concatParam}
    set {_uniqueStorage()._concatParam = newValue}
  }

  public var contrastiveLossParam: ContrastiveLossParameter? {
    get {return _storage._contrastiveLossParam}
    set {_uniqueStorage()._contrastiveLossParam = newValue}
  }

  public var convolutionParam: ConvolutionParameter? {
    get {return _storage._convolutionParam}
    set {_uniqueStorage()._convolutionParam = newValue}
  }

  public var cropParam: CropParameter? {
    get {return _storage._cropParam}
    set {_uniqueStorage()._cropParam = newValue}
  }

  public var dataParam: DataParameter? {
    get {return _storage._dataParam}
    set {_uniqueStorage()._dataParam = newValue}
  }

  public var dropoutParam: DropoutParameter? {
    get {return _storage._dropoutParam}
    set {_uniqueStorage()._dropoutParam = newValue}
  }

  public var dummyDataParam: DummyDataParameter? {
    get {return _storage._dummyDataParam}
    set {_uniqueStorage()._dummyDataParam = newValue}
  }

  public var eltwiseParam: EltwiseParameter? {
    get {return _storage._eltwiseParam}
    set {_uniqueStorage()._eltwiseParam = newValue}
  }

  public var eluParam: ELUParameter? {
    get {return _storage._eluParam}
    set {_uniqueStorage()._eluParam = newValue}
  }

  public var embedParam: EmbedParameter? {
    get {return _storage._embedParam}
    set {_uniqueStorage()._embedParam = newValue}
  }

  public var expParam: ExpParameter? {
    get {return _storage._expParam}
    set {_uniqueStorage()._expParam = newValue}
  }

  public var flattenParam: FlattenParameter? {
    get {return _storage._flattenParam}
    set {_uniqueStorage()._flattenParam = newValue}
  }

  public var hdf5DataParam: HDF5DataParameter? {
    get {return _storage._hdf5DataParam}
    set {_uniqueStorage()._hdf5DataParam = newValue}
  }

  public var hdf5OutputParam: HDF5OutputParameter? {
    get {return _storage._hdf5OutputParam}
    set {_uniqueStorage()._hdf5OutputParam = newValue}
  }

  public var hingeLossParam: HingeLossParameter? {
    get {return _storage._hingeLossParam}
    set {_uniqueStorage()._hingeLossParam = newValue}
  }

  public var imageDataParam: ImageDataParameter? {
    get {return _storage._imageDataParam}
    set {_uniqueStorage()._imageDataParam = newValue}
  }

  public var infogainLossParam: InfogainLossParameter? {
    get {return _storage._infogainLossParam}
    set {_uniqueStorage()._infogainLossParam = newValue}
  }

  public var innerProductParam: InnerProductParameter? {
    get {return _storage._innerProductParam}
    set {_uniqueStorage()._innerProductParam = newValue}
  }

  public var inputParam: InputParameter? {
    get {return _storage._inputParam}
    set {_uniqueStorage()._inputParam = newValue}
  }

  public var logParam: LogParameter? {
    get {return _storage._logParam}
    set {_uniqueStorage()._logParam = newValue}
  }

  public var lrnParam: LRNParameter? {
    get {return _storage._lrnParam}
    set {_uniqueStorage()._lrnParam = newValue}
  }

  public var memoryDataParam: MemoryDataParameter? {
    get {return _storage._memoryDataParam}
    set {_uniqueStorage()._memoryDataParam = newValue}
  }

  public var mvnParam: MVNParameter? {
    get {return _storage._mvnParam}
    set {_uniqueStorage()._mvnParam = newValue}
  }

  public var parameterParam: ParameterParameter? {
    get {return _storage._parameterParam}
    set {_uniqueStorage()._parameterParam = newValue}
  }

  public var poolingParam: PoolingParameter? {
    get {return _storage._poolingParam}
    set {_uniqueStorage()._poolingParam = newValue}
  }

  public var powerParam: PowerParameter? {
    get {return _storage._powerParam}
    set {_uniqueStorage()._powerParam = newValue}
  }

  public var preluParam: PReLUParameter? {
    get {return _storage._preluParam}
    set {_uniqueStorage()._preluParam = newValue}
  }

  public var pythonParam: PythonParameter? {
    get {return _storage._pythonParam}
    set {_uniqueStorage()._pythonParam = newValue}
  }

  public var recurrentParam: RecurrentParameter? {
    get {return _storage._recurrentParam}
    set {_uniqueStorage()._recurrentParam = newValue}
  }

  public var reductionParam: ReductionParameter? {
    get {return _storage._reductionParam}
    set {_uniqueStorage()._reductionParam = newValue}
  }

  public var reluParam: ReLUParameter? {
    get {return _storage._reluParam}
    set {_uniqueStorage()._reluParam = newValue}
  }

  public var reshapeParam: ReshapeParameter? {
    get {return _storage._reshapeParam}
    set {_uniqueStorage()._reshapeParam = newValue}
  }

  public var scaleParam: ScaleParameter? {
    get {return _storage._scaleParam}
    set {_uniqueStorage()._scaleParam = newValue}
  }

  public var sigmoidParam: SigmoidParameter? {
    get {return _storage._sigmoidParam}
    set {_uniqueStorage()._sigmoidParam = newValue}
  }

  public var softmaxParam: SoftmaxParameter? {
    get {return _storage._softmaxParam}
    set {_uniqueStorage()._softmaxParam = newValue}
  }

  public var sppParam: SPPParameter? {
    get {return _storage._sppParam}
    set {_uniqueStorage()._sppParam = newValue}
  }

  public var sliceParam: SliceParameter? {
    get {return _storage._sliceParam}
    set {_uniqueStorage()._sliceParam = newValue}
  }

  public var tanhParam: TanHParameter? {
    get {return _storage._tanhParam}
    set {_uniqueStorage()._tanhParam = newValue}
  }

  public var thresholdParam: ThresholdParameter? {
    get {return _storage._thresholdParam}
    set {_uniqueStorage()._thresholdParam = newValue}
  }

  public var tileParam: TileParameter? {
    get {return _storage._tileParam}
    set {_uniqueStorage()._tileParam = newValue}
  }

  public var windowDataParam: WindowDataParameter? {
    get {return _storage._windowDataParam}
    set {_uniqueStorage()._windowDataParam = newValue}
  }

  public init() {}

  public init(name: String? = nil,
    type: String? = nil,
    bottom: [String] = [],
    top: [String] = [],
    phase: Phase? = nil,
    lossWeight: [Float] = [],
    param: [ParamSpec] = [],
    blobs: [BlobProto] = [],
    propagateDown: [Bool] = [],
    include: [NetStateRule] = [],
    exclude: [NetStateRule] = [],
    transformParam: TransformationParameter? = nil,
    lossParam: LossParameter? = nil,
    accuracyParam: AccuracyParameter? = nil,
    argmaxParam: ArgMaxParameter? = nil,
    batchNormParam: BatchNormParameter? = nil,
    biasParam: BiasParameter? = nil,
    concatParam: ConcatParameter? = nil,
    contrastiveLossParam: ContrastiveLossParameter? = nil,
    convolutionParam: ConvolutionParameter? = nil,
    cropParam: CropParameter? = nil,
    dataParam: DataParameter? = nil,
    dropoutParam: DropoutParameter? = nil,
    dummyDataParam: DummyDataParameter? = nil,
    eltwiseParam: EltwiseParameter? = nil,
    eluParam: ELUParameter? = nil,
    embedParam: EmbedParameter? = nil,
    expParam: ExpParameter? = nil,
    flattenParam: FlattenParameter? = nil,
    hdf5DataParam: HDF5DataParameter? = nil,
    hdf5OutputParam: HDF5OutputParameter? = nil,
    hingeLossParam: HingeLossParameter? = nil,
    imageDataParam: ImageDataParameter? = nil,
    infogainLossParam: InfogainLossParameter? = nil,
    innerProductParam: InnerProductParameter? = nil,
    inputParam: InputParameter? = nil,
    logParam: LogParameter? = nil,
    lrnParam: LRNParameter? = nil,
    memoryDataParam: MemoryDataParameter? = nil,
    mvnParam: MVNParameter? = nil,
    parameterParam: ParameterParameter? = nil,
    poolingParam: PoolingParameter? = nil,
    powerParam: PowerParameter? = nil,
    preluParam: PReLUParameter? = nil,
    pythonParam: PythonParameter? = nil,
    recurrentParam: RecurrentParameter? = nil,
    reductionParam: ReductionParameter? = nil,
    reluParam: ReLUParameter? = nil,
    reshapeParam: ReshapeParameter? = nil,
    scaleParam: ScaleParameter? = nil,
    sigmoidParam: SigmoidParameter? = nil,
    softmaxParam: SoftmaxParameter? = nil,
    sppParam: SPPParameter? = nil,
    sliceParam: SliceParameter? = nil,
    tanhParam: TanHParameter? = nil,
    thresholdParam: ThresholdParameter? = nil,
    tileParam: TileParameter? = nil,
    windowDataParam: WindowDataParameter? = nil)
  {
    let storage = _uniqueStorage()
    storage._name = name
    storage._type = type
    if !bottom.isEmpty {
      storage._bottom = bottom
    }
    if !top.isEmpty {
      storage._top = top
    }
    storage._phase = phase
    if !lossWeight.isEmpty {
      storage._lossWeight = lossWeight
    }
    if !param.isEmpty {
      storage._param = param
    }
    if !blobs.isEmpty {
      storage._blobs = blobs
    }
    if !propagateDown.isEmpty {
      storage._propagateDown = propagateDown
    }
    if !include.isEmpty {
      storage._include = include
    }
    if !exclude.isEmpty {
      storage._exclude = exclude
    }
    storage._transformParam = transformParam
    storage._lossParam = lossParam
    storage._accuracyParam = accuracyParam
    storage._argmaxParam = argmaxParam
    storage._batchNormParam = batchNormParam
    storage._biasParam = biasParam
    storage._concatParam = concatParam
    storage._contrastiveLossParam = contrastiveLossParam
    storage._convolutionParam = convolutionParam
    storage._cropParam = cropParam
    storage._dataParam = dataParam
    storage._dropoutParam = dropoutParam
    storage._dummyDataParam = dummyDataParam
    storage._eltwiseParam = eltwiseParam
    storage._eluParam = eluParam
    storage._embedParam = embedParam
    storage._expParam = expParam
    storage._flattenParam = flattenParam
    storage._hdf5DataParam = hdf5DataParam
    storage._hdf5OutputParam = hdf5OutputParam
    storage._hingeLossParam = hingeLossParam
    storage._imageDataParam = imageDataParam
    storage._infogainLossParam = infogainLossParam
    storage._innerProductParam = innerProductParam
    storage._inputParam = inputParam
    storage._logParam = logParam
    storage._lrnParam = lrnParam
    storage._memoryDataParam = memoryDataParam
    storage._mvnParam = mvnParam
    storage._parameterParam = parameterParam
    storage._poolingParam = poolingParam
    storage._powerParam = powerParam
    storage._preluParam = preluParam
    storage._pythonParam = pythonParam
    storage._recurrentParam = recurrentParam
    storage._reductionParam = reductionParam
    storage._reluParam = reluParam
    storage._reshapeParam = reshapeParam
    storage._scaleParam = scaleParam
    storage._sigmoidParam = sigmoidParam
    storage._softmaxParam = softmaxParam
    storage._sppParam = sppParam
    storage._sliceParam = sliceParam
    storage._tanhParam = tanhParam
    storage._thresholdParam = thresholdParam
    storage._tileParam = tileParam
    storage._windowDataParam = windowDataParam
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: LayerParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Message that stores parameters used to apply transformation
///   to the data layer's data
public struct TransformationParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "TransformationParameter"}
  public var protoMessageName: String {return "TransformationParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "scale": 1,
    "mirror": 2,
    "cropSize": 3,
    "meanFile": 4,
    "meanValue": 5,
    "forceColor": 6,
    "forceGray": 7,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "scale": 1,
    "mirror": 2,
    "crop_size": 3,
    "mean_file": 4,
    "mean_value": 5,
    "force_color": 6,
    "force_gray": 7,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   For data pre-processing, we can do simple scaling and subtracting the
  ///   data mean, if provided. Note that the mean subtraction is always carried
  ///   out before scaling.
  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  ///   Specify if we want to randomly mirror data.
  private var _mirror: Bool? = nil
  public var mirror: Bool? {
    get {return _mirror ?? false}
    set {_mirror = newValue}
  }

  ///   Specify if we would like to randomly crop an image.
  private var _cropSize: UInt32? = nil
  public var cropSize: UInt32? {
    get {return _cropSize ?? 0}
    set {_cropSize = newValue}
  }

  ///   mean_file and mean_value cannot be specified at the same time
  public var meanFile: String? = nil

  ///   if specified can be repeated once (would subtract it from all the channels)
  ///   or can be repeated the same number of times as channels
  ///   (would subtract them from the corresponding channel)
  public var meanValue: [Float] = []

  ///   Force the decoded image to have 3 color channels.
  private var _forceColor: Bool? = nil
  public var forceColor: Bool? {
    get {return _forceColor ?? false}
    set {_forceColor = newValue}
  }

  ///   Force the decoded image to have 1 color channels.
  private var _forceGray: Bool? = nil
  public var forceGray: Bool? {
    get {return _forceGray ?? false}
    set {_forceGray = newValue}
  }

  public init() {}

  public init(scale: Float? = nil,
    mirror: Bool? = nil,
    cropSize: UInt32? = nil,
    meanFile: String? = nil,
    meanValue: [Float] = [],
    forceColor: Bool? = nil,
    forceGray: Bool? = nil)
  {
    self.scale = scale
    self.mirror = mirror
    self.cropSize = cropSize
    self.meanFile = meanFile
    if !meanValue.isEmpty {
      self.meanValue = meanValue
    }
    self.forceColor = forceColor
    self.forceGray = forceGray
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &mirror)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &cropSize)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &meanFile)
    case 5: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &meanValue)
    case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &forceColor)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &forceGray)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = mirror {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "mirror", jsonFieldName: "mirror", swiftFieldName: "mirror")
    }
    if let v = cropSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "crop_size", jsonFieldName: "cropSize", swiftFieldName: "cropSize")
    }
    if let v = meanFile {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 4, protoFieldName: "mean_file", jsonFieldName: "meanFile", swiftFieldName: "meanFile")
    }
    if !meanValue.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: meanValue, protoFieldNumber: 5, protoFieldName: "mean_value", jsonFieldName: "meanValue", swiftFieldName: "meanValue")
    }
    if let v = forceColor {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 6, protoFieldName: "force_color", jsonFieldName: "forceColor", swiftFieldName: "forceColor")
    }
    if let v = forceGray {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 7, protoFieldName: "force_gray", jsonFieldName: "forceGray", swiftFieldName: "forceGray")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: TransformationParameter) -> Bool {
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if (((mirror != nil && mirror! != false) || (other.mirror != nil && other.mirror! != false)) && (mirror == nil || other.mirror == nil || mirror! != other.mirror!)) {return false}
    if (((cropSize != nil && cropSize! != 0) || (other.cropSize != nil && other.cropSize! != 0)) && (cropSize == nil || other.cropSize == nil || cropSize! != other.cropSize!)) {return false}
    if ((meanFile != nil || other.meanFile != nil) && (meanFile == nil || other.meanFile == nil || meanFile! != other.meanFile!)) {return false}
    if meanValue != other.meanValue {return false}
    if (((forceColor != nil && forceColor! != false) || (other.forceColor != nil && other.forceColor! != false)) && (forceColor == nil || other.forceColor == nil || forceColor! != other.forceColor!)) {return false}
    if (((forceGray != nil && forceGray! != false) || (other.forceGray != nil && other.forceGray! != false)) && (forceGray == nil || other.forceGray == nil || forceGray! != other.forceGray!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters shared by loss layers
public struct LossParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "LossParameter"}
  public var protoMessageName: String {return "LossParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "ignoreLabel": 1,
    "normalization": 3,
    "normalize": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "ignore_label": 1,
    "normalization": 3,
    "normalize": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   How to normalize the loss for loss layers that aggregate across batches,
  ///   spatial dimensions, or other dimensions.  Currently only implemented in
  ///   SoftmaxWithLoss and SigmoidCrossEntropyLoss layers.
  public enum NormalizationMode: ProtobufEnum {
    public typealias RawValue = Int

    ///   Divide by the number of examples in the batch times spatial dimensions.
    ///   Outputs that receive the ignore label will NOT be ignored in computing
    ///   the normalization factor.
    case full // = 0

    ///   Divide by the total number of output locations that do not take the
    ///   ignore_label.  If ignore_label is not set, this behaves like FULL.
    case valid // = 1

    ///   Divide by the batch size.
    case batchSize // = 2

    ///   Do not normalize the loss.
    case none // = 3

    public init() {
      self = .full
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .full
      case 1: self = .valid
      case 2: self = .batchSize
      case 3: self = .none
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "full": self = .full
      case "valid": self = .valid
      case "batchSize": self = .batchSize
      case "none": self = .none
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "FULL": self = .full
      case "VALID": self = .valid
      case "BATCH_SIZE": self = .batchSize
      case "NONE": self = .none
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "FULL": self = .full
      case "VALID": self = .valid
      case "BATCH_SIZE": self = .batchSize
      case "NONE": self = .none
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .full: return 0
        case .valid: return 1
        case .batchSize: return 2
        case .none: return 3
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .full: return "\"FULL\""
        case .valid: return "\"VALID\""
        case .batchSize: return "\"BATCH_SIZE\""
        case .none: return "\"NONE\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .full: return ".full"
        case .valid: return ".valid"
        case .batchSize: return ".batchSize"
        case .none: return ".none"
        }
      }
    }

  }

  ///   If specified, ignore instances with the given label.
  public var ignoreLabel: Int32? = nil

  ///   For historical reasons, the default normalization for
  ///   SigmoidCrossEntropyLoss is BATCH_SIZE and *not* VALID.
  private var _normalization: LossParameter.NormalizationMode? = nil
  public var normalization: LossParameter.NormalizationMode? {
    get {return _normalization ?? LossParameter.NormalizationMode.valid}
    set {_normalization = newValue}
  }

  ///   Deprecated.  Ignored if normalization is specified.  If normalization
  ///   is not specified, then setting this to false will be equivalent to
  ///   normalization = BATCH_SIZE to be consistent with previous behavior.
  public var normalize: Bool? = nil

  public init() {}

  public init(ignoreLabel: Int32? = nil,
    normalization: LossParameter.NormalizationMode? = nil,
    normalize: Bool? = nil)
  {
    self.ignoreLabel = ignoreLabel
    self.normalization = normalization
    self.normalize = normalize
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &ignoreLabel)
    case 3: handled = try setter.decodeOptionalField(fieldType: LossParameter.NormalizationMode.self, value: &normalization)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &normalize)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = ignoreLabel {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "ignore_label", jsonFieldName: "ignoreLabel", swiftFieldName: "ignoreLabel")
    }
    if let v = normalize {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "normalize", jsonFieldName: "normalize", swiftFieldName: "normalize")
    }
    if let v = normalization {
      try visitor.visitSingularField(fieldType: LossParameter.NormalizationMode.self, value: v, protoFieldNumber: 3, protoFieldName: "normalization", jsonFieldName: "normalization", swiftFieldName: "normalization")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: LossParameter) -> Bool {
    if ((ignoreLabel != nil || other.ignoreLabel != nil) && (ignoreLabel == nil || other.ignoreLabel == nil || ignoreLabel! != other.ignoreLabel!)) {return false}
    if (((normalization != nil && normalization! != LossParameter.NormalizationMode.valid) || (other.normalization != nil && other.normalization! != LossParameter.NormalizationMode.valid)) && (normalization == nil || other.normalization == nil || normalization! != other.normalization!)) {return false}
    if ((normalize != nil || other.normalize != nil) && (normalize == nil || other.normalize == nil || normalize! != other.normalize!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

//  Messages that store parameters used by individual layer types follow, in
//  alphabetical order.
public struct AccuracyParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "AccuracyParameter"}
  public var protoMessageName: String {return "AccuracyParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "topK": 1,
    "axis": 2,
    "ignoreLabel": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "top_k": 1,
    "axis": 2,
    "ignore_label": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   When computing accuracy, count as correct by comparing the true label to
  ///   the top k scoring classes.  By default, only compare to the top scoring
  ///   class (i.e. argmax).
  private var _topK: UInt32? = nil
  public var topK: UInt32? {
    get {return _topK ?? 1}
    set {_topK = newValue}
  }

  ///   The "label" axis of the prediction blob, whose argmax corresponds to the
  ///   predicted label -- may be negative to index from the end (e.g., -1 for the
  ///   last axis).  For example, if axis == 1 and the predictions are
  ///   (N x C x H x W), the label blob is expected to contain N*H*W ground truth
  ///   labels with integer values in {0, 1, ..., C-1}.
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 1}
    set {_axis = newValue}
  }

  ///   If specified, ignore instances with the given label.
  public var ignoreLabel: Int32? = nil

  public init() {}

  public init(topK: UInt32? = nil,
    axis: Int32? = nil,
    ignoreLabel: Int32? = nil)
  {
    self.topK = topK
    self.axis = axis
    self.ignoreLabel = ignoreLabel
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &topK)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &ignoreLabel)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = topK {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "top_k", jsonFieldName: "topK", swiftFieldName: "topK")
    }
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    if let v = ignoreLabel {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "ignore_label", jsonFieldName: "ignoreLabel", swiftFieldName: "ignoreLabel")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: AccuracyParameter) -> Bool {
    if (((topK != nil && topK! != 1) || (other.topK != nil && other.topK! != 1)) && (topK == nil || other.topK == nil || topK! != other.topK!)) {return false}
    if (((axis != nil && axis! != 1) || (other.axis != nil && other.axis! != 1)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if ((ignoreLabel != nil || other.ignoreLabel != nil) && (ignoreLabel == nil || other.ignoreLabel == nil || ignoreLabel! != other.ignoreLabel!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct ArgMaxParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ArgMaxParameter"}
  public var protoMessageName: String {return "ArgMaxParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "outMaxVal": 1,
    "topK": 2,
    "axis": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "out_max_val": 1,
    "top_k": 2,
    "axis": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   If true produce pairs (argmax, maxval)
  private var _outMaxVal: Bool? = nil
  public var outMaxVal: Bool? {
    get {return _outMaxVal ?? false}
    set {_outMaxVal = newValue}
  }

  private var _topK: UInt32? = nil
  public var topK: UInt32? {
    get {return _topK ?? 1}
    set {_topK = newValue}
  }

  ///   The axis along which to maximise -- may be negative to index from the
  ///   end (e.g., -1 for the last axis).
  ///   By default ArgMaxLayer maximizes over the flattened trailing dimensions
  ///   for each index of the first / num dimension.
  public var axis: Int32? = nil

  public init() {}

  public init(outMaxVal: Bool? = nil,
    topK: UInt32? = nil,
    axis: Int32? = nil)
  {
    self.outMaxVal = outMaxVal
    self.topK = topK
    self.axis = axis
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &outMaxVal)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &topK)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = outMaxVal {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 1, protoFieldName: "out_max_val", jsonFieldName: "outMaxVal", swiftFieldName: "outMaxVal")
    }
    if let v = topK {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "top_k", jsonFieldName: "topK", swiftFieldName: "topK")
    }
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ArgMaxParameter) -> Bool {
    if (((outMaxVal != nil && outMaxVal! != false) || (other.outMaxVal != nil && other.outMaxVal! != false)) && (outMaxVal == nil || other.outMaxVal == nil || outMaxVal! != other.outMaxVal!)) {return false}
    if (((topK != nil && topK! != 1) || (other.topK != nil && other.topK! != 1)) && (topK == nil || other.topK == nil || topK! != other.topK!)) {return false}
    if ((axis != nil || other.axis != nil) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct ConcatParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ConcatParameter"}
  public var protoMessageName: String {return "ConcatParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 2,
    "concatDim": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 2,
    "concat_dim": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   The axis along which to concatenate -- may be negative to index from the
  ///   end (e.g., -1 for the last axis).  Other axes must have the
  ///   same dimension for all the bottom blobs.
  ///   By default, ConcatLayer concatenates blobs along the "channels" axis (1).
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 1}
    set {_axis = newValue}
  }

  ///   DEPRECATED: alias for "axis" -- does not support negative indexing.
  private var _concatDim: UInt32? = nil
  public var concatDim: UInt32? {
    get {return _concatDim ?? 1}
    set {_concatDim = newValue}
  }

  public init() {}

  public init(axis: Int32? = nil,
    concatDim: UInt32? = nil)
  {
    self.axis = axis
    self.concatDim = concatDim
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &concatDim)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = concatDim {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "concat_dim", jsonFieldName: "concatDim", swiftFieldName: "concatDim")
    }
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ConcatParameter) -> Bool {
    if (((axis != nil && axis! != 1) || (other.axis != nil && other.axis! != 1)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if (((concatDim != nil && concatDim! != 1) || (other.concatDim != nil && other.concatDim! != 1)) && (concatDim == nil || other.concatDim == nil || concatDim! != other.concatDim!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct BatchNormParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "BatchNormParameter"}
  public var protoMessageName: String {return "BatchNormParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "useGlobalStats": 1,
    "movingAverageFraction": 2,
    "eps": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "use_global_stats": 1,
    "moving_average_fraction": 2,
    "eps": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   If false, accumulate global mean/variance values via a moving average. If
  ///   true, use those accumulated values instead of computing mean/variance
  ///   across the batch.
  public var useGlobalStats: Bool? = nil

  ///   How much does the moving average decay each iteration?
  private var _movingAverageFraction: Float? = nil
  public var movingAverageFraction: Float? {
    get {return _movingAverageFraction ?? 0.999}
    set {_movingAverageFraction = newValue}
  }

  ///   Small value to add to the variance estimate so that we don't divide by
  ///   zero.
  private var _eps: Float? = nil
  public var eps: Float? {
    get {return _eps ?? 1e-05}
    set {_eps = newValue}
  }

  public init() {}

  public init(useGlobalStats: Bool? = nil,
    movingAverageFraction: Float? = nil,
    eps: Float? = nil)
  {
    self.useGlobalStats = useGlobalStats
    self.movingAverageFraction = movingAverageFraction
    self.eps = eps
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &useGlobalStats)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &movingAverageFraction)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &eps)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = useGlobalStats {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 1, protoFieldName: "use_global_stats", jsonFieldName: "useGlobalStats", swiftFieldName: "useGlobalStats")
    }
    if let v = movingAverageFraction {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "moving_average_fraction", jsonFieldName: "movingAverageFraction", swiftFieldName: "movingAverageFraction")
    }
    if let v = eps {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "eps", jsonFieldName: "eps", swiftFieldName: "eps")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: BatchNormParameter) -> Bool {
    if ((useGlobalStats != nil || other.useGlobalStats != nil) && (useGlobalStats == nil || other.useGlobalStats == nil || useGlobalStats! != other.useGlobalStats!)) {return false}
    if (((movingAverageFraction != nil && movingAverageFraction! != 0.999) || (other.movingAverageFraction != nil && other.movingAverageFraction! != 0.999)) && (movingAverageFraction == nil || other.movingAverageFraction == nil || movingAverageFraction! != other.movingAverageFraction!)) {return false}
    if (((eps != nil && eps! != 1e-05) || (other.eps != nil && other.eps! != 1e-05)) && (eps == nil || other.eps == nil || eps! != other.eps!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct BiasParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "BiasParameter"}
  public var protoMessageName: String {return "BiasParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 1,
    "numAxes": 2,
    "filler": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 1,
    "num_axes": 2,
    "filler": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = BiasParameter
    var unknown = ProtobufUnknownStorage()
    var _axis: Int32? = nil
    var _numAxes: Int32? = nil
    var _filler: FillerParameter? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_axis)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_numAxes)
      case 3: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_filler)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _axis {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
      }
      if let v = _numAxes {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "num_axes", jsonFieldName: "numAxes", swiftFieldName: "numAxes")
      }
      if let v = _filler {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "filler", jsonFieldName: "filler", swiftFieldName: "filler")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if (((_axis != nil && _axis! != 1) || (other._axis != nil && other._axis! != 1)) && (_axis == nil || other._axis == nil || _axis! != other._axis!)) {return false}
      if (((_numAxes != nil && _numAxes! != 1) || (other._numAxes != nil && other._numAxes! != 1)) && (_numAxes == nil || other._numAxes == nil || _numAxes! != other._numAxes!)) {return false}
      if ((_filler != nil || other._filler != nil) && (_filler == nil || other._filler == nil || _filler! != other._filler!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._axis = _axis
      clone._numAxes = _numAxes
      clone._filler = _filler
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The first axis of bottom[0] (the first input Blob) along which to apply
  ///   bottom[1] (the second input Blob).  May be negative to index from the end
  ///   (e.g., -1 for the last axis).
  ///  
  ///   For example, if bottom[0] is 4D with shape 100x3x40x60, the output
  ///   top[0] will have the same shape, and bottom[1] may have any of the
  ///   following shapes (for the given value of axis):
  ///      (axis == 0 == -4) 100; 100x3; 100x3x40; 100x3x40x60
  ///      (axis == 1 == -3)          3;     3x40;     3x40x60
  ///      (axis == 2 == -2)                   40;       40x60
  ///      (axis == 3 == -1)                                60
  ///   Furthermore, bottom[1] may have the empty shape (regardless of the value of
  ///   "axis") -- a scalar bias.
  public var axis: Int32? {
    get {return _storage._axis ?? 1}
    set {_uniqueStorage()._axis = newValue}
  }

  ///   (num_axes is ignored unless just one bottom is given and the bias is
  ///   a learned parameter of the layer.  Otherwise, num_axes is determined by the
  ///   number of axes by the second bottom.)
  ///   The number of axes of the input (bottom[0]) covered by the bias
  ///   parameter, or -1 to cover all axes of bottom[0] starting from `axis`.
  ///   Set num_axes := 0, to add a zero-axis Blob: a scalar.
  public var numAxes: Int32? {
    get {return _storage._numAxes ?? 1}
    set {_uniqueStorage()._numAxes = newValue}
  }

  ///   (filler is ignored unless just one bottom is given and the bias is
  ///   a learned parameter of the layer.)
  ///   The initialization for the learned bias parameter.
  ///   Default is the zero (0) initialization, resulting in the BiasLayer
  ///   initially performing the identity operation.
  public var filler: FillerParameter? {
    get {return _storage._filler}
    set {_uniqueStorage()._filler = newValue}
  }

  public init() {}

  public init(axis: Int32? = nil,
    numAxes: Int32? = nil,
    filler: FillerParameter? = nil)
  {
    let storage = _uniqueStorage()
    storage._axis = axis
    storage._numAxes = numAxes
    storage._filler = filler
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: BiasParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public struct ContrastiveLossParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ContrastiveLossParameter"}
  public var protoMessageName: String {return "ContrastiveLossParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "margin": 1,
    "legacyVersion": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "margin": 1,
    "legacy_version": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   margin for dissimilar pair
  private var _margin: Float? = nil
  public var margin: Float? {
    get {return _margin ?? 1}
    set {_margin = newValue}
  }

  ///   The first implementation of this cost did not exactly match the cost of
  ///   Hadsell et al 2006 -- using (margin - d^2) instead of (margin - d)^2.
  ///   legacy_version = false (the default) uses (margin - d)^2 as proposed in the
  ///   Hadsell paper. New models should probably use this version.
  ///   legacy_version = true uses (margin - d^2). This is kept to support /
  ///   reproduce existing models and results
  private var _legacyVersion: Bool? = nil
  public var legacyVersion: Bool? {
    get {return _legacyVersion ?? false}
    set {_legacyVersion = newValue}
  }

  public init() {}

  public init(margin: Float? = nil,
    legacyVersion: Bool? = nil)
  {
    self.margin = margin
    self.legacyVersion = legacyVersion
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &margin)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &legacyVersion)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = margin {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "margin", jsonFieldName: "margin", swiftFieldName: "margin")
    }
    if let v = legacyVersion {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "legacy_version", jsonFieldName: "legacyVersion", swiftFieldName: "legacyVersion")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ContrastiveLossParameter) -> Bool {
    if (((margin != nil && margin! != 1) || (other.margin != nil && other.margin! != 1)) && (margin == nil || other.margin == nil || margin! != other.margin!)) {return false}
    if (((legacyVersion != nil && legacyVersion! != false) || (other.legacyVersion != nil && other.legacyVersion! != false)) && (legacyVersion == nil || other.legacyVersion == nil || legacyVersion! != other.legacyVersion!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct ConvolutionParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ConvolutionParameter"}
  public var protoMessageName: String {return "ConvolutionParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "numOutput": 1,
    "biasTerm": 2,
    "pad": 3,
    "kernelSize": 4,
    "stride": 6,
    "dilation": 18,
    "padH": 9,
    "padW": 10,
    "kernelH": 11,
    "kernelW": 12,
    "strideH": 13,
    "strideW": 14,
    "group": 5,
    "weightFiller": 7,
    "biasFiller": 8,
    "engine": 15,
    "axis": 16,
    "forceNdIm2col": 17,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "num_output": 1,
    "bias_term": 2,
    "pad": 3,
    "kernel_size": 4,
    "stride": 6,
    "dilation": 18,
    "pad_h": 9,
    "pad_w": 10,
    "kernel_h": 11,
    "kernel_w": 12,
    "stride_h": 13,
    "stride_w": 14,
    "group": 5,
    "weight_filler": 7,
    "bias_filler": 8,
    "engine": 15,
    "axis": 16,
    "force_nd_im2col": 17,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = ConvolutionParameter
    var unknown = ProtobufUnknownStorage()
    var _numOutput: UInt32? = nil
    var _biasTerm: Bool? = nil
    var _pad: [UInt32] = []
    var _kernelSize: [UInt32] = []
    var _stride: [UInt32] = []
    var _dilation: [UInt32] = []
    var _padH: UInt32? = nil
    var _padW: UInt32? = nil
    var _kernelH: UInt32? = nil
    var _kernelW: UInt32? = nil
    var _strideH: UInt32? = nil
    var _strideW: UInt32? = nil
    var _group: UInt32? = nil
    var _weightFiller: FillerParameter? = nil
    var _biasFiller: FillerParameter? = nil
    var _engine: ConvolutionParameter.Engine? = nil
    var _axis: Int32? = nil
    var _forceNdIm2Col: Bool? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_numOutput)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_biasTerm)
      case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &_pad)
      case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &_kernelSize)
      case 6: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &_stride)
      case 18: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &_dilation)
      case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_padH)
      case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_padW)
      case 11: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_kernelH)
      case 12: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_kernelW)
      case 13: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_strideH)
      case 14: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_strideW)
      case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_group)
      case 7: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_weightFiller)
      case 8: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_biasFiller)
      case 15: handled = try setter.decodeOptionalField(fieldType: ConvolutionParameter.Engine.self, value: &_engine)
      case 16: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_axis)
      case 17: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_forceNdIm2Col)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _numOutput {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "num_output", jsonFieldName: "numOutput", swiftFieldName: "numOutput")
      }
      if let v = _biasTerm {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "bias_term", jsonFieldName: "biasTerm", swiftFieldName: "biasTerm")
      }
      if !_pad.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: _pad, protoFieldNumber: 3, protoFieldName: "pad", jsonFieldName: "pad", swiftFieldName: "pad")
      }
      if !_kernelSize.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: _kernelSize, protoFieldNumber: 4, protoFieldName: "kernel_size", jsonFieldName: "kernelSize", swiftFieldName: "kernelSize")
      }
      if let v = _group {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "group", jsonFieldName: "group", swiftFieldName: "group")
      }
      if !_stride.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: _stride, protoFieldNumber: 6, protoFieldName: "stride", jsonFieldName: "stride", swiftFieldName: "stride")
      }
      if let v = _weightFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 7, protoFieldName: "weight_filler", jsonFieldName: "weightFiller", swiftFieldName: "weightFiller")
      }
      if let v = _biasFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 8, protoFieldName: "bias_filler", jsonFieldName: "biasFiller", swiftFieldName: "biasFiller")
      }
      if let v = _padH {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 9, protoFieldName: "pad_h", jsonFieldName: "padH", swiftFieldName: "padH")
      }
      if let v = _padW {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 10, protoFieldName: "pad_w", jsonFieldName: "padW", swiftFieldName: "padW")
      }
      if let v = _kernelH {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 11, protoFieldName: "kernel_h", jsonFieldName: "kernelH", swiftFieldName: "kernelH")
      }
      if let v = _kernelW {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 12, protoFieldName: "kernel_w", jsonFieldName: "kernelW", swiftFieldName: "kernelW")
      }
      if let v = _strideH {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 13, protoFieldName: "stride_h", jsonFieldName: "strideH", swiftFieldName: "strideH")
      }
      if let v = _strideW {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 14, protoFieldName: "stride_w", jsonFieldName: "strideW", swiftFieldName: "strideW")
      }
      if let v = _engine {
        try visitor.visitSingularField(fieldType: ConvolutionParameter.Engine.self, value: v, protoFieldNumber: 15, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
      }
      if let v = _axis {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 16, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
      }
      if let v = _forceNdIm2Col {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 17, protoFieldName: "force_nd_im2col", jsonFieldName: "forceNdIm2col", swiftFieldName: "forceNdIm2Col")
      }
      if !_dilation.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: _dilation, protoFieldNumber: 18, protoFieldName: "dilation", jsonFieldName: "dilation", swiftFieldName: "dilation")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_numOutput != nil || other._numOutput != nil) && (_numOutput == nil || other._numOutput == nil || _numOutput! != other._numOutput!)) {return false}
      if (((_biasTerm != nil && _biasTerm! != true) || (other._biasTerm != nil && other._biasTerm! != true)) && (_biasTerm == nil || other._biasTerm == nil || _biasTerm! != other._biasTerm!)) {return false}
      if _pad != other._pad {return false}
      if _kernelSize != other._kernelSize {return false}
      if _stride != other._stride {return false}
      if _dilation != other._dilation {return false}
      if (((_padH != nil && _padH! != 0) || (other._padH != nil && other._padH! != 0)) && (_padH == nil || other._padH == nil || _padH! != other._padH!)) {return false}
      if (((_padW != nil && _padW! != 0) || (other._padW != nil && other._padW! != 0)) && (_padW == nil || other._padW == nil || _padW! != other._padW!)) {return false}
      if ((_kernelH != nil || other._kernelH != nil) && (_kernelH == nil || other._kernelH == nil || _kernelH! != other._kernelH!)) {return false}
      if ((_kernelW != nil || other._kernelW != nil) && (_kernelW == nil || other._kernelW == nil || _kernelW! != other._kernelW!)) {return false}
      if ((_strideH != nil || other._strideH != nil) && (_strideH == nil || other._strideH == nil || _strideH! != other._strideH!)) {return false}
      if ((_strideW != nil || other._strideW != nil) && (_strideW == nil || other._strideW == nil || _strideW! != other._strideW!)) {return false}
      if (((_group != nil && _group! != 1) || (other._group != nil && other._group! != 1)) && (_group == nil || other._group == nil || _group! != other._group!)) {return false}
      if ((_weightFiller != nil || other._weightFiller != nil) && (_weightFiller == nil || other._weightFiller == nil || _weightFiller! != other._weightFiller!)) {return false}
      if ((_biasFiller != nil || other._biasFiller != nil) && (_biasFiller == nil || other._biasFiller == nil || _biasFiller! != other._biasFiller!)) {return false}
      if (((_engine != nil && _engine! != ConvolutionParameter.Engine.`default`) || (other._engine != nil && other._engine! != ConvolutionParameter.Engine.`default`)) && (_engine == nil || other._engine == nil || _engine! != other._engine!)) {return false}
      if (((_axis != nil && _axis! != 1) || (other._axis != nil && other._axis! != 1)) && (_axis == nil || other._axis == nil || _axis! != other._axis!)) {return false}
      if (((_forceNdIm2Col != nil && _forceNdIm2Col! != false) || (other._forceNdIm2Col != nil && other._forceNdIm2Col! != false)) && (_forceNdIm2Col == nil || other._forceNdIm2Col == nil || _forceNdIm2Col! != other._forceNdIm2Col!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._numOutput = _numOutput
      clone._biasTerm = _biasTerm
      clone._pad = _pad
      clone._kernelSize = _kernelSize
      clone._stride = _stride
      clone._dilation = _dilation
      clone._padH = _padH
      clone._padW = _padW
      clone._kernelH = _kernelH
      clone._kernelW = _kernelW
      clone._strideH = _strideH
      clone._strideW = _strideW
      clone._group = _group
      clone._weightFiller = _weightFiller
      clone._biasFiller = _biasFiller
      clone._engine = _engine
      clone._axis = _axis
      clone._forceNdIm2Col = _forceNdIm2Col
      return clone
    }
  }

  private var _storage = _StorageClass()

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  ///   The number of outputs for the layer
  public var numOutput: UInt32? {
    get {return _storage._numOutput}
    set {_uniqueStorage()._numOutput = newValue}
  }

  ///   whether to have bias terms
  public var biasTerm: Bool? {
    get {return _storage._biasTerm ?? true}
    set {_uniqueStorage()._biasTerm = newValue}
  }

  ///   Pad, kernel size, and stride are all given as a single value for equal
  ///   dimensions in all spatial dimensions, or once per spatial dimension.
  public var pad: [UInt32] {
    get {return _storage._pad}
    set {_uniqueStorage()._pad = newValue}
  }

  ///   The kernel size
  public var kernelSize: [UInt32] {
    get {return _storage._kernelSize}
    set {_uniqueStorage()._kernelSize = newValue}
  }

  ///   The stride; defaults to 1
  public var stride: [UInt32] {
    get {return _storage._stride}
    set {_uniqueStorage()._stride = newValue}
  }

  ///   Factor used to dilate the kernel, (implicitly) zero-filling the resulting
  ///   holes. (Kernel dilation is sometimes referred to by its use in the
  ///   algorithme  trous from Holschneider et al. 1987.)
  public var dilation: [UInt32] {
    get {return _storage._dilation}
    set {_uniqueStorage()._dilation = newValue}
  }

  ///   For 2D convolution only, the *_h and *_w versions may also be used to
  ///   specify both spatial dimensions.
  public var padH: UInt32? {
    get {return _storage._padH ?? 0}
    set {_uniqueStorage()._padH = newValue}
  }

  ///   The padding width (2D only)
  public var padW: UInt32? {
    get {return _storage._padW ?? 0}
    set {_uniqueStorage()._padW = newValue}
  }

  ///   The kernel height (2D only)
  public var kernelH: UInt32? {
    get {return _storage._kernelH}
    set {_uniqueStorage()._kernelH = newValue}
  }

  ///   The kernel width (2D only)
  public var kernelW: UInt32? {
    get {return _storage._kernelW}
    set {_uniqueStorage()._kernelW = newValue}
  }

  ///   The stride height (2D only)
  public var strideH: UInt32? {
    get {return _storage._strideH}
    set {_uniqueStorage()._strideH = newValue}
  }

  ///   The stride width (2D only)
  public var strideW: UInt32? {
    get {return _storage._strideW}
    set {_uniqueStorage()._strideW = newValue}
  }

  ///   The group size for group conv
  public var group: UInt32? {
    get {return _storage._group ?? 1}
    set {_uniqueStorage()._group = newValue}
  }

  ///   The filler for the weight
  public var weightFiller: FillerParameter? {
    get {return _storage._weightFiller}
    set {_uniqueStorage()._weightFiller = newValue}
  }

  ///   The filler for the bias
  public var biasFiller: FillerParameter? {
    get {return _storage._biasFiller}
    set {_uniqueStorage()._biasFiller = newValue}
  }

  public var engine: ConvolutionParameter.Engine? {
    get {return _storage._engine ?? ConvolutionParameter.Engine.`default`}
    set {_uniqueStorage()._engine = newValue}
  }

  ///   The axis to interpret as "channels" when performing convolution.
  ///   Preceding dimensions are treated as independent inputs;
  ///   succeeding dimensions are treated as "spatial".
  ///   With (N, C, H, W) inputs, and axis == 1 (the default), we perform
  ///   N independent 2D convolutions, sliding C-channel (or (C/g)-channels, for
  ///   groups g>1) filters across the spatial axes (H, W) of the input.
  ///   With (N, C, D, H, W) inputs, and axis == 1, we perform
  ///   N independent 3D convolutions, sliding (C/g)-channels
  ///   filters across the spatial axes (D, H, W) of the input.
  public var axis: Int32? {
    get {return _storage._axis ?? 1}
    set {_uniqueStorage()._axis = newValue}
  }

  ///   Whether to force use of the general ND convolution, even if a specific
  ///   implementation for blobs of the appropriate number of spatial dimensions
  ///   is available. (Currently, there is only a 2D-specific convolution
  ///   implementation; for input blobs with num_axes != 2, this option is
  ///   ignored and the ND implementation will be used.)
  public var forceNdIm2Col: Bool? {
    get {return _storage._forceNdIm2Col ?? false}
    set {_uniqueStorage()._forceNdIm2Col = newValue}
  }

  public init() {}

  public init(numOutput: UInt32? = nil,
    biasTerm: Bool? = nil,
    pad: [UInt32] = [],
    kernelSize: [UInt32] = [],
    stride: [UInt32] = [],
    dilation: [UInt32] = [],
    padH: UInt32? = nil,
    padW: UInt32? = nil,
    kernelH: UInt32? = nil,
    kernelW: UInt32? = nil,
    strideH: UInt32? = nil,
    strideW: UInt32? = nil,
    group: UInt32? = nil,
    weightFiller: FillerParameter? = nil,
    biasFiller: FillerParameter? = nil,
    engine: ConvolutionParameter.Engine? = nil,
    axis: Int32? = nil,
    forceNdIm2Col: Bool? = nil)
  {
    let storage = _uniqueStorage()
    storage._numOutput = numOutput
    storage._biasTerm = biasTerm
    if !pad.isEmpty {
      storage._pad = pad
    }
    if !kernelSize.isEmpty {
      storage._kernelSize = kernelSize
    }
    if !stride.isEmpty {
      storage._stride = stride
    }
    if !dilation.isEmpty {
      storage._dilation = dilation
    }
    storage._padH = padH
    storage._padW = padW
    storage._kernelH = kernelH
    storage._kernelW = kernelW
    storage._strideH = strideH
    storage._strideW = strideW
    storage._group = group
    storage._weightFiller = weightFiller
    storage._biasFiller = biasFiller
    storage._engine = engine
    storage._axis = axis
    storage._forceNdIm2Col = forceNdIm2Col
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ConvolutionParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public struct CropParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "CropParameter"}
  public var protoMessageName: String {return "CropParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 1,
    "offset": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 1,
    "offset": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   To crop, elements of the first bottom are selected to fit the dimensions
  ///   of the second, reference bottom. The crop is configured by
  ///   - the crop `axis` to pick the dimensions for cropping
  ///   - the crop `offset` to set the shift for all/each dimension
  ///   to align the cropped bottom with the reference bottom.
  ///   All dimensions up to but excluding `axis` are preserved, while
  ///   the dimensions including and trailing `axis` are cropped.
  ///   If only one `offset` is set, then all dimensions are offset by this amount.
  ///   Otherwise, the number of offsets must equal the number of cropped axes to
  ///   shift the crop in each dimension accordingly.
  ///   Note: standard dimensions are N,C,H,W so the default is a spatial crop,
  ///   and `axis` may be negative to index from the end (e.g., -1 for the last
  ///   axis).
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 2}
    set {_axis = newValue}
  }

  public var offset: [UInt32] = []

  public init() {}

  public init(axis: Int32? = nil,
    offset: [UInt32] = [])
  {
    self.axis = axis
    if !offset.isEmpty {
      self.offset = offset
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &offset)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    if !offset.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: offset, protoFieldNumber: 2, protoFieldName: "offset", jsonFieldName: "offset", swiftFieldName: "offset")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: CropParameter) -> Bool {
    if (((axis != nil && axis! != 2) || (other.axis != nil && other.axis! != 2)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if offset != other.offset {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct DataParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "DataParameter"}
  public var protoMessageName: String {return "DataParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "source": 1,
    "batchSize": 4,
    "randSkip": 7,
    "backend": 8,
    "scale": 2,
    "meanFile": 3,
    "cropSize": 5,
    "mirror": 6,
    "forceEncodedColor": 9,
    "prefetch": 10,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "source": 1,
    "batch_size": 4,
    "rand_skip": 7,
    "backend": 8,
    "scale": 2,
    "mean_file": 3,
    "crop_size": 5,
    "mirror": 6,
    "force_encoded_color": 9,
    "prefetch": 10,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum DB: ProtobufEnum {
    public typealias RawValue = Int
    case leveldb // = 0
    case lmdb // = 1

    public init() {
      self = .leveldb
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .leveldb
      case 1: self = .lmdb
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "leveldb": self = .leveldb
      case "lmdb": self = .lmdb
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "LEVELDB": self = .leveldb
      case "LMDB": self = .lmdb
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "LEVELDB": self = .leveldb
      case "LMDB": self = .lmdb
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .leveldb: return 0
        case .lmdb: return 1
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .leveldb: return "\"LEVELDB\""
        case .lmdb: return "\"LMDB\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .leveldb: return ".leveldb"
        case .lmdb: return ".lmdb"
        }
      }
    }

  }

  ///   Specify the data source.
  public var source: String? = nil

  ///   Specify the batch size.
  public var batchSize: UInt32? = nil

  ///   The rand_skip variable is for the data layer to skip a few data points
  ///   to avoid all asynchronous sgd clients to start at the same point. The skip
  ///   point would be set as rand_skip * rand(0,1). Note that rand_skip should not
  ///   be larger than the number of keys in the database.
  ///   DEPRECATED. Each solver accesses a different subset of the database.
  private var _randSkip: UInt32? = nil
  public var randSkip: UInt32? {
    get {return _randSkip ?? 0}
    set {_randSkip = newValue}
  }

  private var _backend: DataParameter.DB? = nil
  public var backend: DataParameter.DB? {
    get {return _backend ?? DataParameter.DB.leveldb}
    set {_backend = newValue}
  }

  ///   DEPRECATED. See TransformationParameter. For data pre-processing, we can do
  ///   simple scaling and subtracting the data mean, if provided. Note that the
  ///   mean subtraction is always carried out before scaling.
  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  public var meanFile: String? = nil

  ///   DEPRECATED. See TransformationParameter. Specify if we would like to randomly
  ///   crop an image.
  private var _cropSize: UInt32? = nil
  public var cropSize: UInt32? {
    get {return _cropSize ?? 0}
    set {_cropSize = newValue}
  }

  ///   DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
  ///   data.
  private var _mirror: Bool? = nil
  public var mirror: Bool? {
    get {return _mirror ?? false}
    set {_mirror = newValue}
  }

  ///   Force the encoded image to have 3 color channels
  private var _forceEncodedColor: Bool? = nil
  public var forceEncodedColor: Bool? {
    get {return _forceEncodedColor ?? false}
    set {_forceEncodedColor = newValue}
  }

  ///   Prefetch queue (Increase if data feeding bandwidth varies, within the
  ///   limit of device memory for GPU training)
  private var _prefetch: UInt32? = nil
  public var prefetch: UInt32? {
    get {return _prefetch ?? 4}
    set {_prefetch = newValue}
  }

  public init() {}

  public init(source: String? = nil,
    batchSize: UInt32? = nil,
    randSkip: UInt32? = nil,
    backend: DataParameter.DB? = nil,
    scale: Float? = nil,
    meanFile: String? = nil,
    cropSize: UInt32? = nil,
    mirror: Bool? = nil,
    forceEncodedColor: Bool? = nil,
    prefetch: UInt32? = nil)
  {
    self.source = source
    self.batchSize = batchSize
    self.randSkip = randSkip
    self.backend = backend
    self.scale = scale
    self.meanFile = meanFile
    self.cropSize = cropSize
    self.mirror = mirror
    self.forceEncodedColor = forceEncodedColor
    self.prefetch = prefetch
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &source)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &batchSize)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &randSkip)
    case 8: handled = try setter.decodeOptionalField(fieldType: DataParameter.DB.self, value: &backend)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &meanFile)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &cropSize)
    case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &mirror)
    case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &forceEncodedColor)
    case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &prefetch)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = source {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "source", jsonFieldName: "source", swiftFieldName: "source")
    }
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = meanFile {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 3, protoFieldName: "mean_file", jsonFieldName: "meanFile", swiftFieldName: "meanFile")
    }
    if let v = batchSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "batch_size", jsonFieldName: "batchSize", swiftFieldName: "batchSize")
    }
    if let v = cropSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "crop_size", jsonFieldName: "cropSize", swiftFieldName: "cropSize")
    }
    if let v = mirror {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 6, protoFieldName: "mirror", jsonFieldName: "mirror", swiftFieldName: "mirror")
    }
    if let v = randSkip {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 7, protoFieldName: "rand_skip", jsonFieldName: "randSkip", swiftFieldName: "randSkip")
    }
    if let v = backend {
      try visitor.visitSingularField(fieldType: DataParameter.DB.self, value: v, protoFieldNumber: 8, protoFieldName: "backend", jsonFieldName: "backend", swiftFieldName: "backend")
    }
    if let v = forceEncodedColor {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 9, protoFieldName: "force_encoded_color", jsonFieldName: "forceEncodedColor", swiftFieldName: "forceEncodedColor")
    }
    if let v = prefetch {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 10, protoFieldName: "prefetch", jsonFieldName: "prefetch", swiftFieldName: "prefetch")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: DataParameter) -> Bool {
    if ((source != nil || other.source != nil) && (source == nil || other.source == nil || source! != other.source!)) {return false}
    if ((batchSize != nil || other.batchSize != nil) && (batchSize == nil || other.batchSize == nil || batchSize! != other.batchSize!)) {return false}
    if (((randSkip != nil && randSkip! != 0) || (other.randSkip != nil && other.randSkip! != 0)) && (randSkip == nil || other.randSkip == nil || randSkip! != other.randSkip!)) {return false}
    if (((backend != nil && backend! != DataParameter.DB.leveldb) || (other.backend != nil && other.backend! != DataParameter.DB.leveldb)) && (backend == nil || other.backend == nil || backend! != other.backend!)) {return false}
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if ((meanFile != nil || other.meanFile != nil) && (meanFile == nil || other.meanFile == nil || meanFile! != other.meanFile!)) {return false}
    if (((cropSize != nil && cropSize! != 0) || (other.cropSize != nil && other.cropSize! != 0)) && (cropSize == nil || other.cropSize == nil || cropSize! != other.cropSize!)) {return false}
    if (((mirror != nil && mirror! != false) || (other.mirror != nil && other.mirror! != false)) && (mirror == nil || other.mirror == nil || mirror! != other.mirror!)) {return false}
    if (((forceEncodedColor != nil && forceEncodedColor! != false) || (other.forceEncodedColor != nil && other.forceEncodedColor! != false)) && (forceEncodedColor == nil || other.forceEncodedColor == nil || forceEncodedColor! != other.forceEncodedColor!)) {return false}
    if (((prefetch != nil && prefetch! != 4) || (other.prefetch != nil && other.prefetch! != 4)) && (prefetch == nil || other.prefetch == nil || prefetch! != other.prefetch!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct DropoutParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "DropoutParameter"}
  public var protoMessageName: String {return "DropoutParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "dropoutRatio": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "dropout_ratio": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   dropout ratio
  private var _dropoutRatio: Float? = nil
  public var dropoutRatio: Float? {
    get {return _dropoutRatio ?? 0.5}
    set {_dropoutRatio = newValue}
  }

  public init() {}

  public init(dropoutRatio: Float? = nil)
  {
    self.dropoutRatio = dropoutRatio
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &dropoutRatio)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = dropoutRatio {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "dropout_ratio", jsonFieldName: "dropoutRatio", swiftFieldName: "dropoutRatio")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: DropoutParameter) -> Bool {
    if (((dropoutRatio != nil && dropoutRatio! != 0.5) || (other.dropoutRatio != nil && other.dropoutRatio! != 0.5)) && (dropoutRatio == nil || other.dropoutRatio == nil || dropoutRatio! != other.dropoutRatio!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   DummyDataLayer fills any number of arbitrarily shaped blobs with random
///   (or constant) data generated by "Fillers" (see "message FillerParameter").
public struct DummyDataParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "DummyDataParameter"}
  public var protoMessageName: String {return "DummyDataParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "dataFiller": 1,
    "shape": 6,
    "num": 2,
    "channels": 3,
    "height": 4,
    "width": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "data_filler": 1,
    "shape": 6,
    "num": 2,
    "channels": 3,
    "height": 4,
    "width": 5,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   This layer produces N >= 1 top blobs.  DummyDataParameter must specify 1 or N
  ///   shape fields, and 0, 1 or N data_fillers.
  ///  
  ///   If 0 data_fillers are specified, ConstantFiller with a value of 0 is used.
  ///   If 1 data_filler is specified, it is applied to all top blobs.  If N are
  ///   specified, the ith is applied to the ith top blob.
  public var dataFiller: [FillerParameter] = []

  public var shape: [BlobShape] = []

  ///   4D dimensions -- deprecated.  Use "shape" instead.
  public var num: [UInt32] = []

  public var channels: [UInt32] = []

  public var height: [UInt32] = []

  public var width: [UInt32] = []

  public init() {}

  public init(dataFiller: [FillerParameter] = [],
    shape: [BlobShape] = [],
    num: [UInt32] = [],
    channels: [UInt32] = [],
    height: [UInt32] = [],
    width: [UInt32] = [])
  {
    if !dataFiller.isEmpty {
      self.dataFiller = dataFiller
    }
    if !shape.isEmpty {
      self.shape = shape
    }
    if !num.isEmpty {
      self.num = num
    }
    if !channels.isEmpty {
      self.channels = channels
    }
    if !height.isEmpty {
      self.height = height
    }
    if !width.isEmpty {
      self.width = width
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: FillerParameter.self, value: &dataFiller)
    case 6: handled = try setter.decodeRepeatedMessageField(fieldType: BlobShape.self, value: &shape)
    case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &num)
    case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &channels)
    case 4: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &height)
    case 5: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &width)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !dataFiller.isEmpty {
      try visitor.visitRepeatedMessageField(value: dataFiller, protoFieldNumber: 1, protoFieldName: "data_filler", jsonFieldName: "dataFiller", swiftFieldName: "dataFiller")
    }
    if !num.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: num, protoFieldNumber: 2, protoFieldName: "num", jsonFieldName: "num", swiftFieldName: "num")
    }
    if !channels.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: channels, protoFieldNumber: 3, protoFieldName: "channels", jsonFieldName: "channels", swiftFieldName: "channels")
    }
    if !height.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: height, protoFieldNumber: 4, protoFieldName: "height", jsonFieldName: "height", swiftFieldName: "height")
    }
    if !width.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: width, protoFieldNumber: 5, protoFieldName: "width", jsonFieldName: "width", swiftFieldName: "width")
    }
    if !shape.isEmpty {
      try visitor.visitRepeatedMessageField(value: shape, protoFieldNumber: 6, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: DummyDataParameter) -> Bool {
    if dataFiller != other.dataFiller {return false}
    if shape != other.shape {return false}
    if num != other.num {return false}
    if channels != other.channels {return false}
    if height != other.height {return false}
    if width != other.width {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct EltwiseParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "EltwiseParameter"}
  public var protoMessageName: String {return "EltwiseParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "operation": 1,
    "coeff": 2,
    "stableProdGrad": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "operation": 1,
    "coeff": 2,
    "stable_prod_grad": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum EltwiseOp: ProtobufEnum {
    public typealias RawValue = Int
    case prod // = 0
    case sum // = 1
    case max // = 2

    public init() {
      self = .prod
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .prod
      case 1: self = .sum
      case 2: self = .max
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "prod": self = .prod
      case "sum": self = .sum
      case "max": self = .max
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "PROD": self = .prod
      case "SUM": self = .sum
      case "MAX": self = .max
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "PROD": self = .prod
      case "SUM": self = .sum
      case "MAX": self = .max
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .prod: return 0
        case .sum: return 1
        case .max: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .prod: return "\"PROD\""
        case .sum: return "\"SUM\""
        case .max: return "\"MAX\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .prod: return ".prod"
        case .sum: return ".sum"
        case .max: return ".max"
        }
      }
    }

  }

  ///   element-wise operation
  private var _operation: EltwiseParameter.EltwiseOp? = nil
  public var operation: EltwiseParameter.EltwiseOp? {
    get {return _operation ?? EltwiseParameter.EltwiseOp.sum}
    set {_operation = newValue}
  }

  ///   blob-wise coefficient for SUM operation
  public var coeff: [Float] = []

  ///   Whether to use an asymptotically slower (for >2 inputs) but stabler method
  ///   of computing the gradient for the PROD operation. (No effect for SUM op.)
  private var _stableProdGrad: Bool? = nil
  public var stableProdGrad: Bool? {
    get {return _stableProdGrad ?? true}
    set {_stableProdGrad = newValue}
  }

  public init() {}

  public init(operation: EltwiseParameter.EltwiseOp? = nil,
    coeff: [Float] = [],
    stableProdGrad: Bool? = nil)
  {
    self.operation = operation
    if !coeff.isEmpty {
      self.coeff = coeff
    }
    self.stableProdGrad = stableProdGrad
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: EltwiseParameter.EltwiseOp.self, value: &operation)
    case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &coeff)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &stableProdGrad)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = operation {
      try visitor.visitSingularField(fieldType: EltwiseParameter.EltwiseOp.self, value: v, protoFieldNumber: 1, protoFieldName: "operation", jsonFieldName: "operation", swiftFieldName: "operation")
    }
    if !coeff.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: coeff, protoFieldNumber: 2, protoFieldName: "coeff", jsonFieldName: "coeff", swiftFieldName: "coeff")
    }
    if let v = stableProdGrad {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 3, protoFieldName: "stable_prod_grad", jsonFieldName: "stableProdGrad", swiftFieldName: "stableProdGrad")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: EltwiseParameter) -> Bool {
    if (((operation != nil && operation! != EltwiseParameter.EltwiseOp.sum) || (other.operation != nil && other.operation! != EltwiseParameter.EltwiseOp.sum)) && (operation == nil || other.operation == nil || operation! != other.operation!)) {return false}
    if coeff != other.coeff {return false}
    if (((stableProdGrad != nil && stableProdGrad! != true) || (other.stableProdGrad != nil && other.stableProdGrad! != true)) && (stableProdGrad == nil || other.stableProdGrad == nil || stableProdGrad! != other.stableProdGrad!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by ELULayer
public struct ELUParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ELUParameter"}
  public var protoMessageName: String {return "ELUParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "alpha": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "alpha": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Described in:
  ///   Clevert, D.-A., Unterthiner, T., & Hochreiter, S. (2015). Fast and Accurate
  ///   Deep Network Learning by Exponential Linear Units (ELUs). arXiv
  private var _alpha: Float? = nil
  public var alpha: Float? {
    get {return _alpha ?? 1}
    set {_alpha = newValue}
  }

  public init() {}

  public init(alpha: Float? = nil)
  {
    self.alpha = alpha
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &alpha)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = alpha {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "alpha", jsonFieldName: "alpha", swiftFieldName: "alpha")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ELUParameter) -> Bool {
    if (((alpha != nil && alpha! != 1) || (other.alpha != nil && other.alpha! != 1)) && (alpha == nil || other.alpha == nil || alpha! != other.alpha!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by EmbedLayer
public struct EmbedParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "EmbedParameter"}
  public var protoMessageName: String {return "EmbedParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "numOutput": 1,
    "inputDim": 2,
    "biasTerm": 3,
    "weightFiller": 4,
    "biasFiller": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "num_output": 1,
    "input_dim": 2,
    "bias_term": 3,
    "weight_filler": 4,
    "bias_filler": 5,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = EmbedParameter
    var unknown = ProtobufUnknownStorage()
    var _numOutput: UInt32? = nil
    var _inputDim: UInt32? = nil
    var _biasTerm: Bool? = nil
    var _weightFiller: FillerParameter? = nil
    var _biasFiller: FillerParameter? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_numOutput)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_inputDim)
      case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_biasTerm)
      case 4: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_weightFiller)
      case 5: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_biasFiller)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _numOutput {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "num_output", jsonFieldName: "numOutput", swiftFieldName: "numOutput")
      }
      if let v = _inputDim {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "input_dim", jsonFieldName: "inputDim", swiftFieldName: "inputDim")
      }
      if let v = _biasTerm {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 3, protoFieldName: "bias_term", jsonFieldName: "biasTerm", swiftFieldName: "biasTerm")
      }
      if let v = _weightFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "weight_filler", jsonFieldName: "weightFiller", swiftFieldName: "weightFiller")
      }
      if let v = _biasFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "bias_filler", jsonFieldName: "biasFiller", swiftFieldName: "biasFiller")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_numOutput != nil || other._numOutput != nil) && (_numOutput == nil || other._numOutput == nil || _numOutput! != other._numOutput!)) {return false}
      if ((_inputDim != nil || other._inputDim != nil) && (_inputDim == nil || other._inputDim == nil || _inputDim! != other._inputDim!)) {return false}
      if (((_biasTerm != nil && _biasTerm! != true) || (other._biasTerm != nil && other._biasTerm! != true)) && (_biasTerm == nil || other._biasTerm == nil || _biasTerm! != other._biasTerm!)) {return false}
      if ((_weightFiller != nil || other._weightFiller != nil) && (_weightFiller == nil || other._weightFiller == nil || _weightFiller! != other._weightFiller!)) {return false}
      if ((_biasFiller != nil || other._biasFiller != nil) && (_biasFiller == nil || other._biasFiller == nil || _biasFiller! != other._biasFiller!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._numOutput = _numOutput
      clone._inputDim = _inputDim
      clone._biasTerm = _biasTerm
      clone._weightFiller = _weightFiller
      clone._biasFiller = _biasFiller
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The number of outputs for the layer
  public var numOutput: UInt32? {
    get {return _storage._numOutput}
    set {_uniqueStorage()._numOutput = newValue}
  }

  ///   The input is given as integers to be interpreted as one-hot
  ///   vector indices with dimension num_input.  Hence num_input should be
  ///   1 greater than the maximum possible input value.
  public var inputDim: UInt32? {
    get {return _storage._inputDim}
    set {_uniqueStorage()._inputDim = newValue}
  }

  ///   Whether to use a bias term
  public var biasTerm: Bool? {
    get {return _storage._biasTerm ?? true}
    set {_uniqueStorage()._biasTerm = newValue}
  }

  ///   The filler for the weight
  public var weightFiller: FillerParameter? {
    get {return _storage._weightFiller}
    set {_uniqueStorage()._weightFiller = newValue}
  }

  ///   The filler for the bias
  public var biasFiller: FillerParameter? {
    get {return _storage._biasFiller}
    set {_uniqueStorage()._biasFiller = newValue}
  }

  public init() {}

  public init(numOutput: UInt32? = nil,
    inputDim: UInt32? = nil,
    biasTerm: Bool? = nil,
    weightFiller: FillerParameter? = nil,
    biasFiller: FillerParameter? = nil)
  {
    let storage = _uniqueStorage()
    storage._numOutput = numOutput
    storage._inputDim = inputDim
    storage._biasTerm = biasTerm
    storage._weightFiller = weightFiller
    storage._biasFiller = biasFiller
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: EmbedParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Message that stores parameters used by ExpLayer
public struct ExpParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ExpParameter"}
  public var protoMessageName: String {return "ExpParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "base": 1,
    "scale": 2,
    "shift": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "base": 1,
    "scale": 2,
    "shift": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   ExpLayer computes outputs y = base ^ (shift + scale * x), for base > 0.
  ///   Or if base is set to the default (-1), base is set to e,
  ///   so y = exp(shift + scale * x).
  private var _base: Float? = nil
  public var base: Float? {
    get {return _base ?? -1}
    set {_base = newValue}
  }

  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  private var _shift: Float? = nil
  public var shift: Float? {
    get {return _shift ?? 0}
    set {_shift = newValue}
  }

  public init() {}

  public init(base: Float? = nil,
    scale: Float? = nil,
    shift: Float? = nil)
  {
    self.base = base
    self.scale = scale
    self.shift = shift
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &base)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &shift)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = base {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "base", jsonFieldName: "base", swiftFieldName: "base")
    }
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = shift {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "shift", jsonFieldName: "shift", swiftFieldName: "shift")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ExpParameter) -> Bool {
    if (((base != nil && base! != -1) || (other.base != nil && other.base! != -1)) && (base == nil || other.base == nil || base! != other.base!)) {return false}
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if (((shift != nil && shift! != 0) || (other.shift != nil && other.shift! != 0)) && (shift == nil || other.shift == nil || shift! != other.shift!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   / Message that stores parameters used by FlattenLayer
public struct FlattenParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "FlattenParameter"}
  public var protoMessageName: String {return "FlattenParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 1,
    "endAxis": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 1,
    "end_axis": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   The first axis to flatten: all preceding axes are retained in the output.
  ///   May be negative to index from the end (e.g., -1 for the last axis).
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 1}
    set {_axis = newValue}
  }

  ///   The last axis to flatten: all following axes are retained in the output.
  ///   May be negative to index from the end (e.g., the default -1 for the last
  ///   axis).
  private var _endAxis: Int32? = nil
  public var endAxis: Int32? {
    get {return _endAxis ?? -1}
    set {_endAxis = newValue}
  }

  public init() {}

  public init(axis: Int32? = nil,
    endAxis: Int32? = nil)
  {
    self.axis = axis
    self.endAxis = endAxis
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &endAxis)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    if let v = endAxis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "end_axis", jsonFieldName: "endAxis", swiftFieldName: "endAxis")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: FlattenParameter) -> Bool {
    if (((axis != nil && axis! != 1) || (other.axis != nil && other.axis! != 1)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if (((endAxis != nil && endAxis! != -1) || (other.endAxis != nil && other.endAxis! != -1)) && (endAxis == nil || other.endAxis == nil || endAxis! != other.endAxis!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by HDF5DataLayer
public struct HDF5DataParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "HDF5DataParameter"}
  public var protoMessageName: String {return "HDF5DataParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "source": 1,
    "batchSize": 2,
    "shuffle": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "source": 1,
    "batch_size": 2,
    "shuffle": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Specify the data source.
  public var source: String? = nil

  ///   Specify the batch size.
  public var batchSize: UInt32? = nil

  ///   Specify whether to shuffle the data.
  ///   If shuffle == true, the ordering of the HDF5 files is shuffled,
  ///   and the ordering of data within any given HDF5 file is shuffled,
  ///   but data between different files are not interleaved; all of a file's
  ///   data are output (in a random order) before moving onto another file.
  private var _shuffle: Bool? = nil
  public var shuffle: Bool? {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }

  public init() {}

  public init(source: String? = nil,
    batchSize: UInt32? = nil,
    shuffle: Bool? = nil)
  {
    self.source = source
    self.batchSize = batchSize
    self.shuffle = shuffle
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &source)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &batchSize)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &shuffle)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = source {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "source", jsonFieldName: "source", swiftFieldName: "source")
    }
    if let v = batchSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "batch_size", jsonFieldName: "batchSize", swiftFieldName: "batchSize")
    }
    if let v = shuffle {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 3, protoFieldName: "shuffle", jsonFieldName: "shuffle", swiftFieldName: "shuffle")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: HDF5DataParameter) -> Bool {
    if ((source != nil || other.source != nil) && (source == nil || other.source == nil || source! != other.source!)) {return false}
    if ((batchSize != nil || other.batchSize != nil) && (batchSize == nil || other.batchSize == nil || batchSize! != other.batchSize!)) {return false}
    if (((shuffle != nil && shuffle! != false) || (other.shuffle != nil && other.shuffle! != false)) && (shuffle == nil || other.shuffle == nil || shuffle! != other.shuffle!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct HDF5OutputParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "HDF5OutputParameter"}
  public var protoMessageName: String {return "HDF5OutputParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "fileName": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "file_name": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var fileName: String? = nil

  public init() {}

  public init(fileName: String? = nil)
  {
    self.fileName = fileName
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &fileName)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = fileName {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "file_name", jsonFieldName: "fileName", swiftFieldName: "fileName")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: HDF5OutputParameter) -> Bool {
    if ((fileName != nil || other.fileName != nil) && (fileName == nil || other.fileName == nil || fileName! != other.fileName!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct HingeLossParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "HingeLossParameter"}
  public var protoMessageName: String {return "HingeLossParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "norm": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "norm": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum Norm: ProtobufEnum {
    public typealias RawValue = Int
    case l1 // = 1
    case l2 // = 2

    public init() {
      self = .l1
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .l1
      case 2: self = .l2
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "l1": self = .l1
      case "l2": self = .l2
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "L1": self = .l1
      case "L2": self = .l2
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "L1": self = .l1
      case "L2": self = .l2
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .l1: return 1
        case .l2: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .l1: return "\"L1\""
        case .l2: return "\"L2\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .l1: return ".l1"
        case .l2: return ".l2"
        }
      }
    }

  }

  ///   Specify the Norm to use L1 or L2
  private var _norm: HingeLossParameter.Norm? = nil
  public var norm: HingeLossParameter.Norm? {
    get {return _norm ?? HingeLossParameter.Norm.l1}
    set {_norm = newValue}
  }

  public init() {}

  public init(norm: HingeLossParameter.Norm? = nil)
  {
    self.norm = norm
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: HingeLossParameter.Norm.self, value: &norm)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = norm {
      try visitor.visitSingularField(fieldType: HingeLossParameter.Norm.self, value: v, protoFieldNumber: 1, protoFieldName: "norm", jsonFieldName: "norm", swiftFieldName: "norm")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: HingeLossParameter) -> Bool {
    if (((norm != nil && norm! != HingeLossParameter.Norm.l1) || (other.norm != nil && other.norm! != HingeLossParameter.Norm.l1)) && (norm == nil || other.norm == nil || norm! != other.norm!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct ImageDataParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ImageDataParameter"}
  public var protoMessageName: String {return "ImageDataParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "source": 1,
    "batchSize": 4,
    "randSkip": 7,
    "shuffle": 8,
    "newHeight": 9,
    "newWidth": 10,
    "isColor": 11,
    "scale": 2,
    "meanFile": 3,
    "cropSize": 5,
    "mirror": 6,
    "rootFolder": 12,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "source": 1,
    "batch_size": 4,
    "rand_skip": 7,
    "shuffle": 8,
    "new_height": 9,
    "new_width": 10,
    "is_color": 11,
    "scale": 2,
    "mean_file": 3,
    "crop_size": 5,
    "mirror": 6,
    "root_folder": 12,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Specify the data source.
  public var source: String? = nil

  ///   Specify the batch size.
  private var _batchSize: UInt32? = nil
  public var batchSize: UInt32? {
    get {return _batchSize ?? 1}
    set {_batchSize = newValue}
  }

  ///   The rand_skip variable is for the data layer to skip a few data points
  ///   to avoid all asynchronous sgd clients to start at the same point. The skip
  ///   point would be set as rand_skip * rand(0,1). Note that rand_skip should not
  ///   be larger than the number of keys in the database.
  private var _randSkip: UInt32? = nil
  public var randSkip: UInt32? {
    get {return _randSkip ?? 0}
    set {_randSkip = newValue}
  }

  ///   Whether or not ImageLayer should shuffle the list of files at every epoch.
  private var _shuffle: Bool? = nil
  public var shuffle: Bool? {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }

  ///   It will also resize images if new_height or new_width are not zero.
  private var _newHeight: UInt32? = nil
  public var newHeight: UInt32? {
    get {return _newHeight ?? 0}
    set {_newHeight = newValue}
  }

  private var _newWidth: UInt32? = nil
  public var newWidth: UInt32? {
    get {return _newWidth ?? 0}
    set {_newWidth = newValue}
  }

  ///   Specify if the images are color or gray
  private var _isColor: Bool? = nil
  public var isColor: Bool? {
    get {return _isColor ?? true}
    set {_isColor = newValue}
  }

  ///   DEPRECATED. See TransformationParameter. For data pre-processing, we can do
  ///   simple scaling and subtracting the data mean, if provided. Note that the
  ///   mean subtraction is always carried out before scaling.
  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  public var meanFile: String? = nil

  ///   DEPRECATED. See TransformationParameter. Specify if we would like to randomly
  ///   crop an image.
  private var _cropSize: UInt32? = nil
  public var cropSize: UInt32? {
    get {return _cropSize ?? 0}
    set {_cropSize = newValue}
  }

  ///   DEPRECATED. See TransformationParameter. Specify if we want to randomly mirror
  ///   data.
  private var _mirror: Bool? = nil
  public var mirror: Bool? {
    get {return _mirror ?? false}
    set {_mirror = newValue}
  }

  private var _rootFolder: String? = nil
  public var rootFolder: String? {
    get {return _rootFolder ?? ""}
    set {_rootFolder = newValue}
  }

  public init() {}

  public init(source: String? = nil,
    batchSize: UInt32? = nil,
    randSkip: UInt32? = nil,
    shuffle: Bool? = nil,
    newHeight: UInt32? = nil,
    newWidth: UInt32? = nil,
    isColor: Bool? = nil,
    scale: Float? = nil,
    meanFile: String? = nil,
    cropSize: UInt32? = nil,
    mirror: Bool? = nil,
    rootFolder: String? = nil)
  {
    self.source = source
    self.batchSize = batchSize
    self.randSkip = randSkip
    self.shuffle = shuffle
    self.newHeight = newHeight
    self.newWidth = newWidth
    self.isColor = isColor
    self.scale = scale
    self.meanFile = meanFile
    self.cropSize = cropSize
    self.mirror = mirror
    self.rootFolder = rootFolder
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &source)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &batchSize)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &randSkip)
    case 8: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &shuffle)
    case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &newHeight)
    case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &newWidth)
    case 11: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &isColor)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &meanFile)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &cropSize)
    case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &mirror)
    case 12: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &rootFolder)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = source {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "source", jsonFieldName: "source", swiftFieldName: "source")
    }
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = meanFile {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 3, protoFieldName: "mean_file", jsonFieldName: "meanFile", swiftFieldName: "meanFile")
    }
    if let v = batchSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "batch_size", jsonFieldName: "batchSize", swiftFieldName: "batchSize")
    }
    if let v = cropSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "crop_size", jsonFieldName: "cropSize", swiftFieldName: "cropSize")
    }
    if let v = mirror {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 6, protoFieldName: "mirror", jsonFieldName: "mirror", swiftFieldName: "mirror")
    }
    if let v = randSkip {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 7, protoFieldName: "rand_skip", jsonFieldName: "randSkip", swiftFieldName: "randSkip")
    }
    if let v = shuffle {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 8, protoFieldName: "shuffle", jsonFieldName: "shuffle", swiftFieldName: "shuffle")
    }
    if let v = newHeight {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 9, protoFieldName: "new_height", jsonFieldName: "newHeight", swiftFieldName: "newHeight")
    }
    if let v = newWidth {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 10, protoFieldName: "new_width", jsonFieldName: "newWidth", swiftFieldName: "newWidth")
    }
    if let v = isColor {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 11, protoFieldName: "is_color", jsonFieldName: "isColor", swiftFieldName: "isColor")
    }
    if let v = rootFolder {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 12, protoFieldName: "root_folder", jsonFieldName: "rootFolder", swiftFieldName: "rootFolder")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ImageDataParameter) -> Bool {
    if ((source != nil || other.source != nil) && (source == nil || other.source == nil || source! != other.source!)) {return false}
    if (((batchSize != nil && batchSize! != 1) || (other.batchSize != nil && other.batchSize! != 1)) && (batchSize == nil || other.batchSize == nil || batchSize! != other.batchSize!)) {return false}
    if (((randSkip != nil && randSkip! != 0) || (other.randSkip != nil && other.randSkip! != 0)) && (randSkip == nil || other.randSkip == nil || randSkip! != other.randSkip!)) {return false}
    if (((shuffle != nil && shuffle! != false) || (other.shuffle != nil && other.shuffle! != false)) && (shuffle == nil || other.shuffle == nil || shuffle! != other.shuffle!)) {return false}
    if (((newHeight != nil && newHeight! != 0) || (other.newHeight != nil && other.newHeight! != 0)) && (newHeight == nil || other.newHeight == nil || newHeight! != other.newHeight!)) {return false}
    if (((newWidth != nil && newWidth! != 0) || (other.newWidth != nil && other.newWidth! != 0)) && (newWidth == nil || other.newWidth == nil || newWidth! != other.newWidth!)) {return false}
    if (((isColor != nil && isColor! != true) || (other.isColor != nil && other.isColor! != true)) && (isColor == nil || other.isColor == nil || isColor! != other.isColor!)) {return false}
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if ((meanFile != nil || other.meanFile != nil) && (meanFile == nil || other.meanFile == nil || meanFile! != other.meanFile!)) {return false}
    if (((cropSize != nil && cropSize! != 0) || (other.cropSize != nil && other.cropSize! != 0)) && (cropSize == nil || other.cropSize == nil || cropSize! != other.cropSize!)) {return false}
    if (((mirror != nil && mirror! != false) || (other.mirror != nil && other.mirror! != false)) && (mirror == nil || other.mirror == nil || mirror! != other.mirror!)) {return false}
    if (((rootFolder != nil && rootFolder! != "") || (other.rootFolder != nil && other.rootFolder! != "")) && (rootFolder == nil || other.rootFolder == nil || rootFolder! != other.rootFolder!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct InfogainLossParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "InfogainLossParameter"}
  public var protoMessageName: String {return "InfogainLossParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "source": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "source": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Specify the infogain matrix source.
  public var source: String? = nil

  public init() {}

  public init(source: String? = nil)
  {
    self.source = source
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &source)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = source {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "source", jsonFieldName: "source", swiftFieldName: "source")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: InfogainLossParameter) -> Bool {
    if ((source != nil || other.source != nil) && (source == nil || other.source == nil || source! != other.source!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct InnerProductParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "InnerProductParameter"}
  public var protoMessageName: String {return "InnerProductParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "numOutput": 1,
    "biasTerm": 2,
    "weightFiller": 3,
    "biasFiller": 4,
    "axis": 5,
    "transpose": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "num_output": 1,
    "bias_term": 2,
    "weight_filler": 3,
    "bias_filler": 4,
    "axis": 5,
    "transpose": 6,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = InnerProductParameter
    var unknown = ProtobufUnknownStorage()
    var _numOutput: UInt32? = nil
    var _biasTerm: Bool? = nil
    var _weightFiller: FillerParameter? = nil
    var _biasFiller: FillerParameter? = nil
    var _axis: Int32? = nil
    var _transpose: Bool? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_numOutput)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_biasTerm)
      case 3: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_weightFiller)
      case 4: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_biasFiller)
      case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_axis)
      case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_transpose)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _numOutput {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "num_output", jsonFieldName: "numOutput", swiftFieldName: "numOutput")
      }
      if let v = _biasTerm {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "bias_term", jsonFieldName: "biasTerm", swiftFieldName: "biasTerm")
      }
      if let v = _weightFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "weight_filler", jsonFieldName: "weightFiller", swiftFieldName: "weightFiller")
      }
      if let v = _biasFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 4, protoFieldName: "bias_filler", jsonFieldName: "biasFiller", swiftFieldName: "biasFiller")
      }
      if let v = _axis {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
      }
      if let v = _transpose {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 6, protoFieldName: "transpose", jsonFieldName: "transpose", swiftFieldName: "transpose")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_numOutput != nil || other._numOutput != nil) && (_numOutput == nil || other._numOutput == nil || _numOutput! != other._numOutput!)) {return false}
      if (((_biasTerm != nil && _biasTerm! != true) || (other._biasTerm != nil && other._biasTerm! != true)) && (_biasTerm == nil || other._biasTerm == nil || _biasTerm! != other._biasTerm!)) {return false}
      if ((_weightFiller != nil || other._weightFiller != nil) && (_weightFiller == nil || other._weightFiller == nil || _weightFiller! != other._weightFiller!)) {return false}
      if ((_biasFiller != nil || other._biasFiller != nil) && (_biasFiller == nil || other._biasFiller == nil || _biasFiller! != other._biasFiller!)) {return false}
      if (((_axis != nil && _axis! != 1) || (other._axis != nil && other._axis! != 1)) && (_axis == nil || other._axis == nil || _axis! != other._axis!)) {return false}
      if (((_transpose != nil && _transpose! != false) || (other._transpose != nil && other._transpose! != false)) && (_transpose == nil || other._transpose == nil || _transpose! != other._transpose!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._numOutput = _numOutput
      clone._biasTerm = _biasTerm
      clone._weightFiller = _weightFiller
      clone._biasFiller = _biasFiller
      clone._axis = _axis
      clone._transpose = _transpose
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The number of outputs for the layer
  public var numOutput: UInt32? {
    get {return _storage._numOutput}
    set {_uniqueStorage()._numOutput = newValue}
  }

  ///   whether to have bias terms
  public var biasTerm: Bool? {
    get {return _storage._biasTerm ?? true}
    set {_uniqueStorage()._biasTerm = newValue}
  }

  ///   The filler for the weight
  public var weightFiller: FillerParameter? {
    get {return _storage._weightFiller}
    set {_uniqueStorage()._weightFiller = newValue}
  }

  ///   The filler for the bias
  public var biasFiller: FillerParameter? {
    get {return _storage._biasFiller}
    set {_uniqueStorage()._biasFiller = newValue}
  }

  ///   The first axis to be lumped into a single inner product computation;
  ///   all preceding axes are retained in the output.
  ///   May be negative to index from the end (e.g., -1 for the last axis).
  public var axis: Int32? {
    get {return _storage._axis ?? 1}
    set {_uniqueStorage()._axis = newValue}
  }

  ///   Specify whether to transpose the weight matrix or not.
  ///   If transpose == true, any operations will be performed on the transpose
  ///   of the weight matrix. The weight matrix itself is not going to be transposed
  ///   but rather the transfer flag of operations will be toggled accordingly.
  public var transpose: Bool? {
    get {return _storage._transpose ?? false}
    set {_uniqueStorage()._transpose = newValue}
  }

  public init() {}

  public init(numOutput: UInt32? = nil,
    biasTerm: Bool? = nil,
    weightFiller: FillerParameter? = nil,
    biasFiller: FillerParameter? = nil,
    axis: Int32? = nil,
    transpose: Bool? = nil)
  {
    let storage = _uniqueStorage()
    storage._numOutput = numOutput
    storage._biasTerm = biasTerm
    storage._weightFiller = weightFiller
    storage._biasFiller = biasFiller
    storage._axis = axis
    storage._transpose = transpose
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: InnerProductParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public struct InputParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "InputParameter"}
  public var protoMessageName: String {return "InputParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "shape": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "shape": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   This layer produces N >= 1 top blob(s) to be assigned manually.
  ///   Define N shapes to set a shape for each top.
  ///   Define 1 shape to set the same shape for every top.
  ///   Define no shape to defer to reshaping manually.
  public var shape: [BlobShape] = []

  public init() {}

  public init(shape: [BlobShape] = [])
  {
    if !shape.isEmpty {
      self.shape = shape
    }
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeRepeatedMessageField(fieldType: BlobShape.self, value: &shape)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if !shape.isEmpty {
      try visitor.visitRepeatedMessageField(value: shape, protoFieldNumber: 1, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: InputParameter) -> Bool {
    if shape != other.shape {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by LogLayer
public struct LogParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "LogParameter"}
  public var protoMessageName: String {return "LogParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "base": 1,
    "scale": 2,
    "shift": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "base": 1,
    "scale": 2,
    "shift": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   LogLayer computes outputs y = log_base(shift + scale * x), for base > 0.
  ///   Or if base is set to the default (-1), base is set to e,
  ///   so y = ln(shift + scale * x) = log_e(shift + scale * x)
  private var _base: Float? = nil
  public var base: Float? {
    get {return _base ?? -1}
    set {_base = newValue}
  }

  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  private var _shift: Float? = nil
  public var shift: Float? {
    get {return _shift ?? 0}
    set {_shift = newValue}
  }

  public init() {}

  public init(base: Float? = nil,
    scale: Float? = nil,
    shift: Float? = nil)
  {
    self.base = base
    self.scale = scale
    self.shift = shift
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &base)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &shift)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = base {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "base", jsonFieldName: "base", swiftFieldName: "base")
    }
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = shift {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "shift", jsonFieldName: "shift", swiftFieldName: "shift")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: LogParameter) -> Bool {
    if (((base != nil && base! != -1) || (other.base != nil && other.base! != -1)) && (base == nil || other.base == nil || base! != other.base!)) {return false}
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if (((shift != nil && shift! != 0) || (other.shift != nil && other.shift! != 0)) && (shift == nil || other.shift == nil || shift! != other.shift!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by LRNLayer
public struct LRNParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "LRNParameter"}
  public var protoMessageName: String {return "LRNParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "localSize": 1,
    "alpha": 2,
    "beta": 3,
    "normRegion": 4,
    "k": 5,
    "engine": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "local_size": 1,
    "alpha": 2,
    "beta": 3,
    "norm_region": 4,
    "k": 5,
    "engine": 6,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum NormRegion: ProtobufEnum {
    public typealias RawValue = Int
    case acrossChannels // = 0
    case withinChannel // = 1

    public init() {
      self = .acrossChannels
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .acrossChannels
      case 1: self = .withinChannel
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "acrossChannels": self = .acrossChannels
      case "withinChannel": self = .withinChannel
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "ACROSS_CHANNELS": self = .acrossChannels
      case "WITHIN_CHANNEL": self = .withinChannel
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "ACROSS_CHANNELS": self = .acrossChannels
      case "WITHIN_CHANNEL": self = .withinChannel
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .acrossChannels: return 0
        case .withinChannel: return 1
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .acrossChannels: return "\"ACROSS_CHANNELS\""
        case .withinChannel: return "\"WITHIN_CHANNEL\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .acrossChannels: return ".acrossChannels"
        case .withinChannel: return ".withinChannel"
        }
      }
    }

  }

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  private var _localSize: UInt32? = nil
  public var localSize: UInt32? {
    get {return _localSize ?? 5}
    set {_localSize = newValue}
  }

  private var _alpha: Float? = nil
  public var alpha: Float? {
    get {return _alpha ?? 1}
    set {_alpha = newValue}
  }

  private var _beta: Float? = nil
  public var beta: Float? {
    get {return _beta ?? 0.75}
    set {_beta = newValue}
  }

  private var _normRegion: LRNParameter.NormRegion? = nil
  public var normRegion: LRNParameter.NormRegion? {
    get {return _normRegion ?? LRNParameter.NormRegion.acrossChannels}
    set {_normRegion = newValue}
  }

  private var _k: Float? = nil
  public var k: Float? {
    get {return _k ?? 1}
    set {_k = newValue}
  }

  private var _engine: LRNParameter.Engine? = nil
  public var engine: LRNParameter.Engine? {
    get {return _engine ?? LRNParameter.Engine.`default`}
    set {_engine = newValue}
  }

  public init() {}

  public init(localSize: UInt32? = nil,
    alpha: Float? = nil,
    beta: Float? = nil,
    normRegion: LRNParameter.NormRegion? = nil,
    k: Float? = nil,
    engine: LRNParameter.Engine? = nil)
  {
    self.localSize = localSize
    self.alpha = alpha
    self.beta = beta
    self.normRegion = normRegion
    self.k = k
    self.engine = engine
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &localSize)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &alpha)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &beta)
    case 4: handled = try setter.decodeOptionalField(fieldType: LRNParameter.NormRegion.self, value: &normRegion)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &k)
    case 6: handled = try setter.decodeOptionalField(fieldType: LRNParameter.Engine.self, value: &engine)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = localSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "local_size", jsonFieldName: "localSize", swiftFieldName: "localSize")
    }
    if let v = alpha {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "alpha", jsonFieldName: "alpha", swiftFieldName: "alpha")
    }
    if let v = beta {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "beta", jsonFieldName: "beta", swiftFieldName: "beta")
    }
    if let v = normRegion {
      try visitor.visitSingularField(fieldType: LRNParameter.NormRegion.self, value: v, protoFieldNumber: 4, protoFieldName: "norm_region", jsonFieldName: "normRegion", swiftFieldName: "normRegion")
    }
    if let v = k {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 5, protoFieldName: "k", jsonFieldName: "k", swiftFieldName: "k")
    }
    if let v = engine {
      try visitor.visitSingularField(fieldType: LRNParameter.Engine.self, value: v, protoFieldNumber: 6, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: LRNParameter) -> Bool {
    if (((localSize != nil && localSize! != 5) || (other.localSize != nil && other.localSize! != 5)) && (localSize == nil || other.localSize == nil || localSize! != other.localSize!)) {return false}
    if (((alpha != nil && alpha! != 1) || (other.alpha != nil && other.alpha! != 1)) && (alpha == nil || other.alpha == nil || alpha! != other.alpha!)) {return false}
    if (((beta != nil && beta! != 0.75) || (other.beta != nil && other.beta! != 0.75)) && (beta == nil || other.beta == nil || beta! != other.beta!)) {return false}
    if (((normRegion != nil && normRegion! != LRNParameter.NormRegion.acrossChannels) || (other.normRegion != nil && other.normRegion! != LRNParameter.NormRegion.acrossChannels)) && (normRegion == nil || other.normRegion == nil || normRegion! != other.normRegion!)) {return false}
    if (((k != nil && k! != 1) || (other.k != nil && other.k! != 1)) && (k == nil || other.k == nil || k! != other.k!)) {return false}
    if (((engine != nil && engine! != LRNParameter.Engine.`default`) || (other.engine != nil && other.engine! != LRNParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct MemoryDataParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "MemoryDataParameter"}
  public var protoMessageName: String {return "MemoryDataParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "batchSize": 1,
    "channels": 2,
    "height": 3,
    "width": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "batch_size": 1,
    "channels": 2,
    "height": 3,
    "width": 4,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var batchSize: UInt32? = nil

  public var channels: UInt32? = nil

  public var height: UInt32? = nil

  public var width: UInt32? = nil

  public init() {}

  public init(batchSize: UInt32? = nil,
    channels: UInt32? = nil,
    height: UInt32? = nil,
    width: UInt32? = nil)
  {
    self.batchSize = batchSize
    self.channels = channels
    self.height = height
    self.width = width
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &batchSize)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &channels)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &height)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &width)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = batchSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "batch_size", jsonFieldName: "batchSize", swiftFieldName: "batchSize")
    }
    if let v = channels {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "channels", jsonFieldName: "channels", swiftFieldName: "channels")
    }
    if let v = height {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "height", jsonFieldName: "height", swiftFieldName: "height")
    }
    if let v = width {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "width", jsonFieldName: "width", swiftFieldName: "width")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: MemoryDataParameter) -> Bool {
    if ((batchSize != nil || other.batchSize != nil) && (batchSize == nil || other.batchSize == nil || batchSize! != other.batchSize!)) {return false}
    if ((channels != nil || other.channels != nil) && (channels == nil || other.channels == nil || channels! != other.channels!)) {return false}
    if ((height != nil || other.height != nil) && (height == nil || other.height == nil || height! != other.height!)) {return false}
    if ((width != nil || other.width != nil) && (width == nil || other.width == nil || width! != other.width!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct MVNParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "MVNParameter"}
  public var protoMessageName: String {return "MVNParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "normalizeVariance": 1,
    "acrossChannels": 2,
    "eps": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "normalize_variance": 1,
    "across_channels": 2,
    "eps": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   This parameter can be set to false to normalize mean only
  private var _normalizeVariance: Bool? = nil
  public var normalizeVariance: Bool? {
    get {return _normalizeVariance ?? true}
    set {_normalizeVariance = newValue}
  }

  ///   This parameter can be set to true to perform DNN-like MVN
  private var _acrossChannels: Bool? = nil
  public var acrossChannels: Bool? {
    get {return _acrossChannels ?? false}
    set {_acrossChannels = newValue}
  }

  ///   Epsilon for not dividing by zero while normalizing variance
  private var _eps: Float? = nil
  public var eps: Float? {
    get {return _eps ?? 1e-09}
    set {_eps = newValue}
  }

  public init() {}

  public init(normalizeVariance: Bool? = nil,
    acrossChannels: Bool? = nil,
    eps: Float? = nil)
  {
    self.normalizeVariance = normalizeVariance
    self.acrossChannels = acrossChannels
    self.eps = eps
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &normalizeVariance)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &acrossChannels)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &eps)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = normalizeVariance {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 1, protoFieldName: "normalize_variance", jsonFieldName: "normalizeVariance", swiftFieldName: "normalizeVariance")
    }
    if let v = acrossChannels {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "across_channels", jsonFieldName: "acrossChannels", swiftFieldName: "acrossChannels")
    }
    if let v = eps {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "eps", jsonFieldName: "eps", swiftFieldName: "eps")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: MVNParameter) -> Bool {
    if (((normalizeVariance != nil && normalizeVariance! != true) || (other.normalizeVariance != nil && other.normalizeVariance! != true)) && (normalizeVariance == nil || other.normalizeVariance == nil || normalizeVariance! != other.normalizeVariance!)) {return false}
    if (((acrossChannels != nil && acrossChannels! != false) || (other.acrossChannels != nil && other.acrossChannels! != false)) && (acrossChannels == nil || other.acrossChannels == nil || acrossChannels! != other.acrossChannels!)) {return false}
    if (((eps != nil && eps! != 1e-09) || (other.eps != nil && other.eps! != 1e-09)) && (eps == nil || other.eps == nil || eps! != other.eps!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct ParameterParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ParameterParameter"}
  public var protoMessageName: String {return "ParameterParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "shape": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "shape": 1,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = ParameterParameter
    var unknown = ProtobufUnknownStorage()
    var _shape: BlobShape? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalMessageField(fieldType: BlobShape.self, value: &_shape)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_shape != nil || other._shape != nil) && (_shape == nil || other._shape == nil || _shape! != other._shape!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._shape = _shape
      return clone
    }
  }

  private var _storage = _StorageClass()

  public var shape: BlobShape? {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  public init() {}

  public init(shape: BlobShape? = nil)
  {
    let storage = _uniqueStorage()
    storage._shape = shape
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ParameterParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public struct PoolingParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "PoolingParameter"}
  public var protoMessageName: String {return "PoolingParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "pool": 1,
    "pad": 4,
    "padH": 9,
    "padW": 10,
    "kernelSize": 2,
    "kernelH": 5,
    "kernelW": 6,
    "stride": 3,
    "strideH": 7,
    "strideW": 8,
    "engine": 11,
    "globalPooling": 12,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "pool": 1,
    "pad": 4,
    "pad_h": 9,
    "pad_w": 10,
    "kernel_size": 2,
    "kernel_h": 5,
    "kernel_w": 6,
    "stride": 3,
    "stride_h": 7,
    "stride_w": 8,
    "engine": 11,
    "global_pooling": 12,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum PoolMethod: ProtobufEnum {
    public typealias RawValue = Int
    case max // = 0
    case ave // = 1
    case stochastic // = 2

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .ave
      case 2: self = .stochastic
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "max": self = .max
      case "ave": self = .ave
      case "stochastic": self = .stochastic
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "MAX": self = .max
      case "AVE": self = .ave
      case "STOCHASTIC": self = .stochastic
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "MAX": self = .max
      case "AVE": self = .ave
      case "STOCHASTIC": self = .stochastic
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .max: return 0
        case .ave: return 1
        case .stochastic: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .max: return "\"MAX\""
        case .ave: return "\"AVE\""
        case .stochastic: return "\"STOCHASTIC\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .max: return ".max"
        case .ave: return ".ave"
        case .stochastic: return ".stochastic"
        }
      }
    }

  }

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  ///   The pooling method
  private var _pool: PoolingParameter.PoolMethod? = nil
  public var pool: PoolingParameter.PoolMethod? {
    get {return _pool ?? PoolingParameter.PoolMethod.max}
    set {_pool = newValue}
  }

  ///   Pad, kernel size, and stride are all given as a single value for equal
  ///   dimensions in height and width or as Y, X pairs.
  private var _pad: UInt32? = nil
  public var pad: UInt32? {
    get {return _pad ?? 0}
    set {_pad = newValue}
  }

  ///   The padding height
  private var _padH: UInt32? = nil
  public var padH: UInt32? {
    get {return _padH ?? 0}
    set {_padH = newValue}
  }

  ///   The padding width
  private var _padW: UInt32? = nil
  public var padW: UInt32? {
    get {return _padW ?? 0}
    set {_padW = newValue}
  }

  ///   The kernel size (square)
  public var kernelSize: UInt32? = nil

  ///   The kernel height
  public var kernelH: UInt32? = nil

  ///   The kernel width
  public var kernelW: UInt32? = nil

  ///   The stride (equal in Y, X)
  private var _stride: UInt32? = nil
  public var stride: UInt32? {
    get {return _stride ?? 1}
    set {_stride = newValue}
  }

  ///   The stride height
  public var strideH: UInt32? = nil

  ///   The stride width
  public var strideW: UInt32? = nil

  private var _engine: PoolingParameter.Engine? = nil
  public var engine: PoolingParameter.Engine? {
    get {return _engine ?? PoolingParameter.Engine.`default`}
    set {_engine = newValue}
  }

  ///   If global_pooling then it will pool over the size of the bottom by doing
  ///   kernel_h = bottom->height and kernel_w = bottom->width
  private var _globalPooling: Bool? = nil
  public var globalPooling: Bool? {
    get {return _globalPooling ?? false}
    set {_globalPooling = newValue}
  }

  public init() {}

  public init(pool: PoolingParameter.PoolMethod? = nil,
    pad: UInt32? = nil,
    padH: UInt32? = nil,
    padW: UInt32? = nil,
    kernelSize: UInt32? = nil,
    kernelH: UInt32? = nil,
    kernelW: UInt32? = nil,
    stride: UInt32? = nil,
    strideH: UInt32? = nil,
    strideW: UInt32? = nil,
    engine: PoolingParameter.Engine? = nil,
    globalPooling: Bool? = nil)
  {
    self.pool = pool
    self.pad = pad
    self.padH = padH
    self.padW = padW
    self.kernelSize = kernelSize
    self.kernelH = kernelH
    self.kernelW = kernelW
    self.stride = stride
    self.strideH = strideH
    self.strideW = strideW
    self.engine = engine
    self.globalPooling = globalPooling
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: PoolingParameter.PoolMethod.self, value: &pool)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &pad)
    case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &padH)
    case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &padW)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &kernelSize)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &kernelH)
    case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &kernelW)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &stride)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &strideH)
    case 8: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &strideW)
    case 11: handled = try setter.decodeOptionalField(fieldType: PoolingParameter.Engine.self, value: &engine)
    case 12: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &globalPooling)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = pool {
      try visitor.visitSingularField(fieldType: PoolingParameter.PoolMethod.self, value: v, protoFieldNumber: 1, protoFieldName: "pool", jsonFieldName: "pool", swiftFieldName: "pool")
    }
    if let v = kernelSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "kernel_size", jsonFieldName: "kernelSize", swiftFieldName: "kernelSize")
    }
    if let v = stride {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "stride", jsonFieldName: "stride", swiftFieldName: "stride")
    }
    if let v = pad {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "pad", jsonFieldName: "pad", swiftFieldName: "pad")
    }
    if let v = kernelH {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "kernel_h", jsonFieldName: "kernelH", swiftFieldName: "kernelH")
    }
    if let v = kernelW {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 6, protoFieldName: "kernel_w", jsonFieldName: "kernelW", swiftFieldName: "kernelW")
    }
    if let v = strideH {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 7, protoFieldName: "stride_h", jsonFieldName: "strideH", swiftFieldName: "strideH")
    }
    if let v = strideW {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 8, protoFieldName: "stride_w", jsonFieldName: "strideW", swiftFieldName: "strideW")
    }
    if let v = padH {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 9, protoFieldName: "pad_h", jsonFieldName: "padH", swiftFieldName: "padH")
    }
    if let v = padW {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 10, protoFieldName: "pad_w", jsonFieldName: "padW", swiftFieldName: "padW")
    }
    if let v = engine {
      try visitor.visitSingularField(fieldType: PoolingParameter.Engine.self, value: v, protoFieldNumber: 11, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    if let v = globalPooling {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 12, protoFieldName: "global_pooling", jsonFieldName: "globalPooling", swiftFieldName: "globalPooling")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: PoolingParameter) -> Bool {
    if (((pool != nil && pool! != PoolingParameter.PoolMethod.max) || (other.pool != nil && other.pool! != PoolingParameter.PoolMethod.max)) && (pool == nil || other.pool == nil || pool! != other.pool!)) {return false}
    if (((pad != nil && pad! != 0) || (other.pad != nil && other.pad! != 0)) && (pad == nil || other.pad == nil || pad! != other.pad!)) {return false}
    if (((padH != nil && padH! != 0) || (other.padH != nil && other.padH! != 0)) && (padH == nil || other.padH == nil || padH! != other.padH!)) {return false}
    if (((padW != nil && padW! != 0) || (other.padW != nil && other.padW! != 0)) && (padW == nil || other.padW == nil || padW! != other.padW!)) {return false}
    if ((kernelSize != nil || other.kernelSize != nil) && (kernelSize == nil || other.kernelSize == nil || kernelSize! != other.kernelSize!)) {return false}
    if ((kernelH != nil || other.kernelH != nil) && (kernelH == nil || other.kernelH == nil || kernelH! != other.kernelH!)) {return false}
    if ((kernelW != nil || other.kernelW != nil) && (kernelW == nil || other.kernelW == nil || kernelW! != other.kernelW!)) {return false}
    if (((stride != nil && stride! != 1) || (other.stride != nil && other.stride! != 1)) && (stride == nil || other.stride == nil || stride! != other.stride!)) {return false}
    if ((strideH != nil || other.strideH != nil) && (strideH == nil || other.strideH == nil || strideH! != other.strideH!)) {return false}
    if ((strideW != nil || other.strideW != nil) && (strideW == nil || other.strideW == nil || strideW! != other.strideW!)) {return false}
    if (((engine != nil && engine! != PoolingParameter.Engine.`default`) || (other.engine != nil && other.engine! != PoolingParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if (((globalPooling != nil && globalPooling! != false) || (other.globalPooling != nil && other.globalPooling! != false)) && (globalPooling == nil || other.globalPooling == nil || globalPooling! != other.globalPooling!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct PowerParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "PowerParameter"}
  public var protoMessageName: String {return "PowerParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "power": 1,
    "scale": 2,
    "shift": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "power": 1,
    "scale": 2,
    "shift": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   PowerLayer computes outputs y = (shift + scale * x) ^ power.
  private var _power: Float? = nil
  public var power: Float? {
    get {return _power ?? 1}
    set {_power = newValue}
  }

  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  private var _shift: Float? = nil
  public var shift: Float? {
    get {return _shift ?? 0}
    set {_shift = newValue}
  }

  public init() {}

  public init(power: Float? = nil,
    scale: Float? = nil,
    shift: Float? = nil)
  {
    self.power = power
    self.scale = scale
    self.shift = shift
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &power)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &shift)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = power {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "power", jsonFieldName: "power", swiftFieldName: "power")
    }
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = shift {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "shift", jsonFieldName: "shift", swiftFieldName: "shift")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: PowerParameter) -> Bool {
    if (((power != nil && power! != 1) || (other.power != nil && other.power! != 1)) && (power == nil || other.power == nil || power! != other.power!)) {return false}
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if (((shift != nil && shift! != 0) || (other.shift != nil && other.shift! != 0)) && (shift == nil || other.shift == nil || shift! != other.shift!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct PythonParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "PythonParameter"}
  public var protoMessageName: String {return "PythonParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "module": 1,
    "layer": 2,
    "paramStr": 3,
    "shareInParallel": 4,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "module": 1,
    "layer": 2,
    "param_str": 3,
    "share_in_parallel": 4,
  ]}

  var unknown = ProtobufUnknownStorage()

  public var module: String? = nil

  public var layer: String? = nil

  ///   This value is set to the attribute `param_str` of the `PythonLayer` object
  ///   in Python before calling the `setup()` method. This could be a number,
  ///   string, dictionary in Python dict format, JSON, etc. You may parse this
  ///   string in `setup` method and use it in `forward` and `backward`.
  private var _paramStr: String? = nil
  public var paramStr: String? {
    get {return _paramStr ?? ""}
    set {_paramStr = newValue}
  }

  ///   Whether this PythonLayer is shared among worker solvers during data parallelism.
  ///   If true, each worker solver sequentially run forward from this layer.
  ///   This value should be set true if you are using it as a data layer.
  private var _shareInParallel: Bool? = nil
  public var shareInParallel: Bool? {
    get {return _shareInParallel ?? false}
    set {_shareInParallel = newValue}
  }

  public init() {}

  public init(module: String? = nil,
    layer: String? = nil,
    paramStr: String? = nil,
    shareInParallel: Bool? = nil)
  {
    self.module = module
    self.layer = layer
    self.paramStr = paramStr
    self.shareInParallel = shareInParallel
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &module)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &layer)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &paramStr)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &shareInParallel)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = module {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "module", jsonFieldName: "module", swiftFieldName: "module")
    }
    if let v = layer {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 2, protoFieldName: "layer", jsonFieldName: "layer", swiftFieldName: "layer")
    }
    if let v = paramStr {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 3, protoFieldName: "param_str", jsonFieldName: "paramStr", swiftFieldName: "paramStr")
    }
    if let v = shareInParallel {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 4, protoFieldName: "share_in_parallel", jsonFieldName: "shareInParallel", swiftFieldName: "shareInParallel")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: PythonParameter) -> Bool {
    if ((module != nil || other.module != nil) && (module == nil || other.module == nil || module! != other.module!)) {return false}
    if ((layer != nil || other.layer != nil) && (layer == nil || other.layer == nil || layer! != other.layer!)) {return false}
    if (((paramStr != nil && paramStr! != "") || (other.paramStr != nil && other.paramStr! != "")) && (paramStr == nil || other.paramStr == nil || paramStr! != other.paramStr!)) {return false}
    if (((shareInParallel != nil && shareInParallel! != false) || (other.shareInParallel != nil && other.shareInParallel! != false)) && (shareInParallel == nil || other.shareInParallel == nil || shareInParallel! != other.shareInParallel!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by RecurrentLayer
public struct RecurrentParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "RecurrentParameter"}
  public var protoMessageName: String {return "RecurrentParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "numOutput": 1,
    "weightFiller": 2,
    "biasFiller": 3,
    "debugInfo": 4,
    "exposeHidden": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "num_output": 1,
    "weight_filler": 2,
    "bias_filler": 3,
    "debug_info": 4,
    "expose_hidden": 5,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = RecurrentParameter
    var unknown = ProtobufUnknownStorage()
    var _numOutput: UInt32? = nil
    var _weightFiller: FillerParameter? = nil
    var _biasFiller: FillerParameter? = nil
    var _debugInfo: Bool? = nil
    var _exposeHidden: Bool? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_numOutput)
      case 2: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_weightFiller)
      case 3: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_biasFiller)
      case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_debugInfo)
      case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_exposeHidden)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _numOutput {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "num_output", jsonFieldName: "numOutput", swiftFieldName: "numOutput")
      }
      if let v = _weightFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 2, protoFieldName: "weight_filler", jsonFieldName: "weightFiller", swiftFieldName: "weightFiller")
      }
      if let v = _biasFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "bias_filler", jsonFieldName: "biasFiller", swiftFieldName: "biasFiller")
      }
      if let v = _debugInfo {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 4, protoFieldName: "debug_info", jsonFieldName: "debugInfo", swiftFieldName: "debugInfo")
      }
      if let v = _exposeHidden {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 5, protoFieldName: "expose_hidden", jsonFieldName: "exposeHidden", swiftFieldName: "exposeHidden")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if (((_numOutput != nil && _numOutput! != 0) || (other._numOutput != nil && other._numOutput! != 0)) && (_numOutput == nil || other._numOutput == nil || _numOutput! != other._numOutput!)) {return false}
      if ((_weightFiller != nil || other._weightFiller != nil) && (_weightFiller == nil || other._weightFiller == nil || _weightFiller! != other._weightFiller!)) {return false}
      if ((_biasFiller != nil || other._biasFiller != nil) && (_biasFiller == nil || other._biasFiller == nil || _biasFiller! != other._biasFiller!)) {return false}
      if (((_debugInfo != nil && _debugInfo! != false) || (other._debugInfo != nil && other._debugInfo! != false)) && (_debugInfo == nil || other._debugInfo == nil || _debugInfo! != other._debugInfo!)) {return false}
      if (((_exposeHidden != nil && _exposeHidden! != false) || (other._exposeHidden != nil && other._exposeHidden! != false)) && (_exposeHidden == nil || other._exposeHidden == nil || _exposeHidden! != other._exposeHidden!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._numOutput = _numOutput
      clone._weightFiller = _weightFiller
      clone._biasFiller = _biasFiller
      clone._debugInfo = _debugInfo
      clone._exposeHidden = _exposeHidden
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The dimension of the output (and usually hidden state) representation --
  ///   must be explicitly set to non-zero.
  public var numOutput: UInt32? {
    get {return _storage._numOutput ?? 0}
    set {_uniqueStorage()._numOutput = newValue}
  }

  ///   The filler for the weight
  public var weightFiller: FillerParameter? {
    get {return _storage._weightFiller}
    set {_uniqueStorage()._weightFiller = newValue}
  }

  ///   The filler for the bias
  public var biasFiller: FillerParameter? {
    get {return _storage._biasFiller}
    set {_uniqueStorage()._biasFiller = newValue}
  }

  ///   Whether to enable displaying debug_info in the unrolled recurrent net.
  public var debugInfo: Bool? {
    get {return _storage._debugInfo ?? false}
    set {_uniqueStorage()._debugInfo = newValue}
  }

  ///   Whether to add as additional inputs (bottoms) the initial hidden state
  ///   blobs, and add as additional outputs (tops) the final timestep hidden state
  ///   blobs.  The number of additional bottom/top blobs required depends on the
  ///   recurrent architecture -- e.g., 1 for RNNs, 2 for LSTMs.
  public var exposeHidden: Bool? {
    get {return _storage._exposeHidden ?? false}
    set {_uniqueStorage()._exposeHidden = newValue}
  }

  public init() {}

  public init(numOutput: UInt32? = nil,
    weightFiller: FillerParameter? = nil,
    biasFiller: FillerParameter? = nil,
    debugInfo: Bool? = nil,
    exposeHidden: Bool? = nil)
  {
    let storage = _uniqueStorage()
    storage._numOutput = numOutput
    storage._weightFiller = weightFiller
    storage._biasFiller = biasFiller
    storage._debugInfo = debugInfo
    storage._exposeHidden = exposeHidden
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: RecurrentParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Message that stores parameters used by ReductionLayer
public struct ReductionParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ReductionParameter"}
  public var protoMessageName: String {return "ReductionParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "operation": 1,
    "axis": 2,
    "coeff": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "operation": 1,
    "axis": 2,
    "coeff": 3,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum ReductionOp: ProtobufEnum {
    public typealias RawValue = Int
    case sum // = 1
    case asum // = 2
    case sumsq // = 3
    case mean // = 4

    public init() {
      self = .sum
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .sum
      case 2: self = .asum
      case 3: self = .sumsq
      case 4: self = .mean
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "sum": self = .sum
      case "asum": self = .asum
      case "sumsq": self = .sumsq
      case "mean": self = .mean
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "SUM": self = .sum
      case "ASUM": self = .asum
      case "SUMSQ": self = .sumsq
      case "MEAN": self = .mean
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "SUM": self = .sum
      case "ASUM": self = .asum
      case "SUMSQ": self = .sumsq
      case "MEAN": self = .mean
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .sum: return 1
        case .asum: return 2
        case .sumsq: return 3
        case .mean: return 4
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .sum: return "\"SUM\""
        case .asum: return "\"ASUM\""
        case .sumsq: return "\"SUMSQ\""
        case .mean: return "\"MEAN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .sum: return ".sum"
        case .asum: return ".asum"
        case .sumsq: return ".sumsq"
        case .mean: return ".mean"
        }
      }
    }

  }

  ///   reduction operation
  private var _operation: ReductionParameter.ReductionOp? = nil
  public var operation: ReductionParameter.ReductionOp? {
    get {return _operation ?? ReductionParameter.ReductionOp.sum}
    set {_operation = newValue}
  }

  ///   The first axis to reduce to a scalar -- may be negative to index from the
  ///   end (e.g., -1 for the last axis).
  ///   (Currently, only reduction along ALL "tail" axes is supported; reduction
  ///   of axis M through N, where N < num_axes - 1, is unsupported.)
  ///   Suppose we have an n-axis bottom Blob with shape:
  ///       (d0, d1, d2, ..., d(m-1), dm, d(m+1), ..., d(n-1)).
  ///   If axis == m, the output Blob will have shape
  ///       (d0, d1, d2, ..., d(m-1)),
  ///   and the ReductionOp operation is performed (d0 * d1 * d2 * ... * d(m-1))
  ///   times, each including (dm * d(m+1) * ... * d(n-1)) individual data.
  ///   If axis == 0 (the default), the output Blob always has the empty shape
  ///   (count 1), performing reduction across the entire input --
  ///   often useful for creating new loss functions.
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 0}
    set {_axis = newValue}
  }

  ///   coefficient for output
  private var _coeff: Float? = nil
  public var coeff: Float? {
    get {return _coeff ?? 1}
    set {_coeff = newValue}
  }

  public init() {}

  public init(operation: ReductionParameter.ReductionOp? = nil,
    axis: Int32? = nil,
    coeff: Float? = nil)
  {
    self.operation = operation
    self.axis = axis
    self.coeff = coeff
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ReductionParameter.ReductionOp.self, value: &operation)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &coeff)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = operation {
      try visitor.visitSingularField(fieldType: ReductionParameter.ReductionOp.self, value: v, protoFieldNumber: 1, protoFieldName: "operation", jsonFieldName: "operation", swiftFieldName: "operation")
    }
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    if let v = coeff {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 3, protoFieldName: "coeff", jsonFieldName: "coeff", swiftFieldName: "coeff")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ReductionParameter) -> Bool {
    if (((operation != nil && operation! != ReductionParameter.ReductionOp.sum) || (other.operation != nil && other.operation! != ReductionParameter.ReductionOp.sum)) && (operation == nil || other.operation == nil || operation! != other.operation!)) {return false}
    if (((axis != nil && axis! != 0) || (other.axis != nil && other.axis! != 0)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if (((coeff != nil && coeff! != 1) || (other.coeff != nil && other.coeff! != 1)) && (coeff == nil || other.coeff == nil || coeff! != other.coeff!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by ReLULayer
public struct ReLUParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ReLUParameter"}
  public var protoMessageName: String {return "ReLUParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "negativeSlope": 1,
    "engine": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "negative_slope": 1,
    "engine": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  ///   Allow non-zero slope for negative inputs to speed up optimization
  ///   Described in:
  ///   Maas, A. L., Hannun, A. Y., & Ng, A. Y. (2013). Rectifier nonlinearities
  ///   improve neural network acoustic models. In ICML Workshop on Deep Learning
  ///   for Audio, Speech, and Language Processing.
  private var _negativeSlope: Float? = nil
  public var negativeSlope: Float? {
    get {return _negativeSlope ?? 0}
    set {_negativeSlope = newValue}
  }

  private var _engine: ReLUParameter.Engine? = nil
  public var engine: ReLUParameter.Engine? {
    get {return _engine ?? ReLUParameter.Engine.`default`}
    set {_engine = newValue}
  }

  public init() {}

  public init(negativeSlope: Float? = nil,
    engine: ReLUParameter.Engine? = nil)
  {
    self.negativeSlope = negativeSlope
    self.engine = engine
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &negativeSlope)
    case 2: handled = try setter.decodeOptionalField(fieldType: ReLUParameter.Engine.self, value: &engine)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = negativeSlope {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "negative_slope", jsonFieldName: "negativeSlope", swiftFieldName: "negativeSlope")
    }
    if let v = engine {
      try visitor.visitSingularField(fieldType: ReLUParameter.Engine.self, value: v, protoFieldNumber: 2, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ReLUParameter) -> Bool {
    if (((negativeSlope != nil && negativeSlope! != 0) || (other.negativeSlope != nil && other.negativeSlope! != 0)) && (negativeSlope == nil || other.negativeSlope == nil || negativeSlope! != other.negativeSlope!)) {return false}
    if (((engine != nil && engine! != ReLUParameter.Engine.`default`) || (other.engine != nil && other.engine! != ReLUParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct ReshapeParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ReshapeParameter"}
  public var protoMessageName: String {return "ReshapeParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "shape": 1,
    "axis": 2,
    "numAxes": 3,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "shape": 1,
    "axis": 2,
    "num_axes": 3,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = ReshapeParameter
    var unknown = ProtobufUnknownStorage()
    var _shape: BlobShape? = nil
    var _axis: Int32? = nil
    var _numAxes: Int32? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalMessageField(fieldType: BlobShape.self, value: &_shape)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_axis)
      case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_numAxes)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _shape {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "shape", jsonFieldName: "shape", swiftFieldName: "shape")
      }
      if let v = _axis {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
      }
      if let v = _numAxes {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "num_axes", jsonFieldName: "numAxes", swiftFieldName: "numAxes")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_shape != nil || other._shape != nil) && (_shape == nil || other._shape == nil || _shape! != other._shape!)) {return false}
      if (((_axis != nil && _axis! != 0) || (other._axis != nil && other._axis! != 0)) && (_axis == nil || other._axis == nil || _axis! != other._axis!)) {return false}
      if (((_numAxes != nil && _numAxes! != -1) || (other._numAxes != nil && other._numAxes! != -1)) && (_numAxes == nil || other._numAxes == nil || _numAxes! != other._numAxes!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._shape = _shape
      clone._axis = _axis
      clone._numAxes = _numAxes
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Specify the output dimensions. If some of the dimensions are set to 0,
  ///   the corresponding dimension from the bottom layer is used (unchanged).
  ///   Exactly one dimension may be set to -1, in which case its value is
  ///   inferred from the count of the bottom blob and the remaining dimensions.
  ///   For example, suppose we want to reshape a 2D blob "input" with shape 2 x 8:
  ///  
  ///     layer {
  ///       type: "Reshape" bottom: "input" top: "output"
  ///       reshape_param { ... }
  ///     }
  ///  
  ///   If "input" is 2D with shape 2 x 8, then the following reshape_param
  ///   specifications are all equivalent, producing a 3D blob "output" with shape
  ///   2 x 2 x 4:
  ///  
  ///     reshape_param { shape { dim:  2  dim: 2  dim:  4 } }
  ///     reshape_param { shape { dim:  0  dim: 2  dim:  4 } }
  ///     reshape_param { shape { dim:  0  dim: 2  dim: -1 } }
  ///     reshape_param { shape { dim:  0  dim:-1  dim:  4 } }
  public var shape: BlobShape? {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  ///   axis and num_axes control the portion of the bottom blob's shape that are
  ///   replaced by (included in) the reshape. By default (axis == 0 and
  ///   num_axes == -1), the entire bottom blob shape is included in the reshape,
  ///   and hence the shape field must specify the entire output shape.
  ///  
  ///   axis may be non-zero to retain some portion of the beginning of the input
  ///   shape (and may be negative to index from the end; e.g., -1 to begin the
  ///   reshape after the last axis, including nothing in the reshape,
  ///   -2 to include only the last axis, etc.).
  ///  
  ///   For example, suppose "input" is a 2D blob with shape 2 x 8.
  ///   Then the following ReshapeLayer specifications are all equivalent,
  ///   producing a blob "output" with shape 2 x 2 x 4:
  ///  
  ///     reshape_param { shape { dim: 2  dim: 2  dim: 4 } }
  ///     reshape_param { shape { dim: 2  dim: 4 } axis:  1 }
  ///     reshape_param { shape { dim: 2  dim: 4 } axis: -3 }
  ///  
  ///   num_axes specifies the extent of the reshape.
  ///   If num_axes >= 0 (and axis >= 0), the reshape will be performed only on
  ///   input axes in the range [axis, axis+num_axes].
  ///   num_axes may also be -1, the default, to include all remaining axes
  ///   (starting from axis).
  ///  
  ///   For example, suppose "input" is a 2D blob with shape 2 x 8.
  ///   Then the following ReshapeLayer specifications are equivalent,
  ///   producing a blob "output" with shape 1 x 2 x 8.
  ///  
  ///     reshape_param { shape { dim:  1  dim: 2  dim:  8 } }
  ///     reshape_param { shape { dim:  1  dim: 2  }  num_axes: 1 }
  ///     reshape_param { shape { dim:  1  }  num_axes: 0 }
  ///  
  ///   On the other hand, these would produce output blob shape 2 x 1 x 8:
  ///  
  ///     reshape_param { shape { dim: 2  dim: 1  dim: 8  }  }
  ///     reshape_param { shape { dim: 1 }  axis: 1  num_axes: 0 }
  public var axis: Int32? {
    get {return _storage._axis ?? 0}
    set {_uniqueStorage()._axis = newValue}
  }

  public var numAxes: Int32? {
    get {return _storage._numAxes ?? -1}
    set {_uniqueStorage()._numAxes = newValue}
  }

  public init() {}

  public init(shape: BlobShape? = nil,
    axis: Int32? = nil,
    numAxes: Int32? = nil)
  {
    let storage = _uniqueStorage()
    storage._shape = shape
    storage._axis = axis
    storage._numAxes = numAxes
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ReshapeParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public struct ScaleParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ScaleParameter"}
  public var protoMessageName: String {return "ScaleParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 1,
    "numAxes": 2,
    "filler": 3,
    "biasTerm": 4,
    "biasFiller": 5,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 1,
    "num_axes": 2,
    "filler": 3,
    "bias_term": 4,
    "bias_filler": 5,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = ScaleParameter
    var unknown = ProtobufUnknownStorage()
    var _axis: Int32? = nil
    var _numAxes: Int32? = nil
    var _filler: FillerParameter? = nil
    var _biasTerm: Bool? = nil
    var _biasFiller: FillerParameter? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_axis)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_numAxes)
      case 3: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_filler)
      case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_biasTerm)
      case 5: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_biasFiller)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _axis {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
      }
      if let v = _numAxes {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "num_axes", jsonFieldName: "numAxes", swiftFieldName: "numAxes")
      }
      if let v = _filler {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 3, protoFieldName: "filler", jsonFieldName: "filler", swiftFieldName: "filler")
      }
      if let v = _biasTerm {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 4, protoFieldName: "bias_term", jsonFieldName: "biasTerm", swiftFieldName: "biasTerm")
      }
      if let v = _biasFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "bias_filler", jsonFieldName: "biasFiller", swiftFieldName: "biasFiller")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if (((_axis != nil && _axis! != 1) || (other._axis != nil && other._axis! != 1)) && (_axis == nil || other._axis == nil || _axis! != other._axis!)) {return false}
      if (((_numAxes != nil && _numAxes! != 1) || (other._numAxes != nil && other._numAxes! != 1)) && (_numAxes == nil || other._numAxes == nil || _numAxes! != other._numAxes!)) {return false}
      if ((_filler != nil || other._filler != nil) && (_filler == nil || other._filler == nil || _filler! != other._filler!)) {return false}
      if (((_biasTerm != nil && _biasTerm! != false) || (other._biasTerm != nil && other._biasTerm! != false)) && (_biasTerm == nil || other._biasTerm == nil || _biasTerm! != other._biasTerm!)) {return false}
      if ((_biasFiller != nil || other._biasFiller != nil) && (_biasFiller == nil || other._biasFiller == nil || _biasFiller! != other._biasFiller!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._axis = _axis
      clone._numAxes = _numAxes
      clone._filler = _filler
      clone._biasTerm = _biasTerm
      clone._biasFiller = _biasFiller
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   The first axis of bottom[0] (the first input Blob) along which to apply
  ///   bottom[1] (the second input Blob).  May be negative to index from the end
  ///   (e.g., -1 for the last axis).
  ///  
  ///   For example, if bottom[0] is 4D with shape 100x3x40x60, the output
  ///   top[0] will have the same shape, and bottom[1] may have any of the
  ///   following shapes (for the given value of axis):
  ///      (axis == 0 == -4) 100; 100x3; 100x3x40; 100x3x40x60
  ///      (axis == 1 == -3)          3;     3x40;     3x40x60
  ///      (axis == 2 == -2)                   40;       40x60
  ///      (axis == 3 == -1)                                60
  ///   Furthermore, bottom[1] may have the empty shape (regardless of the value of
  ///   "axis") -- a scalar multiplier.
  public var axis: Int32? {
    get {return _storage._axis ?? 1}
    set {_uniqueStorage()._axis = newValue}
  }

  ///   (num_axes is ignored unless just one bottom is given and the scale is
  ///   a learned parameter of the layer.  Otherwise, num_axes is determined by the
  ///   number of axes by the second bottom.)
  ///   The number of axes of the input (bottom[0]) covered by the scale
  ///   parameter, or -1 to cover all axes of bottom[0] starting from `axis`.
  ///   Set num_axes := 0, to multiply with a zero-axis Blob: a scalar.
  public var numAxes: Int32? {
    get {return _storage._numAxes ?? 1}
    set {_uniqueStorage()._numAxes = newValue}
  }

  ///   (filler is ignored unless just one bottom is given and the scale is
  ///   a learned parameter of the layer.)
  ///   The initialization for the learned scale parameter.
  ///   Default is the unit (1) initialization, resulting in the ScaleLayer
  ///   initially performing the identity operation.
  public var filler: FillerParameter? {
    get {return _storage._filler}
    set {_uniqueStorage()._filler = newValue}
  }

  ///   Whether to also learn a bias (equivalent to a ScaleLayer+BiasLayer, but
  ///   may be more efficient).  Initialized with bias_filler (defaults to 0).
  public var biasTerm: Bool? {
    get {return _storage._biasTerm ?? false}
    set {_uniqueStorage()._biasTerm = newValue}
  }

  public var biasFiller: FillerParameter? {
    get {return _storage._biasFiller}
    set {_uniqueStorage()._biasFiller = newValue}
  }

  public init() {}

  public init(axis: Int32? = nil,
    numAxes: Int32? = nil,
    filler: FillerParameter? = nil,
    biasTerm: Bool? = nil,
    biasFiller: FillerParameter? = nil)
  {
    let storage = _uniqueStorage()
    storage._axis = axis
    storage._numAxes = numAxes
    storage._filler = filler
    storage._biasTerm = biasTerm
    storage._biasFiller = biasFiller
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ScaleParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

public struct SigmoidParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "SigmoidParameter"}
  public var protoMessageName: String {return "SigmoidParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "engine": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "engine": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  private var _engine: SigmoidParameter.Engine? = nil
  public var engine: SigmoidParameter.Engine? {
    get {return _engine ?? SigmoidParameter.Engine.`default`}
    set {_engine = newValue}
  }

  public init() {}

  public init(engine: SigmoidParameter.Engine? = nil)
  {
    self.engine = engine
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: SigmoidParameter.Engine.self, value: &engine)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = engine {
      try visitor.visitSingularField(fieldType: SigmoidParameter.Engine.self, value: v, protoFieldNumber: 1, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: SigmoidParameter) -> Bool {
    if (((engine != nil && engine! != SigmoidParameter.Engine.`default`) || (other.engine != nil && other.engine! != SigmoidParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct SliceParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "SliceParameter"}
  public var protoMessageName: String {return "SliceParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 3,
    "slicePoint": 2,
    "sliceDim": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 3,
    "slice_point": 2,
    "slice_dim": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   The axis along which to slice -- may be negative to index from the end
  ///   (e.g., -1 for the last axis).
  ///   By default, SliceLayer concatenates blobs along the "channels" axis (1).
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 1}
    set {_axis = newValue}
  }

  public var slicePoint: [UInt32] = []

  ///   DEPRECATED: alias for "axis" -- does not support negative indexing.
  private var _sliceDim: UInt32? = nil
  public var sliceDim: UInt32? {
    get {return _sliceDim ?? 1}
    set {_sliceDim = newValue}
  }

  public init() {}

  public init(axis: Int32? = nil,
    slicePoint: [UInt32] = [],
    sliceDim: UInt32? = nil)
  {
    self.axis = axis
    if !slicePoint.isEmpty {
      self.slicePoint = slicePoint
    }
    self.sliceDim = sliceDim
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufUInt32.self, value: &slicePoint)
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &sliceDim)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = sliceDim {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "slice_dim", jsonFieldName: "sliceDim", swiftFieldName: "sliceDim")
    }
    if !slicePoint.isEmpty {
      try visitor.visitRepeatedField(fieldType: ProtobufUInt32.self, value: slicePoint, protoFieldNumber: 2, protoFieldName: "slice_point", jsonFieldName: "slicePoint", swiftFieldName: "slicePoint")
    }
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: SliceParameter) -> Bool {
    if (((axis != nil && axis! != 1) || (other.axis != nil && other.axis! != 1)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if slicePoint != other.slicePoint {return false}
    if (((sliceDim != nil && sliceDim! != 1) || (other.sliceDim != nil && other.sliceDim! != 1)) && (sliceDim == nil || other.sliceDim == nil || sliceDim! != other.sliceDim!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by SoftmaxLayer, SoftmaxWithLossLayer
public struct SoftmaxParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "SoftmaxParameter"}
  public var protoMessageName: String {return "SoftmaxParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "engine": 1,
    "axis": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "engine": 1,
    "axis": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  private var _engine: SoftmaxParameter.Engine? = nil
  public var engine: SoftmaxParameter.Engine? {
    get {return _engine ?? SoftmaxParameter.Engine.`default`}
    set {_engine = newValue}
  }

  ///   The axis along which to perform the softmax -- may be negative to index
  ///   from the end (e.g., -1 for the last axis).
  ///   Any other axes will be evaluated as independent softmaxes.
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 1}
    set {_axis = newValue}
  }

  public init() {}

  public init(engine: SoftmaxParameter.Engine? = nil,
    axis: Int32? = nil)
  {
    self.engine = engine
    self.axis = axis
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: SoftmaxParameter.Engine.self, value: &engine)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = engine {
      try visitor.visitSingularField(fieldType: SoftmaxParameter.Engine.self, value: v, protoFieldNumber: 1, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: SoftmaxParameter) -> Bool {
    if (((engine != nil && engine! != SoftmaxParameter.Engine.`default`) || (other.engine != nil && other.engine! != SoftmaxParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if (((axis != nil && axis! != 1) || (other.axis != nil && other.axis! != 1)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct TanHParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "TanHParameter"}
  public var protoMessageName: String {return "TanHParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "engine": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "engine": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  private var _engine: TanHParameter.Engine? = nil
  public var engine: TanHParameter.Engine? {
    get {return _engine ?? TanHParameter.Engine.`default`}
    set {_engine = newValue}
  }

  public init() {}

  public init(engine: TanHParameter.Engine? = nil)
  {
    self.engine = engine
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: TanHParameter.Engine.self, value: &engine)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = engine {
      try visitor.visitSingularField(fieldType: TanHParameter.Engine.self, value: v, protoFieldNumber: 1, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: TanHParameter) -> Bool {
    if (((engine != nil && engine! != TanHParameter.Engine.`default`) || (other.engine != nil && other.engine! != TanHParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by TileLayer
public struct TileParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "TileParameter"}
  public var protoMessageName: String {return "TileParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "axis": 1,
    "tiles": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "axis": 1,
    "tiles": 2,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   The index of the axis to tile.
  private var _axis: Int32? = nil
  public var axis: Int32? {
    get {return _axis ?? 1}
    set {_axis = newValue}
  }

  ///   The number of copies (tiles) of the blob to output.
  public var tiles: Int32? = nil

  public init() {}

  public init(axis: Int32? = nil,
    tiles: Int32? = nil)
  {
    self.axis = axis
    self.tiles = tiles
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &axis)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &tiles)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = axis {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "axis", jsonFieldName: "axis", swiftFieldName: "axis")
    }
    if let v = tiles {
      try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 2, protoFieldName: "tiles", jsonFieldName: "tiles", swiftFieldName: "tiles")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: TileParameter) -> Bool {
    if (((axis != nil && axis! != 1) || (other.axis != nil && other.axis! != 1)) && (axis == nil || other.axis == nil || axis! != other.axis!)) {return false}
    if ((tiles != nil || other.tiles != nil) && (tiles == nil || other.tiles == nil || tiles! != other.tiles!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   Message that stores parameters used by ThresholdLayer
public struct ThresholdParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "ThresholdParameter"}
  public var protoMessageName: String {return "ThresholdParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "threshold": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "threshold": 1,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Strictly positive values
  private var _threshold: Float? = nil
  public var threshold: Float? {
    get {return _threshold ?? 0}
    set {_threshold = newValue}
  }

  public init() {}

  public init(threshold: Float? = nil)
  {
    self.threshold = threshold
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &threshold)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = threshold {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 1, protoFieldName: "threshold", jsonFieldName: "threshold", swiftFieldName: "threshold")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: ThresholdParameter) -> Bool {
    if (((threshold != nil && threshold! != 0) || (other.threshold != nil && other.threshold! != 0)) && (threshold == nil || other.threshold == nil || threshold! != other.threshold!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct WindowDataParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "WindowDataParameter"}
  public var protoMessageName: String {return "WindowDataParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "source": 1,
    "scale": 2,
    "meanFile": 3,
    "batchSize": 4,
    "cropSize": 5,
    "mirror": 6,
    "fgThreshold": 7,
    "bgThreshold": 8,
    "fgFraction": 9,
    "contextPad": 10,
    "cropMode": 11,
    "cacheImages": 12,
    "rootFolder": 13,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "source": 1,
    "scale": 2,
    "mean_file": 3,
    "batch_size": 4,
    "crop_size": 5,
    "mirror": 6,
    "fg_threshold": 7,
    "bg_threshold": 8,
    "fg_fraction": 9,
    "context_pad": 10,
    "crop_mode": 11,
    "cache_images": 12,
    "root_folder": 13,
  ]}

  var unknown = ProtobufUnknownStorage()

  ///   Specify the data source.
  public var source: String? = nil

  ///   For data pre-processing, we can do simple scaling and subtracting the
  ///   data mean, if provided. Note that the mean subtraction is always carried
  ///   out before scaling.
  private var _scale: Float? = nil
  public var scale: Float? {
    get {return _scale ?? 1}
    set {_scale = newValue}
  }

  public var meanFile: String? = nil

  ///   Specify the batch size.
  public var batchSize: UInt32? = nil

  ///   Specify if we would like to randomly crop an image.
  private var _cropSize: UInt32? = nil
  public var cropSize: UInt32? {
    get {return _cropSize ?? 0}
    set {_cropSize = newValue}
  }

  ///   Specify if we want to randomly mirror data.
  private var _mirror: Bool? = nil
  public var mirror: Bool? {
    get {return _mirror ?? false}
    set {_mirror = newValue}
  }

  ///   Foreground (object) overlap threshold
  private var _fgThreshold: Float? = nil
  public var fgThreshold: Float? {
    get {return _fgThreshold ?? 0.5}
    set {_fgThreshold = newValue}
  }

  ///   Background (non-object) overlap threshold
  private var _bgThreshold: Float? = nil
  public var bgThreshold: Float? {
    get {return _bgThreshold ?? 0.5}
    set {_bgThreshold = newValue}
  }

  ///   Fraction of batch that should be foreground objects
  private var _fgFraction: Float? = nil
  public var fgFraction: Float? {
    get {return _fgFraction ?? 0.25}
    set {_fgFraction = newValue}
  }

  ///   Amount of contextual padding to add around a window
  ///   (used only by the window_data_layer)
  private var _contextPad: UInt32? = nil
  public var contextPad: UInt32? {
    get {return _contextPad ?? 0}
    set {_contextPad = newValue}
  }

  ///   Mode for cropping out a detection window
  ///   warp: cropped window is warped to a fixed size and aspect ratio
  ///   square: the tightest square around the window is cropped
  private var _cropMode: String? = nil
  public var cropMode: String? {
    get {return _cropMode ?? "warp"}
    set {_cropMode = newValue}
  }

  ///   cache_images: will load all images in memory for faster access
  private var _cacheImages: Bool? = nil
  public var cacheImages: Bool? {
    get {return _cacheImages ?? false}
    set {_cacheImages = newValue}
  }

  ///   append root_folder to locate images
  private var _rootFolder: String? = nil
  public var rootFolder: String? {
    get {return _rootFolder ?? ""}
    set {_rootFolder = newValue}
  }

  public init() {}

  public init(source: String? = nil,
    scale: Float? = nil,
    meanFile: String? = nil,
    batchSize: UInt32? = nil,
    cropSize: UInt32? = nil,
    mirror: Bool? = nil,
    fgThreshold: Float? = nil,
    bgThreshold: Float? = nil,
    fgFraction: Float? = nil,
    contextPad: UInt32? = nil,
    cropMode: String? = nil,
    cacheImages: Bool? = nil,
    rootFolder: String? = nil)
  {
    self.source = source
    self.scale = scale
    self.meanFile = meanFile
    self.batchSize = batchSize
    self.cropSize = cropSize
    self.mirror = mirror
    self.fgThreshold = fgThreshold
    self.bgThreshold = bgThreshold
    self.fgFraction = fgFraction
    self.contextPad = contextPad
    self.cropMode = cropMode
    self.cacheImages = cacheImages
    self.rootFolder = rootFolder
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &source)
    case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &scale)
    case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &meanFile)
    case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &batchSize)
    case 5: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &cropSize)
    case 6: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &mirror)
    case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &fgThreshold)
    case 8: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &bgThreshold)
    case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &fgFraction)
    case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &contextPad)
    case 11: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &cropMode)
    case 12: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &cacheImages)
    case 13: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &rootFolder)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = source {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "source", jsonFieldName: "source", swiftFieldName: "source")
    }
    if let v = scale {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 2, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
    }
    if let v = meanFile {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 3, protoFieldName: "mean_file", jsonFieldName: "meanFile", swiftFieldName: "meanFile")
    }
    if let v = batchSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 4, protoFieldName: "batch_size", jsonFieldName: "batchSize", swiftFieldName: "batchSize")
    }
    if let v = cropSize {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 5, protoFieldName: "crop_size", jsonFieldName: "cropSize", swiftFieldName: "cropSize")
    }
    if let v = mirror {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 6, protoFieldName: "mirror", jsonFieldName: "mirror", swiftFieldName: "mirror")
    }
    if let v = fgThreshold {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 7, protoFieldName: "fg_threshold", jsonFieldName: "fgThreshold", swiftFieldName: "fgThreshold")
    }
    if let v = bgThreshold {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 8, protoFieldName: "bg_threshold", jsonFieldName: "bgThreshold", swiftFieldName: "bgThreshold")
    }
    if let v = fgFraction {
      try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 9, protoFieldName: "fg_fraction", jsonFieldName: "fgFraction", swiftFieldName: "fgFraction")
    }
    if let v = contextPad {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 10, protoFieldName: "context_pad", jsonFieldName: "contextPad", swiftFieldName: "contextPad")
    }
    if let v = cropMode {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 11, protoFieldName: "crop_mode", jsonFieldName: "cropMode", swiftFieldName: "cropMode")
    }
    if let v = cacheImages {
      try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 12, protoFieldName: "cache_images", jsonFieldName: "cacheImages", swiftFieldName: "cacheImages")
    }
    if let v = rootFolder {
      try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 13, protoFieldName: "root_folder", jsonFieldName: "rootFolder", swiftFieldName: "rootFolder")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: WindowDataParameter) -> Bool {
    if ((source != nil || other.source != nil) && (source == nil || other.source == nil || source! != other.source!)) {return false}
    if (((scale != nil && scale! != 1) || (other.scale != nil && other.scale! != 1)) && (scale == nil || other.scale == nil || scale! != other.scale!)) {return false}
    if ((meanFile != nil || other.meanFile != nil) && (meanFile == nil || other.meanFile == nil || meanFile! != other.meanFile!)) {return false}
    if ((batchSize != nil || other.batchSize != nil) && (batchSize == nil || other.batchSize == nil || batchSize! != other.batchSize!)) {return false}
    if (((cropSize != nil && cropSize! != 0) || (other.cropSize != nil && other.cropSize! != 0)) && (cropSize == nil || other.cropSize == nil || cropSize! != other.cropSize!)) {return false}
    if (((mirror != nil && mirror! != false) || (other.mirror != nil && other.mirror! != false)) && (mirror == nil || other.mirror == nil || mirror! != other.mirror!)) {return false}
    if (((fgThreshold != nil && fgThreshold! != 0.5) || (other.fgThreshold != nil && other.fgThreshold! != 0.5)) && (fgThreshold == nil || other.fgThreshold == nil || fgThreshold! != other.fgThreshold!)) {return false}
    if (((bgThreshold != nil && bgThreshold! != 0.5) || (other.bgThreshold != nil && other.bgThreshold! != 0.5)) && (bgThreshold == nil || other.bgThreshold == nil || bgThreshold! != other.bgThreshold!)) {return false}
    if (((fgFraction != nil && fgFraction! != 0.25) || (other.fgFraction != nil && other.fgFraction! != 0.25)) && (fgFraction == nil || other.fgFraction == nil || fgFraction! != other.fgFraction!)) {return false}
    if (((contextPad != nil && contextPad! != 0) || (other.contextPad != nil && other.contextPad! != 0)) && (contextPad == nil || other.contextPad == nil || contextPad! != other.contextPad!)) {return false}
    if (((cropMode != nil && cropMode! != "warp") || (other.cropMode != nil && other.cropMode! != "warp")) && (cropMode == nil || other.cropMode == nil || cropMode! != other.cropMode!)) {return false}
    if (((cacheImages != nil && cacheImages! != false) || (other.cacheImages != nil && other.cacheImages! != false)) && (cacheImages == nil || other.cacheImages == nil || cacheImages! != other.cacheImages!)) {return false}
    if (((rootFolder != nil && rootFolder! != "") || (other.rootFolder != nil && other.rootFolder! != "")) && (rootFolder == nil || other.rootFolder == nil || rootFolder! != other.rootFolder!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

public struct SPPParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "SPPParameter"}
  public var protoMessageName: String {return "SPPParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "pyramidHeight": 1,
    "pool": 2,
    "engine": 6,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "pyramid_height": 1,
    "pool": 2,
    "engine": 6,
  ]}

  var unknown = ProtobufUnknownStorage()

  public enum PoolMethod: ProtobufEnum {
    public typealias RawValue = Int
    case max // = 0
    case ave // = 1
    case stochastic // = 2

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .ave
      case 2: self = .stochastic
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "max": self = .max
      case "ave": self = .ave
      case "stochastic": self = .stochastic
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "MAX": self = .max
      case "AVE": self = .ave
      case "STOCHASTIC": self = .stochastic
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "MAX": self = .max
      case "AVE": self = .ave
      case "STOCHASTIC": self = .stochastic
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .max: return 0
        case .ave: return 1
        case .stochastic: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .max: return "\"MAX\""
        case .ave: return "\"AVE\""
        case .stochastic: return "\"STOCHASTIC\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .max: return ".max"
        case .ave: return ".ave"
        case .stochastic: return ".stochastic"
        }
      }
    }

  }

  public enum Engine: ProtobufEnum {
    public typealias RawValue = Int
    case `default` // = 0
    case caffe // = 1
    case cudnn // = 2

    public init() {
      self = .`default`
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .`default`
      case 1: self = .caffe
      case 2: self = .cudnn
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "default": self = .`default`
      case "caffe": self = .caffe
      case "cudnn": self = .cudnn
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "DEFAULT": self = .`default`
      case "CAFFE": self = .caffe
      case "CUDNN": self = .cudnn
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .`default`: return 0
        case .caffe: return 1
        case .cudnn: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .`default`: return "\"DEFAULT\""
        case .caffe: return "\"CAFFE\""
        case .cudnn: return "\"CUDNN\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .`default`: return ".default"
        case .caffe: return ".caffe"
        case .cudnn: return ".cudnn"
        }
      }
    }

  }

  public var pyramidHeight: UInt32? = nil

  ///   The pooling method
  private var _pool: SPPParameter.PoolMethod? = nil
  public var pool: SPPParameter.PoolMethod? {
    get {return _pool ?? SPPParameter.PoolMethod.max}
    set {_pool = newValue}
  }

  private var _engine: SPPParameter.Engine? = nil
  public var engine: SPPParameter.Engine? {
    get {return _engine ?? SPPParameter.Engine.`default`}
    set {_engine = newValue}
  }

  public init() {}

  public init(pyramidHeight: UInt32? = nil,
    pool: SPPParameter.PoolMethod? = nil,
    engine: SPPParameter.Engine? = nil)
  {
    self.pyramidHeight = pyramidHeight
    self.pool = pool
    self.engine = engine
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    let handled: Bool
    switch protoFieldNumber {
    case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &pyramidHeight)
    case 2: handled = try setter.decodeOptionalField(fieldType: SPPParameter.PoolMethod.self, value: &pool)
    case 6: handled = try setter.decodeOptionalField(fieldType: SPPParameter.Engine.self, value: &engine)
    default:
      handled = false
    }
    if handled {
        return true
    } else {
        return try unknown.decodeField(setter: &setter)
    }
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    if let v = pyramidHeight {
      try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 1, protoFieldName: "pyramid_height", jsonFieldName: "pyramidHeight", swiftFieldName: "pyramidHeight")
    }
    if let v = pool {
      try visitor.visitSingularField(fieldType: SPPParameter.PoolMethod.self, value: v, protoFieldNumber: 2, protoFieldName: "pool", jsonFieldName: "pool", swiftFieldName: "pool")
    }
    if let v = engine {
      try visitor.visitSingularField(fieldType: SPPParameter.Engine.self, value: v, protoFieldNumber: 6, protoFieldName: "engine", jsonFieldName: "engine", swiftFieldName: "engine")
    }
    unknown.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: SPPParameter) -> Bool {
    if ((pyramidHeight != nil || other.pyramidHeight != nil) && (pyramidHeight == nil || other.pyramidHeight == nil || pyramidHeight! != other.pyramidHeight!)) {return false}
    if (((pool != nil && pool! != SPPParameter.PoolMethod.max) || (other.pool != nil && other.pool! != SPPParameter.PoolMethod.max)) && (pool == nil || other.pool == nil || pool! != other.pool!)) {return false}
    if (((engine != nil && engine! != SPPParameter.Engine.`default`) || (other.engine != nil && other.engine! != SPPParameter.Engine.`default`)) && (engine == nil || other.engine == nil || engine! != other.engine!)) {return false}
    if unknown != other.unknown {return false}
    return true
  }
}

///   DEPRECATED: use LayerParameter.
public struct V1LayerParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "V1LayerParameter"}
  public var protoMessageName: String {return "V1LayerParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "bottom": 2,
    "top": 3,
    "name": 4,
    "include": 32,
    "exclude": 33,
    "type": 5,
    "blobs": 6,
    "param": 1001,
    "blobShareMode": 1002,
    "blobsLr": 7,
    "weightDecay": 8,
    "lossWeight": 35,
    "accuracyParam": 27,
    "argmaxParam": 23,
    "concatParam": 9,
    "contrastiveLossParam": 40,
    "convolutionParam": 10,
    "dataParam": 11,
    "dropoutParam": 12,
    "dummyDataParam": 26,
    "eltwiseParam": 24,
    "expParam": 41,
    "hdf5DataParam": 13,
    "hdf5OutputParam": 14,
    "hingeLossParam": 29,
    "imageDataParam": 15,
    "infogainLossParam": 16,
    "innerProductParam": 17,
    "lrnParam": 18,
    "memoryDataParam": 22,
    "mvnParam": 34,
    "poolingParam": 19,
    "powerParam": 21,
    "reluParam": 30,
    "sigmoidParam": 38,
    "softmaxParam": 39,
    "sliceParam": 31,
    "tanhParam": 37,
    "thresholdParam": 25,
    "windowDataParam": 20,
    "transformParam": 36,
    "lossParam": 42,
    "layer": 1,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "bottom": 2,
    "top": 3,
    "name": 4,
    "include": 32,
    "exclude": 33,
    "type": 5,
    "blobs": 6,
    "param": 1001,
    "blob_share_mode": 1002,
    "blobs_lr": 7,
    "weight_decay": 8,
    "loss_weight": 35,
    "accuracy_param": 27,
    "argmax_param": 23,
    "concat_param": 9,
    "contrastive_loss_param": 40,
    "convolution_param": 10,
    "data_param": 11,
    "dropout_param": 12,
    "dummy_data_param": 26,
    "eltwise_param": 24,
    "exp_param": 41,
    "hdf5_data_param": 13,
    "hdf5_output_param": 14,
    "hinge_loss_param": 29,
    "image_data_param": 15,
    "infogain_loss_param": 16,
    "inner_product_param": 17,
    "lrn_param": 18,
    "memory_data_param": 22,
    "mvn_param": 34,
    "pooling_param": 19,
    "power_param": 21,
    "relu_param": 30,
    "sigmoid_param": 38,
    "softmax_param": 39,
    "slice_param": 31,
    "tanh_param": 37,
    "threshold_param": 25,
    "window_data_param": 20,
    "transform_param": 36,
    "loss_param": 42,
    "layer": 1,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = V1LayerParameter
    var unknown = ProtobufUnknownStorage()
    var _bottom: [String] = []
    var _top: [String] = []
    var _name: String? = nil
    var _include: [NetStateRule] = []
    var _exclude: [NetStateRule] = []
    var _type: V1LayerParameter.LayerType? = nil
    var _blobs: [BlobProto] = []
    var _param: [String] = []
    var _blobShareMode: [V1LayerParameter.DimCheckMode] = []
    var _blobsLr: [Float] = []
    var _weightDecay: [Float] = []
    var _lossWeight: [Float] = []
    var _accuracyParam: AccuracyParameter? = nil
    var _argmaxParam: ArgMaxParameter? = nil
    var _concatParam: ConcatParameter? = nil
    var _contrastiveLossParam: ContrastiveLossParameter? = nil
    var _convolutionParam: ConvolutionParameter? = nil
    var _dataParam: DataParameter? = nil
    var _dropoutParam: DropoutParameter? = nil
    var _dummyDataParam: DummyDataParameter? = nil
    var _eltwiseParam: EltwiseParameter? = nil
    var _expParam: ExpParameter? = nil
    var _hdf5DataParam: HDF5DataParameter? = nil
    var _hdf5OutputParam: HDF5OutputParameter? = nil
    var _hingeLossParam: HingeLossParameter? = nil
    var _imageDataParam: ImageDataParameter? = nil
    var _infogainLossParam: InfogainLossParameter? = nil
    var _innerProductParam: InnerProductParameter? = nil
    var _lrnParam: LRNParameter? = nil
    var _memoryDataParam: MemoryDataParameter? = nil
    var _mvnParam: MVNParameter? = nil
    var _poolingParam: PoolingParameter? = nil
    var _powerParam: PowerParameter? = nil
    var _reluParam: ReLUParameter? = nil
    var _sigmoidParam: SigmoidParameter? = nil
    var _softmaxParam: SoftmaxParameter? = nil
    var _sliceParam: SliceParameter? = nil
    var _tanhParam: TanHParameter? = nil
    var _thresholdParam: ThresholdParameter? = nil
    var _windowDataParam: WindowDataParameter? = nil
    var _transformParam: TransformationParameter? = nil
    var _lossParam: LossParameter? = nil
    var _layer: V0LayerParameter? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 2: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_bottom)
      case 3: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_top)
      case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_name)
      case 32: handled = try setter.decodeRepeatedMessageField(fieldType: NetStateRule.self, value: &_include)
      case 33: handled = try setter.decodeRepeatedMessageField(fieldType: NetStateRule.self, value: &_exclude)
      case 5: handled = try setter.decodeOptionalField(fieldType: V1LayerParameter.LayerType.self, value: &_type)
      case 6: handled = try setter.decodeRepeatedMessageField(fieldType: BlobProto.self, value: &_blobs)
      case 1001: handled = try setter.decodeRepeatedField(fieldType: ProtobufString.self, value: &_param)
      case 1002: handled = try setter.decodeRepeatedField(fieldType: V1LayerParameter.DimCheckMode.self, value: &_blobShareMode)
      case 7: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &_blobsLr)
      case 8: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &_weightDecay)
      case 35: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &_lossWeight)
      case 27: handled = try setter.decodeOptionalMessageField(fieldType: AccuracyParameter.self, value: &_accuracyParam)
      case 23: handled = try setter.decodeOptionalMessageField(fieldType: ArgMaxParameter.self, value: &_argmaxParam)
      case 9: handled = try setter.decodeOptionalMessageField(fieldType: ConcatParameter.self, value: &_concatParam)
      case 40: handled = try setter.decodeOptionalMessageField(fieldType: ContrastiveLossParameter.self, value: &_contrastiveLossParam)
      case 10: handled = try setter.decodeOptionalMessageField(fieldType: ConvolutionParameter.self, value: &_convolutionParam)
      case 11: handled = try setter.decodeOptionalMessageField(fieldType: DataParameter.self, value: &_dataParam)
      case 12: handled = try setter.decodeOptionalMessageField(fieldType: DropoutParameter.self, value: &_dropoutParam)
      case 26: handled = try setter.decodeOptionalMessageField(fieldType: DummyDataParameter.self, value: &_dummyDataParam)
      case 24: handled = try setter.decodeOptionalMessageField(fieldType: EltwiseParameter.self, value: &_eltwiseParam)
      case 41: handled = try setter.decodeOptionalMessageField(fieldType: ExpParameter.self, value: &_expParam)
      case 13: handled = try setter.decodeOptionalMessageField(fieldType: HDF5DataParameter.self, value: &_hdf5DataParam)
      case 14: handled = try setter.decodeOptionalMessageField(fieldType: HDF5OutputParameter.self, value: &_hdf5OutputParam)
      case 29: handled = try setter.decodeOptionalMessageField(fieldType: HingeLossParameter.self, value: &_hingeLossParam)
      case 15: handled = try setter.decodeOptionalMessageField(fieldType: ImageDataParameter.self, value: &_imageDataParam)
      case 16: handled = try setter.decodeOptionalMessageField(fieldType: InfogainLossParameter.self, value: &_infogainLossParam)
      case 17: handled = try setter.decodeOptionalMessageField(fieldType: InnerProductParameter.self, value: &_innerProductParam)
      case 18: handled = try setter.decodeOptionalMessageField(fieldType: LRNParameter.self, value: &_lrnParam)
      case 22: handled = try setter.decodeOptionalMessageField(fieldType: MemoryDataParameter.self, value: &_memoryDataParam)
      case 34: handled = try setter.decodeOptionalMessageField(fieldType: MVNParameter.self, value: &_mvnParam)
      case 19: handled = try setter.decodeOptionalMessageField(fieldType: PoolingParameter.self, value: &_poolingParam)
      case 21: handled = try setter.decodeOptionalMessageField(fieldType: PowerParameter.self, value: &_powerParam)
      case 30: handled = try setter.decodeOptionalMessageField(fieldType: ReLUParameter.self, value: &_reluParam)
      case 38: handled = try setter.decodeOptionalMessageField(fieldType: SigmoidParameter.self, value: &_sigmoidParam)
      case 39: handled = try setter.decodeOptionalMessageField(fieldType: SoftmaxParameter.self, value: &_softmaxParam)
      case 31: handled = try setter.decodeOptionalMessageField(fieldType: SliceParameter.self, value: &_sliceParam)
      case 37: handled = try setter.decodeOptionalMessageField(fieldType: TanHParameter.self, value: &_tanhParam)
      case 25: handled = try setter.decodeOptionalMessageField(fieldType: ThresholdParameter.self, value: &_thresholdParam)
      case 20: handled = try setter.decodeOptionalMessageField(fieldType: WindowDataParameter.self, value: &_windowDataParam)
      case 36: handled = try setter.decodeOptionalMessageField(fieldType: TransformationParameter.self, value: &_transformParam)
      case 42: handled = try setter.decodeOptionalMessageField(fieldType: LossParameter.self, value: &_lossParam)
      case 1: handled = try setter.decodeOptionalMessageField(fieldType: V0LayerParameter.self, value: &_layer)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _layer {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "layer", jsonFieldName: "layer", swiftFieldName: "layer")
      }
      if !_bottom.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _bottom, protoFieldNumber: 2, protoFieldName: "bottom", jsonFieldName: "bottom", swiftFieldName: "bottom")
      }
      if !_top.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _top, protoFieldNumber: 3, protoFieldName: "top", jsonFieldName: "top", swiftFieldName: "top")
      }
      if let v = _name {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 4, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if let v = _type {
        try visitor.visitSingularField(fieldType: V1LayerParameter.LayerType.self, value: v, protoFieldNumber: 5, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
      }
      if !_blobs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _blobs, protoFieldNumber: 6, protoFieldName: "blobs", jsonFieldName: "blobs", swiftFieldName: "blobs")
      }
      if !_blobsLr.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: _blobsLr, protoFieldNumber: 7, protoFieldName: "blobs_lr", jsonFieldName: "blobsLr", swiftFieldName: "blobsLr")
      }
      if !_weightDecay.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: _weightDecay, protoFieldNumber: 8, protoFieldName: "weight_decay", jsonFieldName: "weightDecay", swiftFieldName: "weightDecay")
      }
      if let v = _concatParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 9, protoFieldName: "concat_param", jsonFieldName: "concatParam", swiftFieldName: "concatParam")
      }
      if let v = _convolutionParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 10, protoFieldName: "convolution_param", jsonFieldName: "convolutionParam", swiftFieldName: "convolutionParam")
      }
      if let v = _dataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 11, protoFieldName: "data_param", jsonFieldName: "dataParam", swiftFieldName: "dataParam")
      }
      if let v = _dropoutParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 12, protoFieldName: "dropout_param", jsonFieldName: "dropoutParam", swiftFieldName: "dropoutParam")
      }
      if let v = _hdf5DataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 13, protoFieldName: "hdf5_data_param", jsonFieldName: "hdf5DataParam", swiftFieldName: "hdf5DataParam")
      }
      if let v = _hdf5OutputParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 14, protoFieldName: "hdf5_output_param", jsonFieldName: "hdf5OutputParam", swiftFieldName: "hdf5OutputParam")
      }
      if let v = _imageDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 15, protoFieldName: "image_data_param", jsonFieldName: "imageDataParam", swiftFieldName: "imageDataParam")
      }
      if let v = _infogainLossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 16, protoFieldName: "infogain_loss_param", jsonFieldName: "infogainLossParam", swiftFieldName: "infogainLossParam")
      }
      if let v = _innerProductParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 17, protoFieldName: "inner_product_param", jsonFieldName: "innerProductParam", swiftFieldName: "innerProductParam")
      }
      if let v = _lrnParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 18, protoFieldName: "lrn_param", jsonFieldName: "lrnParam", swiftFieldName: "lrnParam")
      }
      if let v = _poolingParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 19, protoFieldName: "pooling_param", jsonFieldName: "poolingParam", swiftFieldName: "poolingParam")
      }
      if let v = _windowDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 20, protoFieldName: "window_data_param", jsonFieldName: "windowDataParam", swiftFieldName: "windowDataParam")
      }
      if let v = _powerParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 21, protoFieldName: "power_param", jsonFieldName: "powerParam", swiftFieldName: "powerParam")
      }
      if let v = _memoryDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 22, protoFieldName: "memory_data_param", jsonFieldName: "memoryDataParam", swiftFieldName: "memoryDataParam")
      }
      if let v = _argmaxParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 23, protoFieldName: "argmax_param", jsonFieldName: "argmaxParam", swiftFieldName: "argmaxParam")
      }
      if let v = _eltwiseParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 24, protoFieldName: "eltwise_param", jsonFieldName: "eltwiseParam", swiftFieldName: "eltwiseParam")
      }
      if let v = _thresholdParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 25, protoFieldName: "threshold_param", jsonFieldName: "thresholdParam", swiftFieldName: "thresholdParam")
      }
      if let v = _dummyDataParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 26, protoFieldName: "dummy_data_param", jsonFieldName: "dummyDataParam", swiftFieldName: "dummyDataParam")
      }
      if let v = _accuracyParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 27, protoFieldName: "accuracy_param", jsonFieldName: "accuracyParam", swiftFieldName: "accuracyParam")
      }
      if let v = _hingeLossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 29, protoFieldName: "hinge_loss_param", jsonFieldName: "hingeLossParam", swiftFieldName: "hingeLossParam")
      }
      if let v = _reluParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 30, protoFieldName: "relu_param", jsonFieldName: "reluParam", swiftFieldName: "reluParam")
      }
      if let v = _sliceParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 31, protoFieldName: "slice_param", jsonFieldName: "sliceParam", swiftFieldName: "sliceParam")
      }
      if !_include.isEmpty {
        try visitor.visitRepeatedMessageField(value: _include, protoFieldNumber: 32, protoFieldName: "include", jsonFieldName: "include", swiftFieldName: "include")
      }
      if !_exclude.isEmpty {
        try visitor.visitRepeatedMessageField(value: _exclude, protoFieldNumber: 33, protoFieldName: "exclude", jsonFieldName: "exclude", swiftFieldName: "exclude")
      }
      if let v = _mvnParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 34, protoFieldName: "mvn_param", jsonFieldName: "mvnParam", swiftFieldName: "mvnParam")
      }
      if !_lossWeight.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: _lossWeight, protoFieldNumber: 35, protoFieldName: "loss_weight", jsonFieldName: "lossWeight", swiftFieldName: "lossWeight")
      }
      if let v = _transformParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 36, protoFieldName: "transform_param", jsonFieldName: "transformParam", swiftFieldName: "transformParam")
      }
      if let v = _tanhParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 37, protoFieldName: "tanh_param", jsonFieldName: "tanhParam", swiftFieldName: "tanhParam")
      }
      if let v = _sigmoidParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 38, protoFieldName: "sigmoid_param", jsonFieldName: "sigmoidParam", swiftFieldName: "sigmoidParam")
      }
      if let v = _softmaxParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 39, protoFieldName: "softmax_param", jsonFieldName: "softmaxParam", swiftFieldName: "softmaxParam")
      }
      if let v = _contrastiveLossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 40, protoFieldName: "contrastive_loss_param", jsonFieldName: "contrastiveLossParam", swiftFieldName: "contrastiveLossParam")
      }
      if let v = _expParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 41, protoFieldName: "exp_param", jsonFieldName: "expParam", swiftFieldName: "expParam")
      }
      if let v = _lossParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 42, protoFieldName: "loss_param", jsonFieldName: "lossParam", swiftFieldName: "lossParam")
      }
      if !_param.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufString.self, value: _param, protoFieldNumber: 1001, protoFieldName: "param", jsonFieldName: "param", swiftFieldName: "param")
      }
      if !_blobShareMode.isEmpty {
        try visitor.visitRepeatedField(fieldType: V1LayerParameter.DimCheckMode.self, value: _blobShareMode, protoFieldNumber: 1002, protoFieldName: "blob_share_mode", jsonFieldName: "blobShareMode", swiftFieldName: "blobShareMode")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if _bottom != other._bottom {return false}
      if _top != other._top {return false}
      if ((_name != nil || other._name != nil) && (_name == nil || other._name == nil || _name! != other._name!)) {return false}
      if _include != other._include {return false}
      if _exclude != other._exclude {return false}
      if ((_type != nil || other._type != nil) && (_type == nil || other._type == nil || _type! != other._type!)) {return false}
      if _blobs != other._blobs {return false}
      if _param != other._param {return false}
      if _blobShareMode != other._blobShareMode {return false}
      if _blobsLr != other._blobsLr {return false}
      if _weightDecay != other._weightDecay {return false}
      if _lossWeight != other._lossWeight {return false}
      if ((_accuracyParam != nil || other._accuracyParam != nil) && (_accuracyParam == nil || other._accuracyParam == nil || _accuracyParam! != other._accuracyParam!)) {return false}
      if ((_argmaxParam != nil || other._argmaxParam != nil) && (_argmaxParam == nil || other._argmaxParam == nil || _argmaxParam! != other._argmaxParam!)) {return false}
      if ((_concatParam != nil || other._concatParam != nil) && (_concatParam == nil || other._concatParam == nil || _concatParam! != other._concatParam!)) {return false}
      if ((_contrastiveLossParam != nil || other._contrastiveLossParam != nil) && (_contrastiveLossParam == nil || other._contrastiveLossParam == nil || _contrastiveLossParam! != other._contrastiveLossParam!)) {return false}
      if ((_convolutionParam != nil || other._convolutionParam != nil) && (_convolutionParam == nil || other._convolutionParam == nil || _convolutionParam! != other._convolutionParam!)) {return false}
      if ((_dataParam != nil || other._dataParam != nil) && (_dataParam == nil || other._dataParam == nil || _dataParam! != other._dataParam!)) {return false}
      if ((_dropoutParam != nil || other._dropoutParam != nil) && (_dropoutParam == nil || other._dropoutParam == nil || _dropoutParam! != other._dropoutParam!)) {return false}
      if ((_dummyDataParam != nil || other._dummyDataParam != nil) && (_dummyDataParam == nil || other._dummyDataParam == nil || _dummyDataParam! != other._dummyDataParam!)) {return false}
      if ((_eltwiseParam != nil || other._eltwiseParam != nil) && (_eltwiseParam == nil || other._eltwiseParam == nil || _eltwiseParam! != other._eltwiseParam!)) {return false}
      if ((_expParam != nil || other._expParam != nil) && (_expParam == nil || other._expParam == nil || _expParam! != other._expParam!)) {return false}
      if ((_hdf5DataParam != nil || other._hdf5DataParam != nil) && (_hdf5DataParam == nil || other._hdf5DataParam == nil || _hdf5DataParam! != other._hdf5DataParam!)) {return false}
      if ((_hdf5OutputParam != nil || other._hdf5OutputParam != nil) && (_hdf5OutputParam == nil || other._hdf5OutputParam == nil || _hdf5OutputParam! != other._hdf5OutputParam!)) {return false}
      if ((_hingeLossParam != nil || other._hingeLossParam != nil) && (_hingeLossParam == nil || other._hingeLossParam == nil || _hingeLossParam! != other._hingeLossParam!)) {return false}
      if ((_imageDataParam != nil || other._imageDataParam != nil) && (_imageDataParam == nil || other._imageDataParam == nil || _imageDataParam! != other._imageDataParam!)) {return false}
      if ((_infogainLossParam != nil || other._infogainLossParam != nil) && (_infogainLossParam == nil || other._infogainLossParam == nil || _infogainLossParam! != other._infogainLossParam!)) {return false}
      if ((_innerProductParam != nil || other._innerProductParam != nil) && (_innerProductParam == nil || other._innerProductParam == nil || _innerProductParam! != other._innerProductParam!)) {return false}
      if ((_lrnParam != nil || other._lrnParam != nil) && (_lrnParam == nil || other._lrnParam == nil || _lrnParam! != other._lrnParam!)) {return false}
      if ((_memoryDataParam != nil || other._memoryDataParam != nil) && (_memoryDataParam == nil || other._memoryDataParam == nil || _memoryDataParam! != other._memoryDataParam!)) {return false}
      if ((_mvnParam != nil || other._mvnParam != nil) && (_mvnParam == nil || other._mvnParam == nil || _mvnParam! != other._mvnParam!)) {return false}
      if ((_poolingParam != nil || other._poolingParam != nil) && (_poolingParam == nil || other._poolingParam == nil || _poolingParam! != other._poolingParam!)) {return false}
      if ((_powerParam != nil || other._powerParam != nil) && (_powerParam == nil || other._powerParam == nil || _powerParam! != other._powerParam!)) {return false}
      if ((_reluParam != nil || other._reluParam != nil) && (_reluParam == nil || other._reluParam == nil || _reluParam! != other._reluParam!)) {return false}
      if ((_sigmoidParam != nil || other._sigmoidParam != nil) && (_sigmoidParam == nil || other._sigmoidParam == nil || _sigmoidParam! != other._sigmoidParam!)) {return false}
      if ((_softmaxParam != nil || other._softmaxParam != nil) && (_softmaxParam == nil || other._softmaxParam == nil || _softmaxParam! != other._softmaxParam!)) {return false}
      if ((_sliceParam != nil || other._sliceParam != nil) && (_sliceParam == nil || other._sliceParam == nil || _sliceParam! != other._sliceParam!)) {return false}
      if ((_tanhParam != nil || other._tanhParam != nil) && (_tanhParam == nil || other._tanhParam == nil || _tanhParam! != other._tanhParam!)) {return false}
      if ((_thresholdParam != nil || other._thresholdParam != nil) && (_thresholdParam == nil || other._thresholdParam == nil || _thresholdParam! != other._thresholdParam!)) {return false}
      if ((_windowDataParam != nil || other._windowDataParam != nil) && (_windowDataParam == nil || other._windowDataParam == nil || _windowDataParam! != other._windowDataParam!)) {return false}
      if ((_transformParam != nil || other._transformParam != nil) && (_transformParam == nil || other._transformParam == nil || _transformParam! != other._transformParam!)) {return false}
      if ((_lossParam != nil || other._lossParam != nil) && (_lossParam == nil || other._lossParam == nil || _lossParam! != other._lossParam!)) {return false}
      if ((_layer != nil || other._layer != nil) && (_layer == nil || other._layer == nil || _layer! != other._layer!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._bottom = _bottom
      clone._top = _top
      clone._name = _name
      clone._include = _include
      clone._exclude = _exclude
      clone._type = _type
      clone._blobs = _blobs
      clone._param = _param
      clone._blobShareMode = _blobShareMode
      clone._blobsLr = _blobsLr
      clone._weightDecay = _weightDecay
      clone._lossWeight = _lossWeight
      clone._accuracyParam = _accuracyParam
      clone._argmaxParam = _argmaxParam
      clone._concatParam = _concatParam
      clone._contrastiveLossParam = _contrastiveLossParam
      clone._convolutionParam = _convolutionParam
      clone._dataParam = _dataParam
      clone._dropoutParam = _dropoutParam
      clone._dummyDataParam = _dummyDataParam
      clone._eltwiseParam = _eltwiseParam
      clone._expParam = _expParam
      clone._hdf5DataParam = _hdf5DataParam
      clone._hdf5OutputParam = _hdf5OutputParam
      clone._hingeLossParam = _hingeLossParam
      clone._imageDataParam = _imageDataParam
      clone._infogainLossParam = _infogainLossParam
      clone._innerProductParam = _innerProductParam
      clone._lrnParam = _lrnParam
      clone._memoryDataParam = _memoryDataParam
      clone._mvnParam = _mvnParam
      clone._poolingParam = _poolingParam
      clone._powerParam = _powerParam
      clone._reluParam = _reluParam
      clone._sigmoidParam = _sigmoidParam
      clone._softmaxParam = _softmaxParam
      clone._sliceParam = _sliceParam
      clone._tanhParam = _tanhParam
      clone._thresholdParam = _thresholdParam
      clone._windowDataParam = _windowDataParam
      clone._transformParam = _transformParam
      clone._lossParam = _lossParam
      clone._layer = _layer
      return clone
    }
  }

  private var _storage = _StorageClass()

  public enum LayerType: ProtobufEnum {
    public typealias RawValue = Int
    case none // = 0
    case absval // = 35
    case accuracy // = 1
    case argmax // = 30
    case bnll // = 2
    case concat // = 3
    case contrastiveLoss // = 37
    case convolution // = 4
    case data // = 5
    case deconvolution // = 39
    case dropout // = 6
    case dummyData // = 32
    case euclideanLoss // = 7
    case eltwise // = 25
    case exp // = 38
    case flatten // = 8
    case hdf5Data // = 9
    case hdf5Output // = 10
    case hingeLoss // = 28
    case im2Col // = 11
    case imageData // = 12
    case infogainLoss // = 13
    case innerProduct // = 14
    case lrn // = 15
    case memoryData // = 29
    case multinomialLogisticLoss // = 16
    case mvn // = 34
    case pooling // = 17
    case power // = 26
    case relu // = 18
    case sigmoid // = 19
    case sigmoidCrossEntropyLoss // = 27
    case silence // = 36
    case softmax // = 20
    case softmaxLoss // = 21
    case split // = 22
    case slice // = 33
    case tanh // = 23
    case windowData // = 24
    case threshold // = 31

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 35: self = .absval
      case 1: self = .accuracy
      case 30: self = .argmax
      case 2: self = .bnll
      case 3: self = .concat
      case 37: self = .contrastiveLoss
      case 4: self = .convolution
      case 5: self = .data
      case 39: self = .deconvolution
      case 6: self = .dropout
      case 32: self = .dummyData
      case 7: self = .euclideanLoss
      case 25: self = .eltwise
      case 38: self = .exp
      case 8: self = .flatten
      case 9: self = .hdf5Data
      case 10: self = .hdf5Output
      case 28: self = .hingeLoss
      case 11: self = .im2Col
      case 12: self = .imageData
      case 13: self = .infogainLoss
      case 14: self = .innerProduct
      case 15: self = .lrn
      case 29: self = .memoryData
      case 16: self = .multinomialLogisticLoss
      case 34: self = .mvn
      case 17: self = .pooling
      case 26: self = .power
      case 18: self = .relu
      case 19: self = .sigmoid
      case 27: self = .sigmoidCrossEntropyLoss
      case 36: self = .silence
      case 20: self = .softmax
      case 21: self = .softmaxLoss
      case 22: self = .split
      case 33: self = .slice
      case 23: self = .tanh
      case 24: self = .windowData
      case 31: self = .threshold
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "none": self = .none
      case "absval": self = .absval
      case "accuracy": self = .accuracy
      case "argmax": self = .argmax
      case "bnll": self = .bnll
      case "concat": self = .concat
      case "contrastiveLoss": self = .contrastiveLoss
      case "convolution": self = .convolution
      case "data": self = .data
      case "deconvolution": self = .deconvolution
      case "dropout": self = .dropout
      case "dummyData": self = .dummyData
      case "euclideanLoss": self = .euclideanLoss
      case "eltwise": self = .eltwise
      case "exp": self = .exp
      case "flatten": self = .flatten
      case "hdf5Data": self = .hdf5Data
      case "hdf5Output": self = .hdf5Output
      case "hingeLoss": self = .hingeLoss
      case "im2Col": self = .im2Col
      case "imageData": self = .imageData
      case "infogainLoss": self = .infogainLoss
      case "innerProduct": self = .innerProduct
      case "lrn": self = .lrn
      case "memoryData": self = .memoryData
      case "multinomialLogisticLoss": self = .multinomialLogisticLoss
      case "mvn": self = .mvn
      case "pooling": self = .pooling
      case "power": self = .power
      case "relu": self = .relu
      case "sigmoid": self = .sigmoid
      case "sigmoidCrossEntropyLoss": self = .sigmoidCrossEntropyLoss
      case "silence": self = .silence
      case "softmax": self = .softmax
      case "softmaxLoss": self = .softmaxLoss
      case "split": self = .split
      case "slice": self = .slice
      case "tanh": self = .tanh
      case "windowData": self = .windowData
      case "threshold": self = .threshold
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "NONE": self = .none
      case "ABSVAL": self = .absval
      case "ACCURACY": self = .accuracy
      case "ARGMAX": self = .argmax
      case "BNLL": self = .bnll
      case "CONCAT": self = .concat
      case "CONTRASTIVE_LOSS": self = .contrastiveLoss
      case "CONVOLUTION": self = .convolution
      case "DATA": self = .data
      case "DECONVOLUTION": self = .deconvolution
      case "DROPOUT": self = .dropout
      case "DUMMY_DATA": self = .dummyData
      case "EUCLIDEAN_LOSS": self = .euclideanLoss
      case "ELTWISE": self = .eltwise
      case "EXP": self = .exp
      case "FLATTEN": self = .flatten
      case "HDF5_DATA": self = .hdf5Data
      case "HDF5_OUTPUT": self = .hdf5Output
      case "HINGE_LOSS": self = .hingeLoss
      case "IM2COL": self = .im2Col
      case "IMAGE_DATA": self = .imageData
      case "INFOGAIN_LOSS": self = .infogainLoss
      case "INNER_PRODUCT": self = .innerProduct
      case "LRN": self = .lrn
      case "MEMORY_DATA": self = .memoryData
      case "MULTINOMIAL_LOGISTIC_LOSS": self = .multinomialLogisticLoss
      case "MVN": self = .mvn
      case "POOLING": self = .pooling
      case "POWER": self = .power
      case "RELU": self = .relu
      case "SIGMOID": self = .sigmoid
      case "SIGMOID_CROSS_ENTROPY_LOSS": self = .sigmoidCrossEntropyLoss
      case "SILENCE": self = .silence
      case "SOFTMAX": self = .softmax
      case "SOFTMAX_LOSS": self = .softmaxLoss
      case "SPLIT": self = .split
      case "SLICE": self = .slice
      case "TANH": self = .tanh
      case "WINDOW_DATA": self = .windowData
      case "THRESHOLD": self = .threshold
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "NONE": self = .none
      case "ABSVAL": self = .absval
      case "ACCURACY": self = .accuracy
      case "ARGMAX": self = .argmax
      case "BNLL": self = .bnll
      case "CONCAT": self = .concat
      case "CONTRASTIVE_LOSS": self = .contrastiveLoss
      case "CONVOLUTION": self = .convolution
      case "DATA": self = .data
      case "DECONVOLUTION": self = .deconvolution
      case "DROPOUT": self = .dropout
      case "DUMMY_DATA": self = .dummyData
      case "EUCLIDEAN_LOSS": self = .euclideanLoss
      case "ELTWISE": self = .eltwise
      case "EXP": self = .exp
      case "FLATTEN": self = .flatten
      case "HDF5_DATA": self = .hdf5Data
      case "HDF5_OUTPUT": self = .hdf5Output
      case "HINGE_LOSS": self = .hingeLoss
      case "IM2COL": self = .im2Col
      case "IMAGE_DATA": self = .imageData
      case "INFOGAIN_LOSS": self = .infogainLoss
      case "INNER_PRODUCT": self = .innerProduct
      case "LRN": self = .lrn
      case "MEMORY_DATA": self = .memoryData
      case "MULTINOMIAL_LOGISTIC_LOSS": self = .multinomialLogisticLoss
      case "MVN": self = .mvn
      case "POOLING": self = .pooling
      case "POWER": self = .power
      case "RELU": self = .relu
      case "SIGMOID": self = .sigmoid
      case "SIGMOID_CROSS_ENTROPY_LOSS": self = .sigmoidCrossEntropyLoss
      case "SILENCE": self = .silence
      case "SOFTMAX": self = .softmax
      case "SOFTMAX_LOSS": self = .softmaxLoss
      case "SPLIT": self = .split
      case "SLICE": self = .slice
      case "TANH": self = .tanh
      case "WINDOW_DATA": self = .windowData
      case "THRESHOLD": self = .threshold
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .none: return 0
        case .absval: return 35
        case .accuracy: return 1
        case .argmax: return 30
        case .bnll: return 2
        case .concat: return 3
        case .contrastiveLoss: return 37
        case .convolution: return 4
        case .data: return 5
        case .deconvolution: return 39
        case .dropout: return 6
        case .dummyData: return 32
        case .euclideanLoss: return 7
        case .eltwise: return 25
        case .exp: return 38
        case .flatten: return 8
        case .hdf5Data: return 9
        case .hdf5Output: return 10
        case .hingeLoss: return 28
        case .im2Col: return 11
        case .imageData: return 12
        case .infogainLoss: return 13
        case .innerProduct: return 14
        case .lrn: return 15
        case .memoryData: return 29
        case .multinomialLogisticLoss: return 16
        case .mvn: return 34
        case .pooling: return 17
        case .power: return 26
        case .relu: return 18
        case .sigmoid: return 19
        case .sigmoidCrossEntropyLoss: return 27
        case .silence: return 36
        case .softmax: return 20
        case .softmaxLoss: return 21
        case .split: return 22
        case .slice: return 33
        case .tanh: return 23
        case .windowData: return 24
        case .threshold: return 31
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .none: return "\"NONE\""
        case .absval: return "\"ABSVAL\""
        case .accuracy: return "\"ACCURACY\""
        case .argmax: return "\"ARGMAX\""
        case .bnll: return "\"BNLL\""
        case .concat: return "\"CONCAT\""
        case .contrastiveLoss: return "\"CONTRASTIVE_LOSS\""
        case .convolution: return "\"CONVOLUTION\""
        case .data: return "\"DATA\""
        case .deconvolution: return "\"DECONVOLUTION\""
        case .dropout: return "\"DROPOUT\""
        case .dummyData: return "\"DUMMY_DATA\""
        case .euclideanLoss: return "\"EUCLIDEAN_LOSS\""
        case .eltwise: return "\"ELTWISE\""
        case .exp: return "\"EXP\""
        case .flatten: return "\"FLATTEN\""
        case .hdf5Data: return "\"HDF5_DATA\""
        case .hdf5Output: return "\"HDF5_OUTPUT\""
        case .hingeLoss: return "\"HINGE_LOSS\""
        case .im2Col: return "\"IM2COL\""
        case .imageData: return "\"IMAGE_DATA\""
        case .infogainLoss: return "\"INFOGAIN_LOSS\""
        case .innerProduct: return "\"INNER_PRODUCT\""
        case .lrn: return "\"LRN\""
        case .memoryData: return "\"MEMORY_DATA\""
        case .multinomialLogisticLoss: return "\"MULTINOMIAL_LOGISTIC_LOSS\""
        case .mvn: return "\"MVN\""
        case .pooling: return "\"POOLING\""
        case .power: return "\"POWER\""
        case .relu: return "\"RELU\""
        case .sigmoid: return "\"SIGMOID\""
        case .sigmoidCrossEntropyLoss: return "\"SIGMOID_CROSS_ENTROPY_LOSS\""
        case .silence: return "\"SILENCE\""
        case .softmax: return "\"SOFTMAX\""
        case .softmaxLoss: return "\"SOFTMAX_LOSS\""
        case .split: return "\"SPLIT\""
        case .slice: return "\"SLICE\""
        case .tanh: return "\"TANH\""
        case .windowData: return "\"WINDOW_DATA\""
        case .threshold: return "\"THRESHOLD\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .none: return ".none"
        case .absval: return ".absval"
        case .accuracy: return ".accuracy"
        case .argmax: return ".argmax"
        case .bnll: return ".bnll"
        case .concat: return ".concat"
        case .contrastiveLoss: return ".contrastiveLoss"
        case .convolution: return ".convolution"
        case .data: return ".data"
        case .deconvolution: return ".deconvolution"
        case .dropout: return ".dropout"
        case .dummyData: return ".dummyData"
        case .euclideanLoss: return ".euclideanLoss"
        case .eltwise: return ".eltwise"
        case .exp: return ".exp"
        case .flatten: return ".flatten"
        case .hdf5Data: return ".hdf5Data"
        case .hdf5Output: return ".hdf5Output"
        case .hingeLoss: return ".hingeLoss"
        case .im2Col: return ".im2Col"
        case .imageData: return ".imageData"
        case .infogainLoss: return ".infogainLoss"
        case .innerProduct: return ".innerProduct"
        case .lrn: return ".lrn"
        case .memoryData: return ".memoryData"
        case .multinomialLogisticLoss: return ".multinomialLogisticLoss"
        case .mvn: return ".mvn"
        case .pooling: return ".pooling"
        case .power: return ".power"
        case .relu: return ".relu"
        case .sigmoid: return ".sigmoid"
        case .sigmoidCrossEntropyLoss: return ".sigmoidCrossEntropyLoss"
        case .silence: return ".silence"
        case .softmax: return ".softmax"
        case .softmaxLoss: return ".softmaxLoss"
        case .split: return ".split"
        case .slice: return ".slice"
        case .tanh: return ".tanh"
        case .windowData: return ".windowData"
        case .threshold: return ".threshold"
        }
      }
    }

  }

  public enum DimCheckMode: ProtobufEnum {
    public typealias RawValue = Int
    case strict // = 0
    case permissive // = 1

    public init() {
      self = .strict
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .strict
      case 1: self = .permissive
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "strict": self = .strict
      case "permissive": self = .permissive
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "STRICT": self = .strict
      case "PERMISSIVE": self = .permissive
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "STRICT": self = .strict
      case "PERMISSIVE": self = .permissive
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .strict: return 0
        case .permissive: return 1
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .strict: return "\"STRICT\""
        case .permissive: return "\"PERMISSIVE\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .strict: return ".strict"
        case .permissive: return ".permissive"
        }
      }
    }

  }

  public var bottom: [String] {
    get {return _storage._bottom}
    set {_uniqueStorage()._bottom = newValue}
  }

  public var top: [String] {
    get {return _storage._top}
    set {_uniqueStorage()._top = newValue}
  }

  public var name: String? {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var include: [NetStateRule] {
    get {return _storage._include}
    set {_uniqueStorage()._include = newValue}
  }

  public var exclude: [NetStateRule] {
    get {return _storage._exclude}
    set {_uniqueStorage()._exclude = newValue}
  }

  public var type: V1LayerParameter.LayerType? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var blobs: [BlobProto] {
    get {return _storage._blobs}
    set {_uniqueStorage()._blobs = newValue}
  }

  public var param: [String] {
    get {return _storage._param}
    set {_uniqueStorage()._param = newValue}
  }

  public var blobShareMode: [V1LayerParameter.DimCheckMode] {
    get {return _storage._blobShareMode}
    set {_uniqueStorage()._blobShareMode = newValue}
  }

  public var blobsLr: [Float] {
    get {return _storage._blobsLr}
    set {_uniqueStorage()._blobsLr = newValue}
  }

  public var weightDecay: [Float] {
    get {return _storage._weightDecay}
    set {_uniqueStorage()._weightDecay = newValue}
  }

  public var lossWeight: [Float] {
    get {return _storage._lossWeight}
    set {_uniqueStorage()._lossWeight = newValue}
  }

  public var accuracyParam: AccuracyParameter? {
    get {return _storage._accuracyParam}
    set {_uniqueStorage()._accuracyParam = newValue}
  }

  public var argmaxParam: ArgMaxParameter? {
    get {return _storage._argmaxParam}
    set {_uniqueStorage()._argmaxParam = newValue}
  }

  public var concatParam: ConcatParameter? {
    get {return _storage._concatParam}
    set {_uniqueStorage()._concatParam = newValue}
  }

  public var contrastiveLossParam: ContrastiveLossParameter? {
    get {return _storage._contrastiveLossParam}
    set {_uniqueStorage()._contrastiveLossParam = newValue}
  }

  public var convolutionParam: ConvolutionParameter? {
    get {return _storage._convolutionParam}
    set {_uniqueStorage()._convolutionParam = newValue}
  }

  public var dataParam: DataParameter? {
    get {return _storage._dataParam}
    set {_uniqueStorage()._dataParam = newValue}
  }

  public var dropoutParam: DropoutParameter? {
    get {return _storage._dropoutParam}
    set {_uniqueStorage()._dropoutParam = newValue}
  }

  public var dummyDataParam: DummyDataParameter? {
    get {return _storage._dummyDataParam}
    set {_uniqueStorage()._dummyDataParam = newValue}
  }

  public var eltwiseParam: EltwiseParameter? {
    get {return _storage._eltwiseParam}
    set {_uniqueStorage()._eltwiseParam = newValue}
  }

  public var expParam: ExpParameter? {
    get {return _storage._expParam}
    set {_uniqueStorage()._expParam = newValue}
  }

  public var hdf5DataParam: HDF5DataParameter? {
    get {return _storage._hdf5DataParam}
    set {_uniqueStorage()._hdf5DataParam = newValue}
  }

  public var hdf5OutputParam: HDF5OutputParameter? {
    get {return _storage._hdf5OutputParam}
    set {_uniqueStorage()._hdf5OutputParam = newValue}
  }

  public var hingeLossParam: HingeLossParameter? {
    get {return _storage._hingeLossParam}
    set {_uniqueStorage()._hingeLossParam = newValue}
  }

  public var imageDataParam: ImageDataParameter? {
    get {return _storage._imageDataParam}
    set {_uniqueStorage()._imageDataParam = newValue}
  }

  public var infogainLossParam: InfogainLossParameter? {
    get {return _storage._infogainLossParam}
    set {_uniqueStorage()._infogainLossParam = newValue}
  }

  public var innerProductParam: InnerProductParameter? {
    get {return _storage._innerProductParam}
    set {_uniqueStorage()._innerProductParam = newValue}
  }

  public var lrnParam: LRNParameter? {
    get {return _storage._lrnParam}
    set {_uniqueStorage()._lrnParam = newValue}
  }

  public var memoryDataParam: MemoryDataParameter? {
    get {return _storage._memoryDataParam}
    set {_uniqueStorage()._memoryDataParam = newValue}
  }

  public var mvnParam: MVNParameter? {
    get {return _storage._mvnParam}
    set {_uniqueStorage()._mvnParam = newValue}
  }

  public var poolingParam: PoolingParameter? {
    get {return _storage._poolingParam}
    set {_uniqueStorage()._poolingParam = newValue}
  }

  public var powerParam: PowerParameter? {
    get {return _storage._powerParam}
    set {_uniqueStorage()._powerParam = newValue}
  }

  public var reluParam: ReLUParameter? {
    get {return _storage._reluParam}
    set {_uniqueStorage()._reluParam = newValue}
  }

  public var sigmoidParam: SigmoidParameter? {
    get {return _storage._sigmoidParam}
    set {_uniqueStorage()._sigmoidParam = newValue}
  }

  public var softmaxParam: SoftmaxParameter? {
    get {return _storage._softmaxParam}
    set {_uniqueStorage()._softmaxParam = newValue}
  }

  public var sliceParam: SliceParameter? {
    get {return _storage._sliceParam}
    set {_uniqueStorage()._sliceParam = newValue}
  }

  public var tanhParam: TanHParameter? {
    get {return _storage._tanhParam}
    set {_uniqueStorage()._tanhParam = newValue}
  }

  public var thresholdParam: ThresholdParameter? {
    get {return _storage._thresholdParam}
    set {_uniqueStorage()._thresholdParam = newValue}
  }

  public var windowDataParam: WindowDataParameter? {
    get {return _storage._windowDataParam}
    set {_uniqueStorage()._windowDataParam = newValue}
  }

  public var transformParam: TransformationParameter? {
    get {return _storage._transformParam}
    set {_uniqueStorage()._transformParam = newValue}
  }

  public var lossParam: LossParameter? {
    get {return _storage._lossParam}
    set {_uniqueStorage()._lossParam = newValue}
  }

  public var layer: V0LayerParameter? {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  public init() {}

  public init(bottom: [String] = [],
    top: [String] = [],
    name: String? = nil,
    include: [NetStateRule] = [],
    exclude: [NetStateRule] = [],
    type: V1LayerParameter.LayerType? = nil,
    blobs: [BlobProto] = [],
    param: [String] = [],
    blobShareMode: [V1LayerParameter.DimCheckMode] = [],
    blobsLr: [Float] = [],
    weightDecay: [Float] = [],
    lossWeight: [Float] = [],
    accuracyParam: AccuracyParameter? = nil,
    argmaxParam: ArgMaxParameter? = nil,
    concatParam: ConcatParameter? = nil,
    contrastiveLossParam: ContrastiveLossParameter? = nil,
    convolutionParam: ConvolutionParameter? = nil,
    dataParam: DataParameter? = nil,
    dropoutParam: DropoutParameter? = nil,
    dummyDataParam: DummyDataParameter? = nil,
    eltwiseParam: EltwiseParameter? = nil,
    expParam: ExpParameter? = nil,
    hdf5DataParam: HDF5DataParameter? = nil,
    hdf5OutputParam: HDF5OutputParameter? = nil,
    hingeLossParam: HingeLossParameter? = nil,
    imageDataParam: ImageDataParameter? = nil,
    infogainLossParam: InfogainLossParameter? = nil,
    innerProductParam: InnerProductParameter? = nil,
    lrnParam: LRNParameter? = nil,
    memoryDataParam: MemoryDataParameter? = nil,
    mvnParam: MVNParameter? = nil,
    poolingParam: PoolingParameter? = nil,
    powerParam: PowerParameter? = nil,
    reluParam: ReLUParameter? = nil,
    sigmoidParam: SigmoidParameter? = nil,
    softmaxParam: SoftmaxParameter? = nil,
    sliceParam: SliceParameter? = nil,
    tanhParam: TanHParameter? = nil,
    thresholdParam: ThresholdParameter? = nil,
    windowDataParam: WindowDataParameter? = nil,
    transformParam: TransformationParameter? = nil,
    lossParam: LossParameter? = nil,
    layer: V0LayerParameter? = nil)
  {
    let storage = _uniqueStorage()
    if !bottom.isEmpty {
      storage._bottom = bottom
    }
    if !top.isEmpty {
      storage._top = top
    }
    storage._name = name
    if !include.isEmpty {
      storage._include = include
    }
    if !exclude.isEmpty {
      storage._exclude = exclude
    }
    storage._type = type
    if !blobs.isEmpty {
      storage._blobs = blobs
    }
    if !param.isEmpty {
      storage._param = param
    }
    if !blobShareMode.isEmpty {
      storage._blobShareMode = blobShareMode
    }
    if !blobsLr.isEmpty {
      storage._blobsLr = blobsLr
    }
    if !weightDecay.isEmpty {
      storage._weightDecay = weightDecay
    }
    if !lossWeight.isEmpty {
      storage._lossWeight = lossWeight
    }
    storage._accuracyParam = accuracyParam
    storage._argmaxParam = argmaxParam
    storage._concatParam = concatParam
    storage._contrastiveLossParam = contrastiveLossParam
    storage._convolutionParam = convolutionParam
    storage._dataParam = dataParam
    storage._dropoutParam = dropoutParam
    storage._dummyDataParam = dummyDataParam
    storage._eltwiseParam = eltwiseParam
    storage._expParam = expParam
    storage._hdf5DataParam = hdf5DataParam
    storage._hdf5OutputParam = hdf5OutputParam
    storage._hingeLossParam = hingeLossParam
    storage._imageDataParam = imageDataParam
    storage._infogainLossParam = infogainLossParam
    storage._innerProductParam = innerProductParam
    storage._lrnParam = lrnParam
    storage._memoryDataParam = memoryDataParam
    storage._mvnParam = mvnParam
    storage._poolingParam = poolingParam
    storage._powerParam = powerParam
    storage._reluParam = reluParam
    storage._sigmoidParam = sigmoidParam
    storage._softmaxParam = softmaxParam
    storage._sliceParam = sliceParam
    storage._tanhParam = tanhParam
    storage._thresholdParam = thresholdParam
    storage._windowDataParam = windowDataParam
    storage._transformParam = transformParam
    storage._lossParam = lossParam
    storage._layer = layer
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: V1LayerParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   DEPRECATED: V0LayerParameter is the old way of specifying layer parameters
///   in Caffe.  We keep this message type around for legacy support.
public struct V0LayerParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "V0LayerParameter"}
  public var protoMessageName: String {return "V0LayerParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "name": 1,
    "type": 2,
    "numOutput": 3,
    "biasterm": 4,
    "weightFiller": 5,
    "biasFiller": 6,
    "pad": 7,
    "kernelsize": 8,
    "group": 9,
    "stride": 10,
    "pool": 11,
    "dropoutRatio": 12,
    "localSize": 13,
    "alpha": 14,
    "beta": 15,
    "k": 22,
    "source": 16,
    "scale": 17,
    "meanfile": 18,
    "batchsize": 19,
    "cropsize": 20,
    "mirror": 21,
    "blobs": 50,
    "blobsLr": 51,
    "weightDecay": 52,
    "randSkip": 53,
    "detFgThreshold": 54,
    "detBgThreshold": 55,
    "detFgFraction": 56,
    "detContextPad": 58,
    "detCropMode": 59,
    "newNum": 60,
    "newChannels": 61,
    "newHeight": 62,
    "newWidth": 63,
    "shuffleImages": 64,
    "concatDim": 65,
    "hdf5OutputParam": 1001,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "name": 1,
    "type": 2,
    "num_output": 3,
    "biasterm": 4,
    "weight_filler": 5,
    "bias_filler": 6,
    "pad": 7,
    "kernelsize": 8,
    "group": 9,
    "stride": 10,
    "pool": 11,
    "dropout_ratio": 12,
    "local_size": 13,
    "alpha": 14,
    "beta": 15,
    "k": 22,
    "source": 16,
    "scale": 17,
    "meanfile": 18,
    "batchsize": 19,
    "cropsize": 20,
    "mirror": 21,
    "blobs": 50,
    "blobs_lr": 51,
    "weight_decay": 52,
    "rand_skip": 53,
    "det_fg_threshold": 54,
    "det_bg_threshold": 55,
    "det_fg_fraction": 56,
    "det_context_pad": 58,
    "det_crop_mode": 59,
    "new_num": 60,
    "new_channels": 61,
    "new_height": 62,
    "new_width": 63,
    "shuffle_images": 64,
    "concat_dim": 65,
    "hdf5_output_param": 1001,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = V0LayerParameter
    var unknown = ProtobufUnknownStorage()
    var _name: String? = nil
    var _type: String? = nil
    var _numOutput: UInt32? = nil
    var _biasterm: Bool? = nil
    var _weightFiller: FillerParameter? = nil
    var _biasFiller: FillerParameter? = nil
    var _pad: UInt32? = nil
    var _kernelsize: UInt32? = nil
    var _group: UInt32? = nil
    var _stride: UInt32? = nil
    var _pool: V0LayerParameter.PoolMethod? = nil
    var _dropoutRatio: Float? = nil
    var _localSize: UInt32? = nil
    var _alpha: Float? = nil
    var _beta: Float? = nil
    var _k: Float? = nil
    var _source: String? = nil
    var _scale: Float? = nil
    var _meanfile: String? = nil
    var _batchsize: UInt32? = nil
    var _cropsize: UInt32? = nil
    var _mirror: Bool? = nil
    var _blobs: [BlobProto] = []
    var _blobsLr: [Float] = []
    var _weightDecay: [Float] = []
    var _randSkip: UInt32? = nil
    var _detFgThreshold: Float? = nil
    var _detBgThreshold: Float? = nil
    var _detFgFraction: Float? = nil
    var _detContextPad: UInt32? = nil
    var _detCropMode: String? = nil
    var _newNum: Int32? = nil
    var _newChannels: Int32? = nil
    var _newHeight: Int32? = nil
    var _newWidth: Int32? = nil
    var _shuffleImages: Bool? = nil
    var _concatDim: UInt32? = nil
    var _hdf5OutputParam: HDF5OutputParameter? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_name)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_type)
      case 3: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_numOutput)
      case 4: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_biasterm)
      case 5: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_weightFiller)
      case 6: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_biasFiller)
      case 7: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_pad)
      case 8: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_kernelsize)
      case 9: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_group)
      case 10: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_stride)
      case 11: handled = try setter.decodeOptionalField(fieldType: V0LayerParameter.PoolMethod.self, value: &_pool)
      case 12: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_dropoutRatio)
      case 13: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_localSize)
      case 14: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_alpha)
      case 15: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_beta)
      case 22: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_k)
      case 16: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_source)
      case 17: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_scale)
      case 18: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_meanfile)
      case 19: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_batchsize)
      case 20: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_cropsize)
      case 21: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_mirror)
      case 50: handled = try setter.decodeRepeatedMessageField(fieldType: BlobProto.self, value: &_blobs)
      case 51: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &_blobsLr)
      case 52: handled = try setter.decodeRepeatedField(fieldType: ProtobufFloat.self, value: &_weightDecay)
      case 53: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_randSkip)
      case 54: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_detFgThreshold)
      case 55: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_detBgThreshold)
      case 56: handled = try setter.decodeOptionalField(fieldType: ProtobufFloat.self, value: &_detFgFraction)
      case 58: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_detContextPad)
      case 59: handled = try setter.decodeOptionalField(fieldType: ProtobufString.self, value: &_detCropMode)
      case 60: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_newNum)
      case 61: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_newChannels)
      case 62: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_newHeight)
      case 63: handled = try setter.decodeOptionalField(fieldType: ProtobufInt32.self, value: &_newWidth)
      case 64: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_shuffleImages)
      case 65: handled = try setter.decodeOptionalField(fieldType: ProtobufUInt32.self, value: &_concatDim)
      case 1001: handled = try setter.decodeOptionalMessageField(fieldType: HDF5OutputParameter.self, value: &_hdf5OutputParam)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _name {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 1, protoFieldName: "name", jsonFieldName: "name", swiftFieldName: "name")
      }
      if let v = _type {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 2, protoFieldName: "type", jsonFieldName: "type", swiftFieldName: "type")
      }
      if let v = _numOutput {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 3, protoFieldName: "num_output", jsonFieldName: "numOutput", swiftFieldName: "numOutput")
      }
      if let v = _biasterm {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 4, protoFieldName: "biasterm", jsonFieldName: "biasterm", swiftFieldName: "biasterm")
      }
      if let v = _weightFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 5, protoFieldName: "weight_filler", jsonFieldName: "weightFiller", swiftFieldName: "weightFiller")
      }
      if let v = _biasFiller {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 6, protoFieldName: "bias_filler", jsonFieldName: "biasFiller", swiftFieldName: "biasFiller")
      }
      if let v = _pad {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 7, protoFieldName: "pad", jsonFieldName: "pad", swiftFieldName: "pad")
      }
      if let v = _kernelsize {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 8, protoFieldName: "kernelsize", jsonFieldName: "kernelsize", swiftFieldName: "kernelsize")
      }
      if let v = _group {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 9, protoFieldName: "group", jsonFieldName: "group", swiftFieldName: "group")
      }
      if let v = _stride {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 10, protoFieldName: "stride", jsonFieldName: "stride", swiftFieldName: "stride")
      }
      if let v = _pool {
        try visitor.visitSingularField(fieldType: V0LayerParameter.PoolMethod.self, value: v, protoFieldNumber: 11, protoFieldName: "pool", jsonFieldName: "pool", swiftFieldName: "pool")
      }
      if let v = _dropoutRatio {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 12, protoFieldName: "dropout_ratio", jsonFieldName: "dropoutRatio", swiftFieldName: "dropoutRatio")
      }
      if let v = _localSize {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 13, protoFieldName: "local_size", jsonFieldName: "localSize", swiftFieldName: "localSize")
      }
      if let v = _alpha {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 14, protoFieldName: "alpha", jsonFieldName: "alpha", swiftFieldName: "alpha")
      }
      if let v = _beta {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 15, protoFieldName: "beta", jsonFieldName: "beta", swiftFieldName: "beta")
      }
      if let v = _source {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 16, protoFieldName: "source", jsonFieldName: "source", swiftFieldName: "source")
      }
      if let v = _scale {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 17, protoFieldName: "scale", jsonFieldName: "scale", swiftFieldName: "scale")
      }
      if let v = _meanfile {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 18, protoFieldName: "meanfile", jsonFieldName: "meanfile", swiftFieldName: "meanfile")
      }
      if let v = _batchsize {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 19, protoFieldName: "batchsize", jsonFieldName: "batchsize", swiftFieldName: "batchsize")
      }
      if let v = _cropsize {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 20, protoFieldName: "cropsize", jsonFieldName: "cropsize", swiftFieldName: "cropsize")
      }
      if let v = _mirror {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 21, protoFieldName: "mirror", jsonFieldName: "mirror", swiftFieldName: "mirror")
      }
      if let v = _k {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 22, protoFieldName: "k", jsonFieldName: "k", swiftFieldName: "k")
      }
      if !_blobs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _blobs, protoFieldNumber: 50, protoFieldName: "blobs", jsonFieldName: "blobs", swiftFieldName: "blobs")
      }
      if !_blobsLr.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: _blobsLr, protoFieldNumber: 51, protoFieldName: "blobs_lr", jsonFieldName: "blobsLr", swiftFieldName: "blobsLr")
      }
      if !_weightDecay.isEmpty {
        try visitor.visitRepeatedField(fieldType: ProtobufFloat.self, value: _weightDecay, protoFieldNumber: 52, protoFieldName: "weight_decay", jsonFieldName: "weightDecay", swiftFieldName: "weightDecay")
      }
      if let v = _randSkip {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 53, protoFieldName: "rand_skip", jsonFieldName: "randSkip", swiftFieldName: "randSkip")
      }
      if let v = _detFgThreshold {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 54, protoFieldName: "det_fg_threshold", jsonFieldName: "detFgThreshold", swiftFieldName: "detFgThreshold")
      }
      if let v = _detBgThreshold {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 55, protoFieldName: "det_bg_threshold", jsonFieldName: "detBgThreshold", swiftFieldName: "detBgThreshold")
      }
      if let v = _detFgFraction {
        try visitor.visitSingularField(fieldType: ProtobufFloat.self, value: v, protoFieldNumber: 56, protoFieldName: "det_fg_fraction", jsonFieldName: "detFgFraction", swiftFieldName: "detFgFraction")
      }
      if let v = _detContextPad {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 58, protoFieldName: "det_context_pad", jsonFieldName: "detContextPad", swiftFieldName: "detContextPad")
      }
      if let v = _detCropMode {
        try visitor.visitSingularField(fieldType: ProtobufString.self, value: v, protoFieldNumber: 59, protoFieldName: "det_crop_mode", jsonFieldName: "detCropMode", swiftFieldName: "detCropMode")
      }
      if let v = _newNum {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 60, protoFieldName: "new_num", jsonFieldName: "newNum", swiftFieldName: "newNum")
      }
      if let v = _newChannels {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 61, protoFieldName: "new_channels", jsonFieldName: "newChannels", swiftFieldName: "newChannels")
      }
      if let v = _newHeight {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 62, protoFieldName: "new_height", jsonFieldName: "newHeight", swiftFieldName: "newHeight")
      }
      if let v = _newWidth {
        try visitor.visitSingularField(fieldType: ProtobufInt32.self, value: v, protoFieldNumber: 63, protoFieldName: "new_width", jsonFieldName: "newWidth", swiftFieldName: "newWidth")
      }
      if let v = _shuffleImages {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 64, protoFieldName: "shuffle_images", jsonFieldName: "shuffleImages", swiftFieldName: "shuffleImages")
      }
      if let v = _concatDim {
        try visitor.visitSingularField(fieldType: ProtobufUInt32.self, value: v, protoFieldNumber: 65, protoFieldName: "concat_dim", jsonFieldName: "concatDim", swiftFieldName: "concatDim")
      }
      if let v = _hdf5OutputParam {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1001, protoFieldName: "hdf5_output_param", jsonFieldName: "hdf5OutputParam", swiftFieldName: "hdf5OutputParam")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_name != nil || other._name != nil) && (_name == nil || other._name == nil || _name! != other._name!)) {return false}
      if ((_type != nil || other._type != nil) && (_type == nil || other._type == nil || _type! != other._type!)) {return false}
      if ((_numOutput != nil || other._numOutput != nil) && (_numOutput == nil || other._numOutput == nil || _numOutput! != other._numOutput!)) {return false}
      if (((_biasterm != nil && _biasterm! != true) || (other._biasterm != nil && other._biasterm! != true)) && (_biasterm == nil || other._biasterm == nil || _biasterm! != other._biasterm!)) {return false}
      if ((_weightFiller != nil || other._weightFiller != nil) && (_weightFiller == nil || other._weightFiller == nil || _weightFiller! != other._weightFiller!)) {return false}
      if ((_biasFiller != nil || other._biasFiller != nil) && (_biasFiller == nil || other._biasFiller == nil || _biasFiller! != other._biasFiller!)) {return false}
      if (((_pad != nil && _pad! != 0) || (other._pad != nil && other._pad! != 0)) && (_pad == nil || other._pad == nil || _pad! != other._pad!)) {return false}
      if ((_kernelsize != nil || other._kernelsize != nil) && (_kernelsize == nil || other._kernelsize == nil || _kernelsize! != other._kernelsize!)) {return false}
      if (((_group != nil && _group! != 1) || (other._group != nil && other._group! != 1)) && (_group == nil || other._group == nil || _group! != other._group!)) {return false}
      if (((_stride != nil && _stride! != 1) || (other._stride != nil && other._stride! != 1)) && (_stride == nil || other._stride == nil || _stride! != other._stride!)) {return false}
      if (((_pool != nil && _pool! != V0LayerParameter.PoolMethod.max) || (other._pool != nil && other._pool! != V0LayerParameter.PoolMethod.max)) && (_pool == nil || other._pool == nil || _pool! != other._pool!)) {return false}
      if (((_dropoutRatio != nil && _dropoutRatio! != 0.5) || (other._dropoutRatio != nil && other._dropoutRatio! != 0.5)) && (_dropoutRatio == nil || other._dropoutRatio == nil || _dropoutRatio! != other._dropoutRatio!)) {return false}
      if (((_localSize != nil && _localSize! != 5) || (other._localSize != nil && other._localSize! != 5)) && (_localSize == nil || other._localSize == nil || _localSize! != other._localSize!)) {return false}
      if (((_alpha != nil && _alpha! != 1) || (other._alpha != nil && other._alpha! != 1)) && (_alpha == nil || other._alpha == nil || _alpha! != other._alpha!)) {return false}
      if (((_beta != nil && _beta! != 0.75) || (other._beta != nil && other._beta! != 0.75)) && (_beta == nil || other._beta == nil || _beta! != other._beta!)) {return false}
      if (((_k != nil && _k! != 1) || (other._k != nil && other._k! != 1)) && (_k == nil || other._k == nil || _k! != other._k!)) {return false}
      if ((_source != nil || other._source != nil) && (_source == nil || other._source == nil || _source! != other._source!)) {return false}
      if (((_scale != nil && _scale! != 1) || (other._scale != nil && other._scale! != 1)) && (_scale == nil || other._scale == nil || _scale! != other._scale!)) {return false}
      if ((_meanfile != nil || other._meanfile != nil) && (_meanfile == nil || other._meanfile == nil || _meanfile! != other._meanfile!)) {return false}
      if ((_batchsize != nil || other._batchsize != nil) && (_batchsize == nil || other._batchsize == nil || _batchsize! != other._batchsize!)) {return false}
      if (((_cropsize != nil && _cropsize! != 0) || (other._cropsize != nil && other._cropsize! != 0)) && (_cropsize == nil || other._cropsize == nil || _cropsize! != other._cropsize!)) {return false}
      if (((_mirror != nil && _mirror! != false) || (other._mirror != nil && other._mirror! != false)) && (_mirror == nil || other._mirror == nil || _mirror! != other._mirror!)) {return false}
      if _blobs != other._blobs {return false}
      if _blobsLr != other._blobsLr {return false}
      if _weightDecay != other._weightDecay {return false}
      if (((_randSkip != nil && _randSkip! != 0) || (other._randSkip != nil && other._randSkip! != 0)) && (_randSkip == nil || other._randSkip == nil || _randSkip! != other._randSkip!)) {return false}
      if (((_detFgThreshold != nil && _detFgThreshold! != 0.5) || (other._detFgThreshold != nil && other._detFgThreshold! != 0.5)) && (_detFgThreshold == nil || other._detFgThreshold == nil || _detFgThreshold! != other._detFgThreshold!)) {return false}
      if (((_detBgThreshold != nil && _detBgThreshold! != 0.5) || (other._detBgThreshold != nil && other._detBgThreshold! != 0.5)) && (_detBgThreshold == nil || other._detBgThreshold == nil || _detBgThreshold! != other._detBgThreshold!)) {return false}
      if (((_detFgFraction != nil && _detFgFraction! != 0.25) || (other._detFgFraction != nil && other._detFgFraction! != 0.25)) && (_detFgFraction == nil || other._detFgFraction == nil || _detFgFraction! != other._detFgFraction!)) {return false}
      if (((_detContextPad != nil && _detContextPad! != 0) || (other._detContextPad != nil && other._detContextPad! != 0)) && (_detContextPad == nil || other._detContextPad == nil || _detContextPad! != other._detContextPad!)) {return false}
      if (((_detCropMode != nil && _detCropMode! != "warp") || (other._detCropMode != nil && other._detCropMode! != "warp")) && (_detCropMode == nil || other._detCropMode == nil || _detCropMode! != other._detCropMode!)) {return false}
      if (((_newNum != nil && _newNum! != 0) || (other._newNum != nil && other._newNum! != 0)) && (_newNum == nil || other._newNum == nil || _newNum! != other._newNum!)) {return false}
      if (((_newChannels != nil && _newChannels! != 0) || (other._newChannels != nil && other._newChannels! != 0)) && (_newChannels == nil || other._newChannels == nil || _newChannels! != other._newChannels!)) {return false}
      if (((_newHeight != nil && _newHeight! != 0) || (other._newHeight != nil && other._newHeight! != 0)) && (_newHeight == nil || other._newHeight == nil || _newHeight! != other._newHeight!)) {return false}
      if (((_newWidth != nil && _newWidth! != 0) || (other._newWidth != nil && other._newWidth! != 0)) && (_newWidth == nil || other._newWidth == nil || _newWidth! != other._newWidth!)) {return false}
      if (((_shuffleImages != nil && _shuffleImages! != false) || (other._shuffleImages != nil && other._shuffleImages! != false)) && (_shuffleImages == nil || other._shuffleImages == nil || _shuffleImages! != other._shuffleImages!)) {return false}
      if (((_concatDim != nil && _concatDim! != 1) || (other._concatDim != nil && other._concatDim! != 1)) && (_concatDim == nil || other._concatDim == nil || _concatDim! != other._concatDim!)) {return false}
      if ((_hdf5OutputParam != nil || other._hdf5OutputParam != nil) && (_hdf5OutputParam == nil || other._hdf5OutputParam == nil || _hdf5OutputParam! != other._hdf5OutputParam!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._name = _name
      clone._type = _type
      clone._numOutput = _numOutput
      clone._biasterm = _biasterm
      clone._weightFiller = _weightFiller
      clone._biasFiller = _biasFiller
      clone._pad = _pad
      clone._kernelsize = _kernelsize
      clone._group = _group
      clone._stride = _stride
      clone._pool = _pool
      clone._dropoutRatio = _dropoutRatio
      clone._localSize = _localSize
      clone._alpha = _alpha
      clone._beta = _beta
      clone._k = _k
      clone._source = _source
      clone._scale = _scale
      clone._meanfile = _meanfile
      clone._batchsize = _batchsize
      clone._cropsize = _cropsize
      clone._mirror = _mirror
      clone._blobs = _blobs
      clone._blobsLr = _blobsLr
      clone._weightDecay = _weightDecay
      clone._randSkip = _randSkip
      clone._detFgThreshold = _detFgThreshold
      clone._detBgThreshold = _detBgThreshold
      clone._detFgFraction = _detFgFraction
      clone._detContextPad = _detContextPad
      clone._detCropMode = _detCropMode
      clone._newNum = _newNum
      clone._newChannels = _newChannels
      clone._newHeight = _newHeight
      clone._newWidth = _newWidth
      clone._shuffleImages = _shuffleImages
      clone._concatDim = _concatDim
      clone._hdf5OutputParam = _hdf5OutputParam
      return clone
    }
  }

  private var _storage = _StorageClass()

  public enum PoolMethod: ProtobufEnum {
    public typealias RawValue = Int
    case max // = 0
    case ave // = 1
    case stochastic // = 2

    public init() {
      self = .max
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .max
      case 1: self = .ave
      case 2: self = .stochastic
      default: return nil
      }
    }

    public init?(name: String) {
      switch name {
      case "max": self = .max
      case "ave": self = .ave
      case "stochastic": self = .stochastic
      default: return nil
      }
    }

    public init?(jsonName: String) {
      switch jsonName {
      case "MAX": self = .max
      case "AVE": self = .ave
      case "STOCHASTIC": self = .stochastic
      default: return nil
      }
    }

    public init?(protoName: String) {
      switch protoName {
      case "MAX": self = .max
      case "AVE": self = .ave
      case "STOCHASTIC": self = .stochastic
      default: return nil
      }
    }

    public var rawValue: Int {
      get {
        switch self {
        case .max: return 0
        case .ave: return 1
        case .stochastic: return 2
        }
      }
    }

    public var json: String {
      get {
        switch self {
        case .max: return "\"MAX\""
        case .ave: return "\"AVE\""
        case .stochastic: return "\"STOCHASTIC\""
        }
      }
    }

    public var hashValue: Int { return rawValue }

    public var debugDescription: String {
      get {
        switch self {
        case .max: return ".max"
        case .ave: return ".ave"
        case .stochastic: return ".stochastic"
        }
      }
    }

  }

  ///   the layer name
  public var name: String? {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  ///   the string to specify the layer type
  public var type: String? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///   Parameters to specify layers with inner products.
  public var numOutput: UInt32? {
    get {return _storage._numOutput}
    set {_uniqueStorage()._numOutput = newValue}
  }

  ///   whether to have bias terms
  public var biasterm: Bool? {
    get {return _storage._biasterm ?? true}
    set {_uniqueStorage()._biasterm = newValue}
  }

  ///   The filler for the weight
  public var weightFiller: FillerParameter? {
    get {return _storage._weightFiller}
    set {_uniqueStorage()._weightFiller = newValue}
  }

  ///   The filler for the bias
  public var biasFiller: FillerParameter? {
    get {return _storage._biasFiller}
    set {_uniqueStorage()._biasFiller = newValue}
  }

  ///   The padding size
  public var pad: UInt32? {
    get {return _storage._pad ?? 0}
    set {_uniqueStorage()._pad = newValue}
  }

  ///   The kernel size
  public var kernelsize: UInt32? {
    get {return _storage._kernelsize}
    set {_uniqueStorage()._kernelsize = newValue}
  }

  ///   The group size for group conv
  public var group: UInt32? {
    get {return _storage._group ?? 1}
    set {_uniqueStorage()._group = newValue}
  }

  ///   The stride
  public var stride: UInt32? {
    get {return _storage._stride ?? 1}
    set {_uniqueStorage()._stride = newValue}
  }

  ///   The pooling method
  public var pool: V0LayerParameter.PoolMethod? {
    get {return _storage._pool ?? V0LayerParameter.PoolMethod.max}
    set {_uniqueStorage()._pool = newValue}
  }

  ///   dropout ratio
  public var dropoutRatio: Float? {
    get {return _storage._dropoutRatio ?? 0.5}
    set {_uniqueStorage()._dropoutRatio = newValue}
  }

  ///   for local response norm
  public var localSize: UInt32? {
    get {return _storage._localSize ?? 5}
    set {_uniqueStorage()._localSize = newValue}
  }

  ///   for local response norm
  public var alpha: Float? {
    get {return _storage._alpha ?? 1}
    set {_uniqueStorage()._alpha = newValue}
  }

  ///   for local response norm
  public var beta: Float? {
    get {return _storage._beta ?? 0.75}
    set {_uniqueStorage()._beta = newValue}
  }

  public var k: Float? {
    get {return _storage._k ?? 1}
    set {_uniqueStorage()._k = newValue}
  }

  ///   For data layers, specify the data source
  public var source: String? {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  ///   For data pre-processing, we can do simple scaling and subtracting the
  ///   data mean, if provided. Note that the mean subtraction is always carried
  ///   out before scaling.
  public var scale: Float? {
    get {return _storage._scale ?? 1}
    set {_uniqueStorage()._scale = newValue}
  }

  public var meanfile: String? {
    get {return _storage._meanfile}
    set {_uniqueStorage()._meanfile = newValue}
  }

  ///   For data layers, specify the batch size.
  public var batchsize: UInt32? {
    get {return _storage._batchsize}
    set {_uniqueStorage()._batchsize = newValue}
  }

  ///   For data layers, specify if we would like to randomly crop an image.
  public var cropsize: UInt32? {
    get {return _storage._cropsize ?? 0}
    set {_uniqueStorage()._cropsize = newValue}
  }

  ///   For data layers, specify if we want to randomly mirror data.
  public var mirror: Bool? {
    get {return _storage._mirror ?? false}
    set {_uniqueStorage()._mirror = newValue}
  }

  ///   The blobs containing the numeric parameters of the layer
  public var blobs: [BlobProto] {
    get {return _storage._blobs}
    set {_uniqueStorage()._blobs = newValue}
  }

  ///   The ratio that is multiplied on the global learning rate. If you want to
  ///   set the learning ratio for one blob, you need to set it for all blobs.
  public var blobsLr: [Float] {
    get {return _storage._blobsLr}
    set {_uniqueStorage()._blobsLr = newValue}
  }

  ///   The weight decay that is multiplied on the global weight decay.
  public var weightDecay: [Float] {
    get {return _storage._weightDecay}
    set {_uniqueStorage()._weightDecay = newValue}
  }

  ///   The rand_skip variable is for the data layer to skip a few data points
  ///   to avoid all asynchronous sgd clients to start at the same point. The skip
  ///   point would be set as rand_skip * rand(0,1). Note that rand_skip should not
  ///   be larger than the number of keys in the database.
  public var randSkip: UInt32? {
    get {return _storage._randSkip ?? 0}
    set {_uniqueStorage()._randSkip = newValue}
  }

  ///   Fields related to detection (det_*)
  ///   foreground (object) overlap threshold
  public var detFgThreshold: Float? {
    get {return _storage._detFgThreshold ?? 0.5}
    set {_uniqueStorage()._detFgThreshold = newValue}
  }

  ///   background (non-object) overlap threshold
  public var detBgThreshold: Float? {
    get {return _storage._detBgThreshold ?? 0.5}
    set {_uniqueStorage()._detBgThreshold = newValue}
  }

  ///   Fraction of batch that should be foreground objects
  public var detFgFraction: Float? {
    get {return _storage._detFgFraction ?? 0.25}
    set {_uniqueStorage()._detFgFraction = newValue}
  }

  //  optional bool OBSOLETE_can_clobber = 57 [default = true];

  ///   Amount of contextual padding to add around a window
  ///   (used only by the window_data_layer)
  public var detContextPad: UInt32? {
    get {return _storage._detContextPad ?? 0}
    set {_uniqueStorage()._detContextPad = newValue}
  }

  ///   Mode for cropping out a detection window
  ///   warp: cropped window is warped to a fixed size and aspect ratio
  ///   square: the tightest square around the window is cropped
  public var detCropMode: String? {
    get {return _storage._detCropMode ?? "warp"}
    set {_uniqueStorage()._detCropMode = newValue}
  }

  ///   For ReshapeLayer, one needs to specify the new dimensions.
  public var newNum: Int32? {
    get {return _storage._newNum ?? 0}
    set {_uniqueStorage()._newNum = newValue}
  }

  public var newChannels: Int32? {
    get {return _storage._newChannels ?? 0}
    set {_uniqueStorage()._newChannels = newValue}
  }

  public var newHeight: Int32? {
    get {return _storage._newHeight ?? 0}
    set {_uniqueStorage()._newHeight = newValue}
  }

  public var newWidth: Int32? {
    get {return _storage._newWidth ?? 0}
    set {_uniqueStorage()._newWidth = newValue}
  }

  ///   Whether or not ImageLayer should shuffle the list of files at every epoch.
  ///   It will also resize images if new_height or new_width are not zero.
  public var shuffleImages: Bool? {
    get {return _storage._shuffleImages ?? false}
    set {_uniqueStorage()._shuffleImages = newValue}
  }

  ///   For ConcatLayer, one needs to specify the dimension for concatenation, and
  ///   the other dimensions must be the same for all the bottom blobs.
  ///   By default it will concatenate blobs along the channels dimension.
  public var concatDim: UInt32? {
    get {return _storage._concatDim ?? 1}
    set {_uniqueStorage()._concatDim = newValue}
  }

  public var hdf5OutputParam: HDF5OutputParameter? {
    get {return _storage._hdf5OutputParam}
    set {_uniqueStorage()._hdf5OutputParam = newValue}
  }

  public init() {}

  public init(name: String? = nil,
    type: String? = nil,
    numOutput: UInt32? = nil,
    biasterm: Bool? = nil,
    weightFiller: FillerParameter? = nil,
    biasFiller: FillerParameter? = nil,
    pad: UInt32? = nil,
    kernelsize: UInt32? = nil,
    group: UInt32? = nil,
    stride: UInt32? = nil,
    pool: V0LayerParameter.PoolMethod? = nil,
    dropoutRatio: Float? = nil,
    localSize: UInt32? = nil,
    alpha: Float? = nil,
    beta: Float? = nil,
    k: Float? = nil,
    source: String? = nil,
    scale: Float? = nil,
    meanfile: String? = nil,
    batchsize: UInt32? = nil,
    cropsize: UInt32? = nil,
    mirror: Bool? = nil,
    blobs: [BlobProto] = [],
    blobsLr: [Float] = [],
    weightDecay: [Float] = [],
    randSkip: UInt32? = nil,
    detFgThreshold: Float? = nil,
    detBgThreshold: Float? = nil,
    detFgFraction: Float? = nil,
    detContextPad: UInt32? = nil,
    detCropMode: String? = nil,
    newNum: Int32? = nil,
    newChannels: Int32? = nil,
    newHeight: Int32? = nil,
    newWidth: Int32? = nil,
    shuffleImages: Bool? = nil,
    concatDim: UInt32? = nil,
    hdf5OutputParam: HDF5OutputParameter? = nil)
  {
    let storage = _uniqueStorage()
    storage._name = name
    storage._type = type
    storage._numOutput = numOutput
    storage._biasterm = biasterm
    storage._weightFiller = weightFiller
    storage._biasFiller = biasFiller
    storage._pad = pad
    storage._kernelsize = kernelsize
    storage._group = group
    storage._stride = stride
    storage._pool = pool
    storage._dropoutRatio = dropoutRatio
    storage._localSize = localSize
    storage._alpha = alpha
    storage._beta = beta
    storage._k = k
    storage._source = source
    storage._scale = scale
    storage._meanfile = meanfile
    storage._batchsize = batchsize
    storage._cropsize = cropsize
    storage._mirror = mirror
    if !blobs.isEmpty {
      storage._blobs = blobs
    }
    if !blobsLr.isEmpty {
      storage._blobsLr = blobsLr
    }
    if !weightDecay.isEmpty {
      storage._weightDecay = weightDecay
    }
    storage._randSkip = randSkip
    storage._detFgThreshold = detFgThreshold
    storage._detBgThreshold = detBgThreshold
    storage._detFgFraction = detFgFraction
    storage._detContextPad = detContextPad
    storage._detCropMode = detCropMode
    storage._newNum = newNum
    storage._newChannels = newChannels
    storage._newHeight = newHeight
    storage._newWidth = newWidth
    storage._shuffleImages = shuffleImages
    storage._concatDim = concatDim
    storage._hdf5OutputParam = hdf5OutputParam
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: V0LayerParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}

///   Parametric ReLU described in K. He et al, Delving Deep into Rectifiers:
///   Surpassing Human-Level Performance on ImageNet Classification, 2015.
public struct PReLUParameter: ProtobufGeneratedMessage {
  public var swiftClassName: String {return "PReLUParameter"}
  public var protoMessageName: String {return "PReLUParameter"}
  public var protoPackageName: String {return ""}
  public var jsonFieldNames: [String: Int] {return [
    "filler": 1,
    "channelShared": 2,
  ]}
  public var protoFieldNames: [String: Int] {return [
    "filler": 1,
    "channel_shared": 2,
  ]}

  private class _StorageClass {
    typealias ProtobufExtendedMessage = PReLUParameter
    var unknown = ProtobufUnknownStorage()
    var _filler: FillerParameter? = nil
    var _channelShared: Bool? = nil

    init() {}

    func decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
      let handled: Bool
      switch protoFieldNumber {
      case 1: handled = try setter.decodeOptionalMessageField(fieldType: FillerParameter.self, value: &_filler)
      case 2: handled = try setter.decodeOptionalField(fieldType: ProtobufBool.self, value: &_channelShared)
      default:
        handled = false
      }
      if handled {
          return true
      } else {
          return try unknown.decodeField(setter: &setter)
      }
    }

    func traverse(visitor: inout ProtobufVisitor) throws {
      if let v = _filler {
        try visitor.visitSingularMessageField(value: v, protoFieldNumber: 1, protoFieldName: "filler", jsonFieldName: "filler", swiftFieldName: "filler")
      }
      if let v = _channelShared {
        try visitor.visitSingularField(fieldType: ProtobufBool.self, value: v, protoFieldNumber: 2, protoFieldName: "channel_shared", jsonFieldName: "channelShared", swiftFieldName: "channelShared")
      }
      unknown.traverse(visitor: &visitor)
    }

    func isEqualTo(other: _StorageClass) -> Bool {
      if ((_filler != nil || other._filler != nil) && (_filler == nil || other._filler == nil || _filler! != other._filler!)) {return false}
      if (((_channelShared != nil && _channelShared! != false) || (other._channelShared != nil && other._channelShared! != false)) && (_channelShared == nil || other._channelShared == nil || _channelShared! != other._channelShared!)) {return false}
      if unknown != other.unknown {return false}
      return true
    }

    func copy() -> _StorageClass {
      let clone = _StorageClass()
      clone.unknown = unknown
      clone._filler = _filler
      clone._channelShared = _channelShared
      return clone
    }
  }

  private var _storage = _StorageClass()

  ///   Initial value of a_i. Default is a_i=0.25 for all i.
  public var filler: FillerParameter? {
    get {return _storage._filler}
    set {_uniqueStorage()._filler = newValue}
  }

  ///   Whether or not slope parameters are shared across channels.
  public var channelShared: Bool? {
    get {return _storage._channelShared ?? false}
    set {_uniqueStorage()._channelShared = newValue}
  }

  public init() {}

  public init(filler: FillerParameter? = nil,
    channelShared: Bool? = nil)
  {
    let storage = _uniqueStorage()
    storage._filler = filler
    storage._channelShared = channelShared
  }

  public mutating func _protoc_generated_decodeField(setter: inout ProtobufFieldDecoder, protoFieldNumber: Int) throws -> Bool {
    return try _uniqueStorage().decodeField(setter: &setter, protoFieldNumber: protoFieldNumber)
  }

  public func _protoc_generated_traverse(visitor: inout ProtobufVisitor) throws {
    try _storage.traverse(visitor: &visitor)
  }

  public func _protoc_generated_isEqualTo(other: PReLUParameter) -> Bool {
    return _storage === other._storage || _storage.isEqualTo(other: other._storage)
  }

  private mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _storage.copy()
    }
    return _storage
  }
}
